{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to DSA &amp; Tech Notes \ud83d\udc4b","text":"<p>This site contains AI-generated DSA solutions and Tech Notes, updated twice daily. Browse topics from the sidebar to explore notes and solutions.</p>"},{"location":"instructions/","title":"Instructions","text":"<p>This project automatically generates DSA practice questions + solutions and notes using the Gemini API,  and pushes them to GitHub twice daily at random times.</p>"},{"location":"instructions/#features","title":"Features","text":"<ul> <li>DSA problems (Easy/Medium/Hard)</li> <li>Notes for selected topic of the day</li> <li>Two commits per day (1 file per commit)</li> <li>File names are topic-related, not by timestamp</li> <li>Supports separate React, Java, and DSA notes folders</li> </ul>"},{"location":"instructions/#setup","title":"Setup","text":"<ol> <li>Clone this repository.</li> <li>Install dependencies:    <code>bash    pip install -r requirements.txt</code></li> <li>Add your GitHub repository remote.</li> <li>Run the automation with:    <code>bash    python main.py</code></li> </ol>"},{"location":"instructions/#notes","title":"Notes","text":"<ul> <li>Uses Gemini API (your API key is already embedded in <code>config.py</code>).</li> <li>DSA questions source: LeetCode + curated list (you can extend <code>topics.json</code>).</li> <li>Notes are saved in <code>.txt</code> format inside <code>/notes</code>.</li> </ul> <p>git add . git commit -m \"first commit\" git push origin nitesh-branch</p> <p>git add . git commit -m \"first commit\" git push origin main</p> <p>git checkout main git pull origin main git merge nitesh-branch git push origin main</p>"},{"location":"dsa/","title":"DSA Notes","text":"<p>Welcome to the DSA section! \ud83d\ude80</p>"},{"location":"dsa/easy/Add_Digits/","title":"Problem: Add Digits","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Add_Digits/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Array_Partition_I/","title":"Problem: Array Partition I","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Array_Partition_I/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/ConvertBinaryNumberinaLinkedListtoInteger/","title":"ConvertBinaryNumberinaLinkedListtoInteger","text":""},{"location":"dsa/easy/ConvertBinaryNumberinaLinkedListtoInteger/#summary-of-approach","title":"Summary of Approach","text":"<p>The Java solution to convert a binary number represented as a singly linked list to an integer iterates through the linked list.  Each node represents a bit (0 or 1).  The algorithm starts with an integer result initialized to 0.  It then iterates through the linked list, multiplying the current result by 2 (left-shifting) and adding the value of the current node. This effectively builds the integer representation of the binary number.</p>"},{"location":"dsa/easy/ConvertBinaryNumberinaLinkedListtoInteger/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time Complexity: O(n) where n is the number of nodes in the linked list.  The algorithm iterates through the linked list once.</li> <li>Space Complexity: O(1). The algorithm uses a constant amount of extra space regardless of the size of the linked list.  Only a few variables are used to store the current node, the result integer, and potentially a temporary variable.</li> </ul>"},{"location":"dsa/easy/Convert_Sorted_Array_to_Binary_Search_Tree/","title":"Problem: Convert Sorted Array to Binary Search Tree","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Convert_Sorted_Array_to_Binary_Search_Tree/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/DetectCapital/","title":"DetectCapital","text":""},{"location":"dsa/easy/DetectCapital/#summary-of-approach","title":"Summary of Approach","text":"<p>The problem \"Detect Capital\" asks to determine if a given string has all capital letters, all lowercase letters, or only the first letter is capitalized.  The solution iterates through the string.  It first checks if the first character is uppercase.  Then, it checks the rest of the string:</p> <ul> <li>If the first character is uppercase: It checks if the remaining characters are all lowercase. If not, it checks if the remaining characters are all uppercase.</li> <li>If the first character is lowercase: It checks if the remaining characters are all lowercase.</li> </ul> <p>If any of these conditions (all uppercase, all lowercase, first uppercase rest lowercase) are true, the function returns <code>true</code>; otherwise, it returns <code>false</code>.</p>"},{"location":"dsa/easy/DetectCapital/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(n), where n is the length of the input string. The algorithm iterates through the string once.</li> <li>Space: O(1). The algorithm uses a constant amount of extra space regardless of the input string size.</li> </ul>"},{"location":"dsa/easy/Detect_Capital/","title":"Problem: Detect Capital","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Detect_Capital/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Find_All_Numbers_Disappeared_in_an_Array/","title":"Problem: Find All Numbers Disappeared in an Array","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Find_All_Numbers_Disappeared_in_an_Array/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Find_N_Unique_Integers_Sum_up_to_Zero/","title":"Problem: Find N Unique Integers Sum up to Zero","text":""},{"location":"dsa/easy/Find_N_Unique_Integers_Sum_up_to_Zero/#summary-of-approach","title":"Summary of Approach","text":"<p>The problem asks to find <code>N</code> unique integers that sum up to zero.  A simple and efficient approach leverages the properties of integers. We can construct a solution by creating a sequence of integers from <code>-N/2</code> to <code>N/2 -1</code> (if <code>N</code> is even) or from <code>-(N-1)/2</code> to <code>(N-1)/2</code> (if <code>N</code> is odd). This sequence inherently sums to zero due to the cancellation of positive and negative pairs.  If <code>N</code> is even, we include <code>0</code> as the middle element of the array which doesn't affect the sum. We then simply need to return this sequence of integers as an array.</p>"},{"location":"dsa/easy/Find_N_Unique_Integers_Sum_up_to_Zero/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(N) - Creating the array of integers takes linear time proportional to N.</li> <li>Space: O(N) - The space used by the array of integers is proportional to N.</li> </ul>"},{"location":"dsa/easy/Find_N_Unique_Integers_Sum_up_to_Zero/#java-solution","title":"Java Solution","text":"<pre><code>/*\nGiven an integer n, return any array containing n unique integers that sum up to 0.\n\nExample 1:\nInput: n = 5\nOutput: [-7,-1,1,3,4]\nExplanation: These are unique integers and sum up to 0.\n\nExample 2:\nInput: n = 3\nOutput: [-1,0,1]\n\nExample 3:\nInput: n = 1\nOutput: [0]\n\nConstraints:\n1 &lt;= n &lt;= 1000\n*/\n/*\nDifficulty: Easy\n*/\nclass FindNUniqueIntegersSumUpToZero {\n    public int[] sumZero(int n) {\n        int[] result = new int[n];\n        int sum = 0;\n        for (int i = 0; i &lt; n - 1; i++) {\n            result[i] = i + 1;\n            sum += result[i];\n        }\n        result[n - 1] = -sum;\n        return result;\n    }\n}\n</code></pre>"},{"location":"dsa/easy/Hamming_Distance/","title":"Problem: Hamming Distance","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Hamming_Distance/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Intersection_of_Two_Arrays_II/","title":"Problem: Intersection of Two Arrays II","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Intersection_of_Two_Arrays_II/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Largest_Number_At_Least_Twice_of_Others/","title":"Problem: Largest Number At Least Twice of Others","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Largest_Number_At_Least_Twice_of_Others/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Longest_Palindrome/","title":"Problem: Longest Palindrome","text":""},{"location":"dsa/easy/Longest_Palindrome/#summary-of-approach","title":"Summary of Approach","text":"<p>The \"Longest Palindrome\" problem aims to find the longest palindromic substring within a given string.  Several approaches exist, but a common and efficient one uses a dynamic programming technique or a slightly optimized expansion around center approach.</p> <p>Dynamic Programming Approach: This approach builds a table <code>dp</code> where <code>dp[i][j]</code> is true if the substring from index <code>i</code> to <code>j</code> is a palindrome, and false otherwise.  It iterates through the string, checking substrings of increasing length.  The base cases are single characters (which are palindromes) and two-character substrings.  For longer substrings, it checks if the characters at the ends are equal and if the inner substring (excluding the ends) is also a palindrome (this is checked using the <code>dp</code> table).  The longest palindrome's length is then easily determined.</p> <p>Expansion Around Center Approach: This approach is often preferred for its slightly better space efficiency. It iterates through each character (and between each character pair) as a potential center of a palindrome. It then expands outwards from the center, checking for palindrome properties.  It keeps track of the longest palindrome found so far.  This method avoids the explicit creation of a large DP table.</p>"},{"location":"dsa/easy/Longest_Palindrome/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(n^2) for both dynamic programming and expansion around center approaches.  The nested loops in the dynamic programming approach or the expanding outwards in the expansion around center approach lead to a quadratic time complexity.</li> <li>Space: O(n^2) for the dynamic programming approach due to the <code>dp</code> table of size n x n.  O(1) for the expansion around center approach because it only uses a few variables to track the longest palindrome found.</li> </ul>"},{"location":"dsa/easy/Longest_Palindrome/#java-solution","title":"Java Solution","text":"<pre><code>/*\nQuestion: Longest Palindrome\nDifficulty: Medium\n\nGiven a string s, find the longest palindromic substring in s.\n\nExample 1:\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\nExample 2:\nInput: s = \"cbbd\"\nOutput: \"bb\"\n*/\nclass LongestPalindrome {\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() &lt; 1) return \"\";\n        int start = 0, end = 0;\n        for (int i = 0; i &lt; s.length(); i++) {\n            int len1 = expandAroundCenter(s, i, i);\n            int len2 = expandAroundCenter(s, i, i + 1);\n            int len = Math.max(len1, len2);\n            if (len &gt; end - start) {\n                start = i - (len - 1) / 2;\n                end = i + len / 2;\n            }\n        }\n        return s.substring(start, end + 1);\n    }\n\n    private int expandAroundCenter(String s, int left, int right) {\n        int L = left, R = right;\n        while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) {\n            L--;\n            R++;\n        }\n        return R - L - 1;\n    }\n}\n</code></pre>"},{"location":"dsa/easy/Maximum_Depth_of_Binary_Tree/","title":"Problem: Maximum Depth of Binary Tree","text":""},{"location":"dsa/easy/Maximum_Depth_of_Binary_Tree/#summary-of-approach","title":"Summary of Approach","text":"<p>The Maximum Depth of Binary Tree problem aims to find the maximum depth (height) of a given binary tree.  The approach uses Depth-First Search (DFS), specifically a recursive solution.  The function recursively explores the left and right subtrees of each node.  For each node, the depth is calculated as 1 plus the maximum depth of its left and right subtrees. The base case is an empty tree (null node), which has a depth of 0.  The maximum depth across all paths from the root to the leaves is then returned.  Iterative solutions using a stack or queue are also possible, but the recursive solution is often considered more concise and easier to understand.</p>"},{"location":"dsa/easy/Maximum_Depth_of_Binary_Tree/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(N) where N is the number of nodes in the binary tree.  This is because each node is visited exactly once.</li> <li>Space: O(H) where H is the height of the binary tree. In the worst case (a skewed tree), H can be equal to N, resulting in O(N) space complexity.  This space is used for the recursive call stack.  For a balanced tree, H would be log\u2082(N), leading to O(log\u2082(N)) space complexity.</li> </ul>"},{"location":"dsa/easy/Maximum_Depth_of_Binary_Tree/#java-solution","title":"Java Solution","text":"<pre><code>/**\n * Given the root of a binary tree, return its maximum depth.\n * A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n * Difficulty: Easy\n */\nclass MaximumDepthOfBinaryTree {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        } else {\n            int leftDepth = maxDepth(root.left);\n            int rightDepth = maxDepth(root.right);\n            return Math.max(leftDepth, rightDepth) + 1;\n        }\n    }\n\n    public class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode() {}\n        TreeNode(int val) { this.val = val; }\n        TreeNode(int val, TreeNode left, TreeNode right) {\n            this.val = val;\n            this.left = left;\n            this.right = right;\n        }\n    }\n}\n</code></pre>"},{"location":"dsa/easy/Move_Zeroes/","title":"Problem: Move Zeroes","text":""},{"location":"dsa/easy/Move_Zeroes/#summary-of-approach","title":"Summary of Approach","text":"<p>The \"Move Zeroes\" problem requires rearranging the elements of an array such that all the zeroes are moved to the end while maintaining the relative order of the non-zero elements.  A two-pointer approach is efficient. One pointer (<code>nonZeroIndex</code>) tracks the index where the next non-zero element should be placed. The other pointer (<code>currentIndex</code>) iterates through the array.  If <code>currentIndex</code> encounters a non-zero element, it's swapped with the element at <code>nonZeroIndex</code>, and both pointers advance. If <code>currentIndex</code> encounters a zero, only <code>currentIndex</code> advances.  This ensures that all non-zero elements are compacted to the beginning, effectively moving zeroes to the end.</p>"},{"location":"dsa/easy/Move_Zeroes/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(n) - The algorithm iterates through the array once. Swapping elements takes constant time.</li> <li>Space: O(1) - The algorithm operates in place; it doesn't use extra space proportional to the input size.</li> </ul>"},{"location":"dsa/easy/Move_Zeroes/#java-solution","title":"Java Solution","text":"<pre><code>/*\nGiven an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\nNote that you must do this in-place without making a copy of the array.\n\nExample 1:\n\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\nExample 2:\n\nInput: nums = [0]\nOutput: [0]\nExample 3:\n\nInput: nums = [0,0,1]\nOutput: [1,0,0]\n\nConstraints:\n\n1 &lt;= nums.length &lt;= 104\n-231 &lt;= nums[i] &lt;= 231 - 1\n\nDifficulty: Easy\n*/\nclass MoveZeroes {\n    public void moveZeroes(int[] nums) {\n        int k=0;\n        for(int i=0; i&lt;nums.length; i++){\n            if(nums[i]!=0){\n                nums[k]=nums[i];\n                k++;\n            }\n        }\n        for(int i=k; i&lt;nums.length; i++){\n            nums[i]=0;\n        }\n    }\n}\n</code></pre>"},{"location":"dsa/easy/N-th_Tribonacci_Number/","title":"Problem: N-th Tribonacci Number","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/N-th_Tribonacci_Number/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Palindrome_Number/","title":"Problem: Palindrome Number","text":""},{"location":"dsa/easy/Palindrome_Number/#summary-of-approach","title":"Summary of Approach","text":"<p>The problem is to determine if an integer is a palindrome.  A palindrome reads the same forwards and backward. The approach avoids converting the integer to a string. Instead, it reverses the second half of the integer using integer arithmetic and compares it to the first half. This is more efficient than string conversion, especially for very large numbers.  The algorithm proceeds as follows:</p> <ol> <li> <p>Find the number of digits:  Determine the number of digits in the input integer <code>x</code>. This can be done using logarithms or repeatedly dividing by 10.</p> </li> <li> <p>Reverse the second half:  Extract the second half of the digits and reverse it. This is done by repeatedly dividing <code>x</code> by 10 to remove digits from the right, and building up the reversed second half.</p> </li> <li> <p>Compare: Compare the reversed second half to the first half of the original number. If they are equal, the number is a palindrome; otherwise, it is not.</p> </li> <li> <p>Handle negative numbers and numbers ending in zero: Negative numbers and numbers ending in zero cannot be palindromes, so these cases are handled as special cases for early exit to improve efficiency.</p> </li> </ol>"},{"location":"dsa/easy/Palindrome_Number/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(log\u2081\u2080(n))</li> <li>Space: O(1)</li> </ul> <p>The time complexity is logarithmic because the number of operations required is proportional to the number of digits in the integer, which is logarithmic in the value of the integer. The space complexity is constant because only a few extra integer variables are used, regardless of the size of the input integer.</p>"},{"location":"dsa/easy/Palindrome_Number/#java-solution","title":"Java Solution","text":"<pre><code>/*\nGiven an integer x, return true if x is a palindrome, and false otherwise.\n\nDifficulty: Easy\n*/\nclass PalindromeNumber {\n    public boolean isPalindrome(int x) {\n        if (x &lt; 0) return false;\n        String s = Integer.toString(x);\n        int n = s.length();\n        for (int i = 0; i &lt; n / 2; i++) {\n            if (s.charAt(i) != s.charAt(n - 1 - i)) return false;\n        }\n        return true;\n    }\n}\n</code></pre>"},{"location":"dsa/easy/Path_Sum/","title":"Problem: Path Sum","text":""},{"location":"dsa/easy/Path_Sum/#summary-of-approach","title":"Summary of Approach","text":"<p>The Path Sum problem aims to determine if a path exists from the root to a leaf node in a binary tree such that the sum of the nodes along that path equals a given target sum.  The approach typically uses Depth-First Search (DFS), either recursively or iteratively.</p> <p>A recursive approach explores the left and right subtrees, adding the current node's value to the running sum.  If a leaf node is reached and the running sum matches the target, the function returns <code>true</code>.  If the sum exceeds the target at any point, that branch is pruned.</p> <p>An iterative approach employs a stack (or queue for Breadth-First Search, though less common for this problem) to simulate the recursive calls.  It systematically explores nodes, keeping track of the running sum for each path.</p>"},{"location":"dsa/easy/Path_Sum/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li> <p>Time: O(N) where N is the number of nodes in the binary tree. In the worst case, the algorithm visits every node in the tree.</p> </li> <li> <p>Space: O(H) where H is the height of the binary tree.  This accounts for the recursive call stack in the recursive approach or the stack used in the iterative approach.  In the worst case (a skewed tree), H can be equal to N.  In the best case (a balanced tree), H is log\u2082N.</p> </li> </ul>"},{"location":"dsa/easy/Path_Sum/#java-solution","title":"Java Solution","text":"<pre><code>/**\n * Path Sum\n * Difficulty: Easy\n * Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\n * A leaf is a node with no children.\n */\nclass PathSum {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if (root == null) {\n            return false;\n        }\n        if (root.left == null &amp;&amp; root.right == null) {\n            return targetSum == root.val;\n        }\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n    }\n\n    public class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode() {}\n        TreeNode(int val) { this.val = val; }\n        TreeNode(int val, TreeNode left, TreeNode right) {\n            this.val = val;\n            this.left = left;\n            this.right = right;\n        }\n    }\n}\n</code></pre>"},{"location":"dsa/easy/Power_of_Three/","title":"Problem: Power of Three","text":""},{"location":"dsa/easy/Power_of_Three/#summary-of-approach","title":"Summary of Approach","text":"<p>The \"Power of Three\" problem asks whether a given integer <code>n</code> is a power of three.  The most efficient approach leverages the properties of base-3 logarithms and integer division.  We can repeatedly divide <code>n</code> by 3 until either <code>n</code> becomes 1 (indicating it's a power of 3) or <code>n</code> is no longer divisible by 3 (indicating it's not a power of 3).  Alternatively, a more concise solution uses the fact that powers of 3 are the only integers that are divisible by 3 repeatedly until they become 1.  This can be checked by repeatedly dividing by 3 and verifying the remainder is always 0, finally checking if the result is 1.  Another approach uses a lookup table for powers of 3 within a reasonable range, but this is less efficient for very large inputs.</p>"},{"location":"dsa/easy/Power_of_Three/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(log\u2083n)  The number of divisions by 3 is proportional to the base-3 logarithm of n.  In the worst case, it's logarithmic with respect to the input.</li> <li>Space: O(1) The algorithm uses a constant amount of extra space, regardless of the input size.</li> </ul>"},{"location":"dsa/easy/Power_of_Three/#java-solution","title":"Java Solution","text":"<pre><code>/*\nGiven an integer n, return true if it is a power of three. Otherwise, return false.\n\nAn integer n is a power of three, if there exists an integer x such that n == 3x.\n\nExample 1:\nInput: n = 27\nOutput: true\n\nExample 2:\nInput: n = 0\nOutput: false\n\nExample 3:\nInput: n = 9\nOutput: true\n\nConstraints:\n-231 &lt;= n &lt;= 231 - 1\n\nDifficulty: Easy\n*/\nclass PowerOfThree {\n    public boolean isPowerOfThree(int n) {\n        if (n &lt;= 0) return false;\n        while (n % 3 == 0) {\n            n /= 3;\n        }\n        return n == 1;\n    }\n}\n</code></pre>"},{"location":"dsa/easy/Remove_Duplicates_from_Sorted_List/","title":"Problem: Remove Duplicates from Sorted List","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Remove_Duplicates_from_Sorted_List/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Remove_Element/","title":"Problem: Remove Element","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Remove_Element/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Reverse_Vowels_of_a_String/","title":"Problem: Reverse Vowels of a String","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Reverse_Vowels_of_a_String/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Sort_Array_By_Parity/","title":"Problem: Sort Array By Parity","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Sort_Array_By_Parity/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Sum_of_Two_Integers/","title":"Problem: Sum of Two Integers","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Sum_of_Two_Integers/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Teemo_Attacking/","title":"Problem: Teemo Attacking","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Teemo_Attacking/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Two_Furthest_Houses_With_Different_Colors/","title":"Problem: Two Furthest Houses With Different Colors","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Two_Furthest_Houses_With_Different_Colors/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Two_Sum/","title":"Problem: Two Sum","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Two_Sum/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Ugly_Number/","title":"Problem: Ugly Number","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Ugly_Number/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/easy/Valid_Sudoku/","title":"Problem: Valid Sudoku","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/easy/Valid_Sudoku/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Basic_Calculator_II/","title":"Problem: Basic Calculator II","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Basic_Calculator_II/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Binary_Tree_Maximum_Path_Sum/","title":"Problem: Binary Tree Maximum Path Sum","text":""},{"location":"dsa/hard/Binary_Tree_Maximum_Path_Sum/#summary-of-approach","title":"Summary of Approach","text":"<p>The problem is to find the maximum sum of a path between any two nodes in a binary tree.  The path doesn't need to pass through the root.</p> <p>A recursive approach is most effective. For each node, we calculate the maximum path sum that ends at that node. This involves considering the maximum path sum from the left subtree, the maximum path sum from the right subtree, and adding the node's value.  We maintain a global variable <code>max_sum</code> to track the overall maximum path sum encountered so far.</p> <p>Crucially, the maximum path sum might not necessarily end at any given node. It could be a path entirely within the left or right subtree, or a path connecting a node's left and right subtrees through the node itself.  Therefore, for each node, we also compute the maximum path sum that includes the current node as its peak (i.e., using both left and right subtrees if available).  This maximum path sum through a node is then compared against the global <code>max_sum</code>.</p> <p>The recursion explores the entire tree, and for each node, a constant number of calculations are performed.</p>"},{"location":"dsa/hard/Binary_Tree_Maximum_Path_Sum/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(N), where N is the number of nodes in the binary tree. Each node is visited exactly once during the recursive traversal.</li> <li>Space: O(H), where H is the height of the binary tree. This space is used for the recursive call stack. In the worst case (a skewed tree), H can be equal to N, resulting in O(N) space complexity.  In the best case (a balanced tree), H is log\u2082(N), resulting in O(log N) space complexity.</li> </ul>"},{"location":"dsa/hard/Binary_Tree_Maximum_Path_Sum/#java-solution","title":"Java Solution","text":"<pre><code>/**\n * Given a non-empty binary tree, find the maximum path sum.\n * For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections.\n * The path must contain at least one node and does not need to go through the root.\n *\n * Difficulty: Hard\n */\nclass BinaryTreeMaximumPathSum {\n    int maxSum = Integer.MIN_VALUE;\n\n    public int maxPathSum(TreeNode root) {\n        maxPathSumHelper(root);\n        return maxSum;\n    }\n\n    private int maxPathSumHelper(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n\n        int leftSum = Math.max(0, maxPathSumHelper(node.left));\n        int rightSum = Math.max(0, maxPathSumHelper(node.right));\n\n        maxSum = Math.max(maxSum, leftSum + rightSum + node.val);\n\n        return Math.max(leftSum, rightSum) + node.val;\n    }\n\n    public class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        TreeNode(int x) {\n            val = x;\n        }\n    }\n}\n</code></pre>"},{"location":"dsa/hard/Candy/","title":"Problem: Candy","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Candy/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Candy_Crush/","title":"Problem: Candy Crush","text":"<p>\u26a0\ufe0f Error generating content: 429 You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits. [violations {   quota_metric: \"generativelanguage.googleapis.com/generate_content_free_tier_requests\"   quota_id: \"GenerateRequestsPerDayPerProjectPerModel-FreeTier\"   quota_dimensions {     key: \"model\"     value: \"gemini-1.5-flash\"   }   quota_dimensions {     key: \"location\"     value: \"global\"   }   quota_value: 50 } , links {   description: \"Learn more about Gemini API quotas\"   url: \"https://ai.google.dev/gemini-api/docs/rate-limits\" } , retry_delay {   seconds: 23 } ]</p>"},{"location":"dsa/hard/Candy_Crush/#java-solution","title":"Java Solution","text":"<pre><code>// Candy Crush\n// Difficulty: Medium\n\nclass CandyCrush {\n    public int[][] candyCrush(int[][] board) {\n        int m = board.length;\n        int n = board[0].length;\n        boolean changed = true;\n\n        while (changed) {\n            changed = false;\n            // Find and crush candies\n            for (int i = 0; i &lt; m; i++) {\n                for (int j = 0; j &lt; n; j++) {\n                    if (board[i][j] != 0) {\n                        int count = 1;\n                        // Check horizontally\n                        int k = j + 1;\n                        while (k &lt; n &amp;&amp; board[i][k] == board[i][j]) {\n                            count++;\n                            k++;\n                        }\n                        if (count &gt;= 3) {\n                            changed = true;\n                            for (int l = j; l &lt; j + count; l++) {\n                                board[i][l] = 0;\n                            }\n                        }\n                        //Check vertically\n                        count = 1;\n                        k = i + 1;\n                        while (k &lt; m &amp;&amp; board[k][j] == board[i][j]) {\n                            count++;\n                            k++;\n                        }\n                        if (count &gt;= 3) {\n                            changed = true;\n                            for (int l = i; l &lt; i + count; l++) {\n                                board[l][j] = 0;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Drop candies\n            for (int j = 0; j &lt; n; j++) {\n                int emptyRow = m - 1;\n                for (int i = m - 1; i &gt;= 0; i--) {\n                    if (board[i][j] != 0) {\n                        board[emptyRow][j] = board[i][j];\n                        if (emptyRow != i) {\n                            board[i][j] = 0;\n                        }\n                        emptyRow--;\n                    }\n                }\n            }\n        }\n        return board;\n    }\n}\n</code></pre>"},{"location":"dsa/hard/Concatenated_Words/","title":"Problem: Concatenated Words","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Concatenated_Words/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Count_All_Valid_Pickup_Delivery_Options/","title":"Problem: Count All Valid Pickup Delivery Options","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Count_All_Valid_Pickup_Delivery_Options/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Count_Subarrays_With_Median_K/","title":"Problem: Count Subarrays With Median K","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Count_Subarrays_With_Median_K/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Count_of_Smaller_Numbers_After_Self/","title":"Problem: Count of Smaller Numbers After Self","text":""},{"location":"dsa/hard/Count_of_Smaller_Numbers_After_Self/#summary-of-approach","title":"Summary of Approach","text":"<p>The \"Count of Smaller Numbers After Self\" problem asks to find, for each element in an input array, the number of smaller elements that appear after it in the array.  A naive approach would involve nested loops, comparing each element to all subsequent elements, resulting in O(n\u00b2) time complexity.  However, a more efficient solution utilizes a merge sort-like approach.</p> <p>The algorithm employs a modified merge sort.  During the merge phase, we track the number of smaller elements encountered from the right subarray as we merge the two sorted subarrays. This count represents the number of smaller elements after the current element in the original array.  We store these counts in a separate array, which is then returned as the result.  The key is that the merging process implicitly handles the comparison of elements in a way that's more efficient than brute-force comparison.  Specifically, because the subarrays are sorted, we can efficiently determine how many elements from the right subarray are smaller than an element from the left subarray without needing to explicitly compare every pair.</p>"},{"location":"dsa/hard/Count_of_Smaller_Numbers_After_Self/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(n log n) - This is due to the merge sort algorithm which dominates the runtime. The merging process itself takes linear time within each recursive step.</li> <li>Space: O(n) - This is primarily due to the auxiliary space used by the merge sort algorithm (for the temporary array during merging) and the array to store the counts of smaller elements.  In some implementations, the recursive call stack could also contribute to the space complexity, but it's generally considered O(log n) due to the balanced nature of merge sort, which is subsumed by the O(n) term.</li> </ul>"},{"location":"dsa/hard/Count_of_Smaller_Numbers_After_Self/#java-solution","title":"Java Solution","text":"<pre><code>import java.util.Arrays;\n\n/*\nGiven an array nums, calculate the count of smaller numbers to the right of each number in the array.\nDifficulty:Medium\n*/\nclass CountOfSmallerNumbersAfterSelf {\n    public List&lt;Integer&gt; countSmaller(int[] nums) {\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        if (nums == null || nums.length == 0) {\n            return result;\n        }\n\n        int n = nums.length;\n        for (int i = 0; i &lt; n; i++) {\n            int count = 0;\n            for (int j = i + 1; j &lt; n; j++) {\n                if (nums[j] &lt; nums[i]) {\n                    count++;\n                }\n            }\n            result.add(count);\n        }\n        return result;\n    }\n}\n</code></pre>"},{"location":"dsa/hard/Critical_Connections_in_a_Network/","title":"Problem: Critical Connections in a Network","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Critical_Connections_in_a_Network/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Distinct_Subsequences/","title":"Problem: Distinct Subsequences","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Distinct_Subsequences/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Find_K-th_Smallest_Pair_Distance/","title":"Problem: Find K-th Smallest Pair Distance","text":""},{"location":"dsa/hard/Find_K-th_Smallest_Pair_Distance/#summary-of-approach","title":"Summary of Approach","text":"<p>The problem \"Find K-th Smallest Pair Distance\" aims to find the k-th smallest absolute difference between any two numbers in a given integer array <code>nums</code>.  The most efficient approach utilizes a combination of sorting and binary search.</p> <ol> <li> <p>Sort the array:  Sorting the input array <code>nums</code> allows us to efficiently explore potential pair distances.</p> </li> <li> <p>Binary Search the Distance: We perform a binary search on the range of possible distances (from 0 to the maximum difference between two elements in the sorted array). For each potential distance <code>mid</code>, we count the number of pairs in the sorted array whose difference is less than or equal to <code>mid</code>. This count can be efficiently determined using a two-pointer technique.</p> </li> <li> <p>Refine the Search: Based on the count obtained in step 2, we adjust the search space in the binary search. If the count is less than <code>k</code>, we need to search for larger distances; otherwise, we search for smaller distances.</p> </li> <li> <p>Return the Result:  The binary search eventually converges to the <code>k</code>-th smallest pair distance.</p> </li> </ol>"},{"location":"dsa/hard/Find_K-th_Smallest_Pair_Distance/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li> <p>Time: O(n log n + n log w), where n is the length of the input array and w is the range of possible distances (approximately the maximum element minus the minimum element). The O(n log n) term comes from sorting, and the O(n log w) term comes from the binary search which performs a linear scan (O(n)) for each distance considered in the logarithmic number of steps (log w).  In many cases, w is significantly smaller than n, making the overall complexity dominated by the sorting step.</p> </li> <li> <p>Space: O(1) or O(n) depending on the sorting algorithm used.  In-place sorting algorithms (like HeapSort) achieve O(1) space complexity, while others (like merge sort) might require O(n) auxiliary space.  The counting process in the binary search requires only a constant amount of extra space.</p> </li> </ul>"},{"location":"dsa/hard/Find_K-th_Smallest_Pair_Distance/#java-solution","title":"Java Solution","text":"<pre><code>import java.util.Arrays;\n\n/*\nFind K-th Smallest Pair Distance\n\nDifficulty: Hard\n\nGiven an integer array nums and an integer k, return the kth smallest distance among all the pairs of the array.\n\nThe distance of a pair (nums[i], nums[j]) is abs(nums[i] - nums[j]).\n\nExample 1:\n\nInput: nums = [1,3,1], k = 1\nOutput: 0\nExplanation: Here are all the pairs:\n(1,3) -&gt; 2\n(1,1) -&gt; 0\n(3,1) -&gt; 2\nThen the 1st smallest distance pair is (1,1), and its distance is 0.\n\nExample 2:\n\nInput: nums = [1,1,1], k = 2\nOutput: 0\n\nExample 3:\n\nInput: nums = [1,6,1], k = 3\nOutput: 5\n\n\nConstraints:\n\nn == nums.length\n2 &lt;= n &lt;= 104\n0 &lt;= nums[i] &lt;= 108\n1 &lt;= k &lt;= n * (n - 1) / 2\n*/\nclass FindKthSmallestPairDistance {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        int left = 0, right = nums[n - 1] - nums[0];\n        while (left &lt; right) {\n            int mid = left + (right - left) / 2;\n            int count = 0, j = 0;\n            for (int i = 0; i &lt; n; i++) {\n                while (j &lt; n &amp;&amp; nums[j] - nums[i] &lt;= mid) {\n                    j++;\n                }\n                count += j - i - 1;\n            }\n            if (count &lt; k) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n}\n</code></pre>"},{"location":"dsa/hard/Find_Two_Non-overlapping_Sub-arrays_Each_With_Targ/","title":"Problem: Find Two Non-overlapping Sub-arrays Each With Target Sum","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Find_Two_Non-overlapping_Sub-arrays_Each_With_Targ/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Find_the_Shortest_Superstring/","title":"Find the Shortest Superstring","text":""},{"location":"dsa/hard/Find_the_Shortest_Superstring/#summary-of-approach","title":"Summary of Approach","text":"<p>The Shortest Superstring problem aims to find the shortest string that contains all given strings as substrings.  Several approaches exist, but a common and relatively efficient one involves using a greedy algorithm combined with a graph representation.</p> <p>The algorithm typically works as follows:</p> <ol> <li> <p>Overlap Graph Construction: Create a directed graph where each node represents a string from the input set.  The weighted edges represent the overlap between pairs of strings.  The weight of an edge from string <code>a</code> to string <code>b</code> is the length of the maximum overlap between the suffix of <code>a</code> and the prefix of <code>b</code>.</p> </li> <li> <p>Finding a Hamiltonian Path: The problem then reduces to finding a Hamiltonian path (a path that visits each node exactly once) in the overlap graph that minimizes the total weight. This is an NP-hard problem, so heuristics are often used.  A common greedy approach iteratively selects the edge with the maximum weight (longest overlap) and merges the corresponding strings until all strings are combined.  This doesn't guarantee the absolute shortest superstring, but provides a good approximation.</p> </li> <li> <p>String Construction: Once a Hamiltonian path is found, the strings are concatenated based on the order determined by the path, removing the overlapping portions to construct the shortest superstring (according to the heuristic).</p> </li> </ol>"},{"location":"dsa/hard/Find_the_Shortest_Superstring/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li> <p>Time: O(n^2 * m + n^3)  where 'n' is the number of strings and 'm' is the maximum length of a string.  The O(n^2 * m) term comes from computing the overlap between all pairs of strings. The O(n^3) term arises from the greedy algorithm for finding a Hamiltonian path (which can be implemented with algorithms like Held-Karp, although simpler heuristics are frequently used that may have different complexities).  Note that the exact time complexity depends heavily on the chosen heuristic for finding the Hamiltonian path. A naive approach could be much worse.</p> </li> <li> <p>Space: O(n * m)  This is primarily due to storing the overlap graph (an adjacency matrix or similar representation) and the input strings. The space required to store intermediate results during string concatenation is relatively small compared to this.</p> </li> </ul>"},{"location":"dsa/hard/Frog_Jump/","title":"Problem: Frog Jump","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Frog_Jump/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/K_Inverse_Pairs_Array/","title":"Problem: K Inverse Pairs Array","text":""},{"location":"dsa/hard/K_Inverse_Pairs_Array/#summary-of-approach","title":"Summary of Approach","text":"<p>The K Inverse Pairs Array problem aims to find the number of permutations of integers from 1 to n that have exactly k inverse pairs.  An inverse pair is a pair (i, j) such that i &lt; j but P[i] &gt; P[j], where P is a permutation.  A dynamic programming approach is efficient for solving this.</p> <p>We can build a DP table <code>dp[i][j]</code> where <code>dp[i][j]</code> represents the number of permutations of integers from 1 to <code>i</code> with exactly <code>j</code> inverse pairs.  The base case is <code>dp[1][0] = 1</code> (one permutation of 1 element has 0 inversions).</p> <p>We can iteratively compute <code>dp[i][j]</code> by considering the placement of the element <code>i</code>. When we add <code>i</code> to a permutation of <code>i-1</code> elements with <code>k</code> inversions, we can add <code>0</code> to <code>i-1</code> new inversions.  The number of inversions added depends on where <code>i</code> is placed in the existing permutation.  Therefore, the recurrence relation becomes:</p> <p><code>dp[i][j] = sum(dp[i-1][j-k])</code> for k from 0 to min(j, i-1)</p> <p>This means we sum up the number of permutations of <code>i-1</code> elements with <code>j-k</code> inversions for all possible values of <code>k</code> (number of new inversions added by placing <code>i</code>).  The result <code>dp[i][j]</code> gives the number of permutations of <code>i</code> elements with <code>j</code> inverse pairs. Finally, we return <code>dp[n][k]</code>.  Optimization can be achieved by using modulo arithmetic to avoid integer overflow.</p>"},{"location":"dsa/hard/K_Inverse_Pairs_Array/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(nkn) or O(nk) depending on implementation.  The naive approach is O(nkn) as there is a nested loop structure (outer loop iterates n times, inner loops iterate up to k times each, and the inner most summation has an upper bound of n). A space optimized approach using only two rows can reduce this to O(nk).</li> <li>Space: O(n*k) for the DP table.  Can be reduced to O(k) using space optimization.</li> </ul>"},{"location":"dsa/hard/K_Inverse_Pairs_Array/#java-solution","title":"Java Solution","text":"<pre><code>/*\nK Inverse Pairs Array\nHard\n\nGiven an integer n and an integer k, return the number of arrays of length n such that the number of inverse pairs is equal to k.\n\nAn inverse pair is a pair of integers (i, j) such that i &lt; j and a[i] &gt; a[j].\n\nSince the answer can be very large, return it modulo 109 + 7.\n\n\nExample 1:\n\nInput: n = 3, k = 0\nOutput: 1\nExplanation: Only the array [1,2,3] has 0 inverse pairs.\nExample 2:\n\nInput: n = 3, k = 1\nOutput: 2\nExplanation: The arrays [1,3,2] and [2,1,3] have 1 inverse pair.\n\n\nConstraints:\n\n1 &lt;= n &lt;= 1000\n0 &lt;= k &lt;= 1000\n*/\nclass KInversePairsArray {\n    private static final int MOD = 1000000007;\n\n    public int kInversePairs(int n, int k) {\n        int[][] dp = new int[n + 1][k + 1];\n        dp[0][0] = 1;\n\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = 0; j &lt;= k; j++) {\n                for (int p = 0; p &lt;= j &amp;&amp; p &lt; i; p++) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - p]) % MOD;\n                }\n            }\n        }\n        return dp[n][k];\n    }\n}\n</code></pre>"},{"location":"dsa/hard/LongestCommonSubsequence/","title":"LongestCommonSubsequence","text":""},{"location":"dsa/hard/LongestCommonSubsequence/#summary-of-approach","title":"Summary of Approach","text":"<p>The Longest Common Subsequence (LCS) problem aims to find the longest subsequence common to all sequences in a set of sequences (often just two).  A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.  The approach typically uses dynamic programming.  A matrix (or table) is constructed where <code>dp[i][j]</code> represents the length of the LCS of the first <code>i</code> elements of the first sequence and the first <code>j</code> elements of the second sequence.  The matrix is filled iteratively:</p> <ul> <li>If the <code>i</code>-th element of the first sequence equals the <code>j</code>-th element of the second sequence, then <code>dp[i][j] = dp[i-1][j-1] + 1</code> (we extend the LCS by one).</li> <li>Otherwise, <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code> (we take the longer LCS from either omitting the <code>i</code>-th element of the first sequence or the <code>j</code>-th element of the second sequence).</li> </ul> <p>The value <code>dp[m][n]</code> (where <code>m</code> and <code>n</code> are the lengths of the two sequences) represents the length of the LCS.  To reconstruct the actual LCS, one can backtrack through the matrix from <code>dp[m][n]</code>.</p>"},{"location":"dsa/hard/LongestCommonSubsequence/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(mn) where 'm' and 'n' are the lengths of the two input sequences. This is because the algorithm iterates through an m x n matrix.</li> <li>Space: O(mn)  The space complexity is dominated by the size of the dynamic programming matrix.  While space optimization techniques exist to reduce this to O(min(m, n)), the basic approach uses O(mn) space.</li> </ul>"},{"location":"dsa/hard/Longest_Increasing_Path_in_a_Matrix/","title":"Problem: Longest Increasing Path in a Matrix","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Longest_Increasing_Path_in_a_Matrix/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Maximal_Sum_Circular_Subarray/","title":"Problem: Maximal Sum Circular Subarray","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Maximal_Sum_Circular_Subarray/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/MaximizeScoreAfterNOperations/","title":"MaximizeScoreAfterNOperations","text":""},{"location":"dsa/hard/MaximizeScoreAfterNOperations/#summary-of-approach","title":"Summary of Approach","text":"<p>The problem \"Maximize Score After N Operations\" involves selecting pairs of numbers from a given array such that the product of each pair's indices plus the product of the numbers themselves contributes to a total score. The goal is to maximize this score after performing N operations.  A key observation is that we can't just greedily pick the pairs with the highest scores at each step because that could prevent optimal pairings later on.</p> <p>The most efficient approach uses dynamic programming (DP) to solve this problem.  We define a DP state <code>dp[i][mask]</code> representing the maximum score achievable after <code>i</code> operations, where <code>mask</code> is a bitmask indicating which numbers have already been used.  The DP transition considers all possible pairs of unused numbers and updates the score accordingly.  The algorithm iterates through all possible states, updating the maximum score at each step until <code>N</code> operations are complete. The final answer is the maximum score achievable in <code>dp[N][mask]</code> across all possible masks after <code>N</code> operations.  A bitmask is used for efficient tracking of selected numbers.</p>"},{"location":"dsa/hard/MaximizeScoreAfterNOperations/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li> <p>Time: O(N * 2<sup>M</sup> * M), where N is the number of operations and M is the number of numbers in the input array. This is because there are N operations, 2<sup>M</sup> possible masks (subsets of numbers), and potentially M operations to find a pair within each mask.</p> </li> <li> <p>Space: O(N * 2<sup>M</sup>).  This is the space used to store the DP table <code>dp[i][mask]</code>.</p> </li> </ul>"},{"location":"dsa/hard/Maximize_Score_After_N_Operations/","title":"Problem: Maximize Score After N Operations","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Maximize_Score_After_N_Operations/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Maximum_Good_People_vs_Bad_People/","title":"Problem: Maximum Good People vs Bad People","text":""},{"location":"dsa/hard/Maximum_Good_People_vs_Bad_People/#summary-of-approach","title":"Summary of Approach","text":"<p>The \"Maximum Good People vs Bad People\" problem aims to find the maximum number of good people you can have in a group, given constraints represented by a matrix.  Each row in the matrix represents a statement made by a person, indicating whether another person is good or bad.  The goal is to find an assignment of \"good\" or \"bad\" to each person that satisfies the maximum number of these statements, without creating any contradictions (e.g., someone saying person A is good while another says person A is bad).</p> <p>The most efficient approach usually involves exploring all possible assignments of \"good\" or \"bad\" to each person. This can be done systematically using bit manipulation or recursion.  For each assignment, we check the number of satisfied statements. The assignment that maximizes the satisfied statements is the solution.  Optimization techniques like memoization or dynamic programming can be applied (although they might not drastically improve the time complexity in the worst case).</p>"},{"location":"dsa/hard/Maximum_Good_People_vs_Bad_People/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li> <p>Time: O(2<sup>n</sup> * m), where n is the number of people and m is the number of statements (rows in the matrix).  This is because we potentially need to iterate through all 2<sup>n</sup> possible assignments of good/bad to each person, and for each assignment, we need to check m statements.</p> </li> <li> <p>Space: O(n) or O(m) depending on the implementation.  O(n) space might be needed to store the current assignment of good/bad for each person. O(m) may be needed to store the statement matrix (if a copy is created). In some cases, with careful in-place operations, the space complexity might be even lower, approaching O(1). Note that recursive approaches might also incur additional space complexity due to the call stack.</p> </li> </ul>"},{"location":"dsa/hard/Maximum_Good_People_vs_Bad_People/#java-solution","title":"Java Solution","text":"<pre><code>/*\nQuestion: Maximum Good People vs Bad People\nDifficulty: Medium\n\nYou are given a 0-indexed 2D integer array statements of size n x n where statements[i][j] represents the statement made by the ith person about the jth person.\nstatements[i][j] = 0 represents that the ith person thinks the jth person is bad.\nstatements[i][j] = 1 represents that the ith person thinks the jth person is good.\nstatements[i][j] = 2 represents that the ith person does not know whether the jth person is good or bad.\n\nReturn the maximum number of people who can be good.\n\n\nExample 1:\nInput: statements = [[2,1,2],[1,2,2],[2,0,1]]\nOutput: 2\nExplanation:\n- Person 0 thinks person 1 is good and person 2 is bad.\n- Person 1 thinks person 0 is good and person 2 is bad.\n- Person 2 thinks person 1 is good.\n\nLet's assume person 1 is good. Then person 0 is good, and person 2 is bad.\nLet's assume person 1 is bad. Then person 0 is bad, and person 2 is good.\nThe maximum number of good people is 2.\n\nExample 2:\nInput: statements = [[1,1,1],[1,1,1],[1,1,1]]\nOutput: 3\nExplanation: All people can be good.\n\n\nConstraints:\nn == statements.length == statements[i].length\n1 &lt;= n &lt;= 15\nstatements[i][j] is either 0, 1, or 2.\n*/\nclass MaximumGoodPeopleVsBadPeople {\n    public int maximumGood(int[][] statements) {\n        int n = statements.length;\n        int maxGood = 0;\n        for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) {\n            int goodCount = 0;\n            boolean possible = true;\n            boolean[] good = new boolean[n];\n            for (int j = 0; j &lt; n; ++j) {\n                if ((i &gt;&gt; j) % 2 == 1) {\n                    good[j] = true;\n                    goodCount++;\n                }\n            }\n\n            for (int j = 0; j &lt; n; ++j) {\n                for (int k = 0; k &lt; n; ++k) {\n                    if (statements[j][k] != 2) {\n                        boolean isGood = good[k];\n                        boolean statement = statements[j][k] == 1;\n                        if (good[j] &amp;&amp; isGood != statement) {\n                            possible = false;\n                            break;\n                        }\n                    }\n                }\n                if (!possible) break;\n            }\n            if (possible) maxGood = Math.max(maxGood, goodCount);\n        }\n        return maxGood;\n    }\n}\n</code></pre>"},{"location":"dsa/hard/Maximum_Number_of_Events_That_Can_Be_Attended_II/","title":"Problem: Maximum Number of Events That Can Be Attended II","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Maximum_Number_of_Events_That_Can_Be_Attended_II/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Maximum_Performance_of_a_Team/","title":"Problem: Maximum Performance of a Team","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Maximum_Performance_of_a_Team/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Median_of_Two_Sorted_Arrays/","title":"Problem: Median of Two Sorted Arrays","text":""},{"location":"dsa/hard/Median_of_Two_Sorted_Arrays/#summary-of-approach","title":"Summary of Approach","text":"<p>The \"Median of Two Sorted Arrays\" problem aims to find the median of two sorted arrays efficiently.  A naive approach would involve merging the two arrays and then finding the median. However, this is inefficient.  A more optimal approach uses a divide-and-conquer strategy.  We can avoid fully merging the arrays by employing binary search. The algorithm focuses on finding a partition point in both arrays such that the elements to the left of this point in both arrays constitute the smaller half of the combined array.  By recursively narrowing down the search space using binary search on the smaller array, we efficiently identify the partition points and subsequently compute the median.  The key insight is that the partition points must satisfy a specific condition related to the elements immediately before and after them to ensure we have the correct number of elements on each side to represent the median.</p>"},{"location":"dsa/hard/Median_of_Two_Sorted_Arrays/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(log(min(m, n))) where 'm' and 'n' are the lengths of the input arrays.  This is due to the binary search performed on the smaller array.</li> <li>Space: O(1). The algorithm uses constant extra space, regardless of the input size.  It operates primarily in-place.</li> </ul>"},{"location":"dsa/hard/Median_of_Two_Sorted_Arrays/#java-solution","title":"Java Solution","text":"<pre><code>// Median of Two Sorted Arrays\n// Difficulty: Hard\n\nclass MedianOfTwoSortedArrays {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int m = nums1.length;\n        int n = nums2.length;\n        if (m &gt; n) {\n            return findMedianSortedArrays(nums2, nums1); // Ensure nums1 is shorter\n        }\n        int low = 0, high = m;\n        while (low &lt;= high) {\n            int partitionX = (low + high) / 2;\n            int partitionY = (m + n + 1) / 2 - partitionX;\n            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n            int minRightX = (partitionX == m) ? Integer.MAX_VALUE : nums1[partitionX];\n            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n            int minRightY = (partitionY == n) ? Integer.MAX_VALUE : nums2[partitionY];\n            if (maxLeftX &lt;= minRightY &amp;&amp; maxLeftY &lt;= minRightX) {\n                if ((m + n) % 2 == 0) {\n                    return (double) (Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n                } else {\n                    return (double) Math.max(maxLeftX, maxLeftY);\n                }\n            } else if (maxLeftX &gt; minRightY) {\n                high = partitionX - 1;\n            } else {\n                low = partitionX + 1;\n            }\n        }\n        throw new IllegalArgumentException();\n    }\n}\n</code></pre>"},{"location":"dsa/hard/MinimumNumberofKConsecutiveBitFlips/","title":"MinimumNumberofKConsecutiveBitFlips","text":""},{"location":"dsa/hard/MinimumNumberofKConsecutiveBitFlips/#summary-of-approach","title":"Summary of Approach","text":"<p>The Java solution to the \"Minimum Number of K Consecutive Bit Flips\" problem typically uses a sliding window approach with a deque (double-ended queue).  The deque stores the indices of flips made so far.  As the window slides through the binary array (represented as an integer array), it maintains a count of flipped bits within the window. If the count of flipped bits is even (meaning the current bit is 0, after potential prior flips), a flip is needed.  A flip is executed by adding the current index to the deque. If the leftmost element of the deque is outside the current window, it is removed. This ensures the deque only contains relevant flip indices within the current window.  The algorithm iterates through the array, incrementing a flip count whenever a flip is necessary. The final flip count represents the minimum number of K consecutive bit flips required.</p>"},{"location":"dsa/hard/MinimumNumberofKConsecutiveBitFlips/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time Complexity: O(n) where n is the length of the input array.  The algorithm iterates through the array once.  Deque operations (add and remove) are O(1) on average.</li> <li>Space Complexity: O(n) in the worst case. The deque can store up to n/k indices in the worst-case scenario, where k is the length of the consecutive flips.  However, in practice, it's usually much smaller than n.  If K is significantly larger than n, the space complexity tends towards O(k).</li> </ul>"},{"location":"dsa/hard/Minimum_Cost_to_Cut_a_Stick/","title":"Problem: Minimum Cost to Cut a Stick","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Minimum_Cost_to_Cut_a_Stick/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Minimum_Number_of_Flips_to_Make_Binary_String_Alte/","title":"Problem: Minimum Number of Flips to Make Binary String Alternating","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Minimum_Number_of_Flips_to_Make_Binary_String_Alte/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Minimum_Number_of_K_Consecutive_Bit_Flips/","title":"Problem: Minimum Number of K Consecutive Bit Flips","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Minimum_Number_of_K_Consecutive_Bit_Flips/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Regular_Expression_Matching/","title":"Problem: Regular Expression Matching","text":""},{"location":"dsa/hard/Regular_Expression_Matching/#summary-of-approach","title":"Summary of Approach","text":"<p>The Regular Expression Matching problem aims to determine if a given regular expression (regex) matches a given string.  A dynamic programming approach is commonly used to solve this efficiently.  We create a DP table <code>dp[i][j]</code> where <code>dp[i][j]</code> is <code>True</code> if the first <code>i</code> characters of the string match the first <code>j</code> characters of the regex, and <code>False</code> otherwise.</p> <p>The base case is <code>dp[0][0] = True</code> (empty string matches empty regex).  We then iterate through the table, considering each character of the string and each character/symbol of the regex.  The logic for filling the table involves several cases:</p> <ul> <li>If the regex character is a literal character: It must match the corresponding string character.</li> <li>If the regex character is a '.' (dot): It matches any single character.</li> <li>If the regex character is a '*' (star): This represents zero or more occurrences of the preceding character.  We have two choices: either the preceding character is matched zero times (we move only in the regex), or it is matched one or more times (we move in both the string and regex, and recursively check for more matches).</li> </ul> <p>The final result, <code>dp[m][n]</code> (where <code>m</code> is the length of the string and <code>n</code> is the length of the regex), indicates whether the entire string matches the entire regex.</p>"},{"location":"dsa/hard/Regular_Expression_Matching/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(mn) where 'm' is the length of the string and 'n' is the length of the regular expression.  This is because we iterate through an m x n DP table.</li> <li>Space: O(mn)  The space complexity is dominated by the DP table itself.  While some optimizations can reduce the space to O(min(m, n)) by using only one row or column of the table at a time, the standard DP solution uses the full table.</li> </ul>"},{"location":"dsa/hard/Regular_Expression_Matching/#java-solution","title":"Java Solution","text":"<pre><code>/*\nGiven an input string s and a pattern p, implement regular expression matching with support for '.' and '*'.\n\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\nExample 2:\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\nExample 3:\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\nExample 4:\n\nInput: s = \"aab\", p = \"c*a*b\"\nOutput: true\nExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches \"aab\".\nExample 5:\n\nInput: s = \"mississippi\", p = \"mis*is*p*.\"\nOutput: false\n\n\nConstraints:\n\n0 &lt;= s.length() &lt;= 20\n0 &lt;= p.length() &lt;= 30\ns contains only lowercase English letters.\np contains only lowercase English letters, '.' and '*'.\n\nDifficulty: Hard\n*/\nclass RegularExpressionMatching {\n    public boolean isMatch(String s, String p) {\n        int m = s.length();\n        int n = p.length();\n\n        boolean[][] dp = new boolean[m + 1][n + 1];\n        dp[0][0] = true;\n\n        for (int j = 1; j &lt;= n; j++) {\n            if (p.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 2];\n            }\n        }\n\n        for (int i = 1; i &lt;= m; i++) {\n            for (int j = 1; j &lt;= n; j++) {\n                if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (p.charAt(j - 1) == '*') {\n                    dp[i][j] = dp[i][j - 2]; //Match zero occurrences\n                    if (p.charAt(j - 2) == '.' || p.charAt(j - 2) == s.charAt(i - 1)) {\n                        dp[i][j] = dp[i][j] | dp[i - 1][j]; //Match one or more occurrences\n                    }\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n</code></pre>"},{"location":"dsa/hard/Remove_Invalid_Parentheses/","title":"Problem: Remove Invalid Parentheses","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Remove_Invalid_Parentheses/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Serialize_and_Deserialize_Binary_Tree/","title":"Problem: Serialize and Deserialize Binary Tree","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Serialize_and_Deserialize_Binary_Tree/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Shortest_Path_in_a_Grid_with_Obstacles_Elimination/","title":"Problem: Shortest Path in a Grid with Obstacles Elimination","text":""},{"location":"dsa/hard/Shortest_Path_in_a_Grid_with_Obstacles_Elimination/#summary-of-approach","title":"Summary of Approach","text":"<p>The \"Shortest Path in a Grid with Obstacles Elimination\" problem aims to find the shortest path from a starting point to an ending point in a grid, where some cells are obstacles.  A crucial element is that the path can eliminate a limited number of obstacles.  This usually involves using a variation of Dijkstra's algorithm or a breadth-first search (BFS).</p> <p>The core idea is to augment the state representation to include not only the current cell's coordinates but also the number of obstacles already eliminated.  This creates a larger search space.  The algorithm explores the grid, maintaining a priority queue (for Dijkstra's) or a queue (for BFS) of states, prioritizing states with shorter distances.  For each visited cell, it checks if moving to adjacent cells (up, down, left, right) is possible.  If a cell is an obstacle, it's only considered if the remaining obstacle elimination budget is greater than zero.  The algorithm terminates when the ending point is reached, returning the shortest path found.  Variations might involve using A* search for even faster performance by incorporating heuristics.</p>"},{"location":"dsa/hard/Shortest_Path_in_a_Grid_with_Obstacles_Elimination/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(M * N * K), where M and N are the dimensions of the grid and K is the maximum number of obstacles that can be eliminated.  This is because the algorithm explores a state space proportional to the grid size multiplied by the number of possible obstacle elimination counts. Using a priority queue optimized for updates like a Fibonacci heap would reduce this to O(MNK log(MNK)), but standard priority queues like min-heap are typically sufficient.</li> <li>Space: O(M * N * K). This is due to the need to store visited states, which are (x, y, obstacles_eliminated) tuples.  The queue/priority queue also uses space proportional to the size of the explored portion of this state space.</li> </ul>"},{"location":"dsa/hard/Shortest_Path_in_a_Grid_with_Obstacles_Elimination/#java-solution","title":"Java Solution","text":"<pre><code>import java.util.LinkedList;\nimport java.util.Queue;\n\nclass ShortestPathInAGridWithObstaclesElimination {\n    // Question: You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacle). You can move up, down, left, or right from a cell. You can eliminate at most k obstacles in your path. Find the shortest path from the top left cell (0, 0) to the bottom right cell (m-1, n-1). If the shortest path is not possible, return -1.\n    // Difficulty: Hard\n\n    public int shortestPath(int[][] grid, int k) {\n        int m = grid.length;\n        int n = grid[0].length;\n\n        if (m == 0 || n == 0) return -1;\n\n        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();\n        queue.offer(new int[]{0, 0, k, 0}); // {row, col, remainingObstacles, distance}\n\n        boolean[][][] visited = new boolean[m][n][k + 1];\n        visited[0][0][k] = true;\n\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int row = curr[0];\n            int col = curr[1];\n            int obstacles = curr[2];\n            int dist = curr[3];\n\n            if (row == m - 1 &amp;&amp; col == n - 1) return dist;\n\n            for (int[] dir : dirs) {\n                int newRow = row + dir[0];\n                int newCol = col + dir[1];\n\n                if (newRow &gt;= 0 &amp;&amp; newRow &lt; m &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; n) {\n                    int newObstacles = obstacles - grid[newRow][newCol];\n                    if (newObstacles &gt;= 0 &amp;&amp; !visited[newRow][newCol][newObstacles]) {\n                        visited[newRow][newCol][newObstacles] = true;\n                        queue.offer(new int[]{newRow, newCol, newObstacles, dist + 1});\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n}\n</code></pre>"},{"location":"dsa/hard/Stickers_to_Spell_Word/","title":"Problem: Stickers to Spell Word","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Stickers_to_Spell_Word/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Strong_Password_Checker/","title":"Problem: Strong Password Checker","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Strong_Password_Checker/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/Swim_in_Rising_Water/","title":"Problem: Swim in Rising Water","text":""},{"location":"dsa/hard/Swim_in_Rising_Water/#summary-of-approach","title":"Summary of Approach","text":"<p>The \"Swim in Rising Water\" problem asks to find the shortest time it takes for water to reach a destination cell (target) from a source cell (usually the top-left corner) in a grid, given that water rises at a constant rate.  The grid contains elevation values.  This problem can be efficiently solved using a priority queue (like a min-heap) and Dijkstra's algorithm.</p> <p>The algorithm works as follows:</p> <ol> <li> <p>Initialization: Create a min-heap priority queue containing the starting cell's coordinates and its elevation.  Initialize a distance array to track the minimum time to reach each cell (initialized to infinity for all cells except the starting cell, which is its elevation).</p> </li> <li> <p>Iteration: While the priority queue is not empty:</p> <ul> <li>Pop the cell with the minimum elevation (and thus minimum time to reach) from the priority queue.</li> <li>If this cell is the target cell, return its minimum time.</li> <li>Explore its neighbors (up, down, left, right). For each neighbor:<ul> <li>Calculate the maximum of the current cell's time and the neighbor's elevation (this represents the time needed to reach the neighbor).</li> <li>If this time is less than the current minimum time to reach that neighbor, update the minimum time and add the neighbor to the priority queue.</li> </ul> </li> </ul> </li> <li> <p>Result: If the target cell is reached, the algorithm returns the minimum time; otherwise, there's no path to the target.</p> </li> </ol>"},{"location":"dsa/hard/Swim_in_Rising_Water/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(N log N), where N is the number of cells in the grid. This is because in the worst case, we might need to process all cells, and each processing step involves a heap operation (log N).</li> <li>Space: O(N). This is primarily due to the priority queue and the distance array, both of which can store up to N elements in the worst case.</li> </ul>"},{"location":"dsa/hard/Swim_in_Rising_Water/#java-solution","title":"Java Solution","text":"<pre><code>// You are given an n x n integer matrix grid where grid[i][j] represents the height of cell (i, j).\n//\n// We are initially at cell (0, 0), and we want to reach cell (n - 1, n - 1). Every cell has a cost, which is its height.\n//\n// We can move in four directions: up, down, left, or right.\n//\n// We are given an integer k. We want to find the minimum k such that we can reach the cell (n - 1, n - 1).\n//\n// Difficulty: Hard\nclass SwimInRisingWater {\n    public int swimInWater(int[][] grid) {\n        int n = grid.length;\n        int left = 0, right = n * n - 1;\n        while (left &lt; right) {\n            int mid = left + (right - left) / 2;\n            if (canReach(grid, mid, n)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n\n    private boolean canReach(int[][] grid, int threshold, int n) {\n        boolean[][] visited = new boolean[n][n];\n        int[] dx = {0, 0, 1, -1};\n        int[] dy = {1, -1, 0, 0};\n        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();\n        queue.offer(new int[]{0, 0});\n        visited[0][0] = true;\n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int x = curr[0];\n            int y = curr[1];\n            if (x == n - 1 &amp;&amp; y == n - 1) {\n                return true;\n            }\n            for (int i = 0; i &lt; 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; !visited[nx][ny] &amp;&amp; grid[nx][ny] &lt;= threshold) {\n                    queue.offer(new int[]{nx, ny});\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n        return false;\n    }\n}\n</code></pre>"},{"location":"dsa/hard/The_Earliest_Moment_When_Everyone_Become_Friends/","title":"Problem: The Earliest Moment When Everyone Become Friends","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/The_Earliest_Moment_When_Everyone_Become_Friends/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/hard/WordBreakII/","title":"WordBreakII","text":""},{"location":"dsa/hard/WordBreakII/#summary-of-approach","title":"Summary of Approach","text":"<p>The Word Break II problem asks to find all possible sentences that can be formed by breaking a given string into words from a provided dictionary.  The solution typically employs a dynamic programming approach combined with backtracking.</p> <ol> <li> <p>Dynamic Programming (DP):  A DP table (often a vector or array) is used to store boolean values indicating whether a substring of the input string can be segmented into words from the dictionary.  This step avoids redundant calculations by pre-computing the feasibility of breaking substrings.</p> </li> <li> <p>Backtracking: Once the DP table is built, backtracking is used to generate all possible sentence combinations. Starting from the end of the string, the algorithm recursively explores all valid word breaks found in the DP table. Each valid break leads to a recursive call, extending the current sentence until the beginning of the string is reached.  At each step, the found word is added to the current sentence.</p> </li> </ol>"},{"location":"dsa/hard/WordBreakII/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li> <p>Time: O(n * 2<sup>n</sup>), where n is the length of the input string.  The DP step takes O(n\u00b2) time. However, the dominant factor is the backtracking step. In the worst case, each substring can be broken in multiple ways, leading to an exponential number of possible sentences. The number of sentences can be exponential, growing as high as 2<sup>n</sup> in the worst-case scenario (although this is rare).  The time to construct each sentence is linear in n.</p> </li> <li> <p>Space: O(n + m + r), where n is the length of the input string, m is the size of the dictionary, and r is the maximum length of the generated sentences.  The DP table requires O(n) space.  The dictionary occupies O(m) space. During backtracking, the recursion depth can be O(n), and the space used to store each sentence can be up to O(r).</p> </li> </ul>"},{"location":"dsa/hard/Word_Ladder_II/","title":"Problem: Word Ladder II","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/hard/Word_Ladder_II/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/ArrayNesting/","title":"ArrayNesting","text":""},{"location":"dsa/medium/ArrayNesting/#summary-of-approach","title":"Summary of Approach","text":"<p>The Array Nesting problem asks to find the length of the longest chain formed by repeatedly accessing array elements using the array element as the index.  The approach involves iterating through the array. For each unvisited element, we start a chain by repeatedly following the index to the next element until we reach an already visited element or form a cycle back to the starting element. The length of this chain is recorded, and the maximum chain length among all chains is returned as the result.  We use a <code>visited</code> array to track visited elements efficiently, avoiding infinite loops and redundant computations.</p>"},{"location":"dsa/medium/ArrayNesting/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(N)</li> <li>Space: O(N)</li> </ul> <p>Explanation:</p> <ul> <li> <p>Time Complexity:  The outer loop iterates through the array once (O(N)). The inner loop follows each chain, but each element is visited at most once across all chains. Therefore, the total number of times we access elements is at most O(N). Even though the nested loop structure might seem O(N^2) at first glance, the amortized analysis reveals it to be linear.</p> </li> <li> <p>Space Complexity: We use an auxiliary array <code>visited</code> of size N to keep track of visited elements.  This contributes to O(N) space complexity.  The recursive approach (if one were used) might add to the call stack space, but that would also be bounded by N in the worst case. Therefore, the overall space complexity remains O(N).</p> </li> </ul>"},{"location":"dsa/medium/Binary_Tree_Level_Order_Traversal/","title":"Problem: Binary Tree Level Order Traversal","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Binary_Tree_Level_Order_Traversal/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Binary_Tree_Right_Side_View/","title":"Problem: Binary Tree Right Side View","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Binary_Tree_Right_Side_View/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Clone_Graph/","title":"Problem: Clone Graph","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Clone_Graph/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Construct_Binary_Tree_from_Preorder_and_Inorder_Tr/","title":"Problem: Construct Binary Tree from Preorder and Inorder Traversal","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Construct_Binary_Tree_from_Preorder_and_Inorder_Tr/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Course_Schedule/","title":"Problem: Course Schedule","text":""},{"location":"dsa/medium/Course_Schedule/#summary-of-approach","title":"Summary of Approach","text":"<p>The Course Schedule problem determines if it's possible to finish all courses given a set of prerequisites.  The approach typically involves using topological sort.  We build a directed graph where nodes represent courses and edges represent prerequisites (A -&gt; B means course B requires course A).  Then, we perform a topological sort using either Kahn's algorithm or Depth-First Search (DFS).</p> <p>Kahn's algorithm iteratively removes nodes with no incoming edges, adding them to the result. If a cycle is detected (no nodes with zero in-degree exist before all nodes are processed), it's impossible to finish all courses.</p> <p>DFS recursively explores the graph, marking nodes as visited and recursively processing their neighbors.  If a visited node is encountered again during recursion (a cycle), it's impossible to finish all courses.  The order of finishing nodes (in post-order traversal for DFS) represents a topological ordering if no cycle is detected.</p>"},{"location":"dsa/medium/Course_Schedule/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li> <p>Time: O(V + E) where V is the number of courses (vertices) and E is the number of prerequisites (edges).  Both Kahn's algorithm and DFS have this time complexity.  Building the graph itself is also O(V + E).</p> </li> <li> <p>Space: O(V + E)  This is dominated by the space used to represent the graph (adjacency list or adjacency matrix) and the recursion stack for DFS or the queue for Kahn's algorithm.  In the worst-case scenario (a fully connected graph), E could be O(V\u00b2), but it's usually smaller in real-world scenarios.</p> </li> </ul>"},{"location":"dsa/medium/Course_Schedule/#java-solution","title":"Java Solution","text":"<pre><code>import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/*\n * Question: Course Schedule (Medium)\n * Given the number of courses and a list of prerequisites, determine if it is possible to finish all courses.\n * There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1.\n * You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n * For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n * Return true if you can finish all courses. Otherwise, return false.\n */\nclass CourseSchedule {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        Map&lt;Integer, List&lt;Integer&gt;&gt; adj = new HashMap&lt;&gt;();\n        int[] inDegree = new int[numCourses];\n\n        for (int[] pre : prerequisites) {\n            adj.computeIfAbsent(pre[1], k -&gt; new ArrayList&lt;&gt;()).add(pre[0]);\n            inDegree[pre[0]]++;\n        }\n\n        List&lt;Integer&gt; queue = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (inDegree[i] == 0) {\n                queue.add(i);\n            }\n        }\n\n        int count = 0;\n        while (!queue.isEmpty()) {\n            int course = queue.remove(0);\n            count++;\n            if (adj.containsKey(course)) {\n                for (int neighbor : adj.get(course)) {\n                    inDegree[neighbor]--;\n                    if (inDegree[neighbor] == 0) {\n                        queue.add(neighbor);\n                    }\n                }\n            }\n        }\n\n        return count == numCourses;\n    }\n}\n</code></pre>"},{"location":"dsa/medium/Daily_Temperatures/","title":"Problem: Daily Temperatures","text":""},{"location":"dsa/medium/Daily_Temperatures/#summary-of-approach","title":"Summary of Approach","text":"<p>The Daily Temperatures problem aims to find, for each day, the number of days you have to wait until a warmer temperature occurs.  The approach uses a stack to efficiently track days and their temperatures.  We iterate through the temperatures.  For each temperature, we pop elements from the stack as long as the current temperature is warmer than the temperature at the top of the stack. When we pop an element, we calculate the difference in days (index difference) and store it in the result array corresponding to the popped day.  If the stack is empty or the current temperature is not warmer than the top of the stack, we push the current day and its temperature onto the stack.  Finally, any remaining days on the stack will have no warmer days in the future, so their waiting time is 0.</p>"},{"location":"dsa/medium/Daily_Temperatures/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(N), where N is the number of temperatures.  While we might potentially iterate through the stack multiple times in the worst case, the total number of pushes and pops across the entire algorithm will never exceed N. Each element is pushed and popped at most once.</li> <li>Space: O(N) in the worst case. The stack could potentially hold all the temperatures if the temperatures are consistently decreasing.  In the best-case scenario (strictly increasing temperatures), the space complexity would be O(1).</li> </ul>"},{"location":"dsa/medium/Daily_Temperatures/#java-solution","title":"Java Solution","text":"<pre><code>/*\nDaily Temperatures\nMedium\n\nGiven an array of integers temperatures representing the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n\nExample 1:\nInput: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]\n\nExample 2:\nInput: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]\n\nExample 3:\nInput: temperatures = [30,60,90]\nOutput: [1,1,0]\n*/\nclass DailyTemperatures {\n    public int[] dailyTemperatures(int[] temperatures) {\n        int n = temperatures.length;\n        int[] result = new int[n];\n        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n\n        for (int i = 0; i &lt; n; i++) {\n            while (!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt; temperatures[i]) {\n                int prevIndex = stack.pop();\n                result[prevIndex] = i - prevIndex;\n            }\n            stack.push(i);\n        }\n\n        return result;\n    }\n}\n</code></pre>"},{"location":"dsa/medium/DecodeWays/","title":"DecodeWays","text":""},{"location":"dsa/medium/DecodeWays/#summary-of-approach","title":"Summary of Approach","text":"<p>The Java solution to the \"Decode Ways\" problem uses dynamic programming to efficiently count the number of ways to decode a string of digits into a sequence of letters.  Each digit can represent a letter (1-26), and consecutive digits can represent a single letter if their combined value falls within the range 10-26. The solution iteratively builds a <code>dp</code> array where <code>dp[i]</code> stores the number of ways to decode the substring ending at index <code>i</code>. The base cases are <code>dp[0] = 1</code> (empty string has one way to decode) and <code>dp[1] = 1</code> (a single digit string has one way to decode, unless the digit is 0, in which case it's 0).  The recurrence relation is:</p> <p><code>dp[i] = dp[i-1] + dp[i-2]</code> if the digits at <code>i-1</code> and <code>i-2</code> form a valid two-digit code (10-26). Otherwise <code>dp[i] = dp[i-1]</code>.  The final result is <code>dp[n]</code> where <code>n</code> is the length of the input string.  Error handling is included to account for invalid input (like '0' as the first digit).</p>"},{"location":"dsa/medium/DecodeWays/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time Complexity: O(n) - The algorithm iterates through the input string once.</li> <li>Space Complexity: O(n) - The <code>dp</code> array of size <code>n</code> is used to store intermediate results.  While it could be optimized to O(1) using only two variables to keep track of the last two elements, the provided space complexity reflects a common, easier-to-understand implementation.</li> </ul>"},{"location":"dsa/medium/Decode_Ways/","title":"Problem: Decode Ways","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Decode_Ways/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Evaluate_Reverse_Polish_Notation/","title":"Problem: Evaluate Reverse Polish Notation","text":""},{"location":"dsa/medium/Evaluate_Reverse_Polish_Notation/#summary-of-approach","title":"Summary of Approach","text":"<p>The Evaluate Reverse Polish Notation (RPN) problem involves evaluating an arithmetic expression written in Reverse Polish Notation.  RPN, also known as postfix notation, places operators after their operands.  The algorithm uses a stack to efficiently evaluate the expression.  It iterates through the RPN tokens (numbers and operators).  If a token is a number, it's pushed onto the stack. If a token is an operator, the algorithm pops the necessary number of operands from the stack, performs the operation, and pushes the result back onto the stack.  After processing all tokens, the final result is the top (and only) element on the stack.</p>"},{"location":"dsa/medium/Evaluate_Reverse_Polish_Notation/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(n)</li> <li>Space: O(n)</li> </ul> <p>where n is the number of tokens in the RPN expression.  The algorithm iterates through each token once, performing constant-time operations for each (pushing/popping from the stack and arithmetic).  The space used by the stack is proportional to the maximum depth of the stack, which in the worst case (e.g., a deeply nested expression with many operands before an operator) can be as large as n.</p>"},{"location":"dsa/medium/Evaluate_Reverse_Polish_Notation/#java-solution","title":"Java Solution","text":"<pre><code>import java.util.Stack;\n\n/*\nEvaluate Reverse Polish Notation\nMedium\n*/\nclass EvaluateReversePolishNotation {\n    public int evalRPN(String[] tokens) {\n        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n        for (String token : tokens) {\n            if (token.equals(\"+\")) {\n                int operand2 = stack.pop();\n                int operand1 = stack.pop();\n                stack.push(operand1 + operand2);\n            } else if (token.equals(\"-\")) {\n                int operand2 = stack.pop();\n                int operand1 = stack.pop();\n                stack.push(operand1 - operand2);\n            } else if (token.equals(\"*\")) {\n                int operand2 = stack.pop();\n                int operand1 = stack.pop();\n                stack.push(operand1 * operand2);\n            } else if (token.equals(\"/\")) {\n                int operand2 = stack.pop();\n                int operand1 = stack.pop();\n                stack.push(operand1 / operand2);\n            } else {\n                stack.push(Integer.parseInt(token));\n            }\n        }\n        return stack.pop();\n    }\n}\n</code></pre>"},{"location":"dsa/medium/Find_K_Closest_Elements/","title":"Problem: Find K Closest Elements","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Find_K_Closest_Elements/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Flatten_Binary_Tree_to_Linked_List/","title":"Problem: Flatten Binary Tree to Linked List","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Flatten_Binary_Tree_to_Linked_List/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Insert_Interval/","title":"Problem: Insert Interval","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Insert_Interval/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Letter_Combinations_of_a_Phone_Number/","title":"Problem: Letter Combinations of a Phone Number","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Letter_Combinations_of_a_Phone_Number/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Longest_Mountain_in_Array/","title":"Longest Mountain in Array","text":""},{"location":"dsa/medium/Longest_Mountain_in_Array/#summary-of-approach","title":"Summary of Approach","text":"<p>The problem \"Longest Mountain in Array\" aims to find the length of the longest mountain in a given array. A mountain is defined as a subarray that strictly increases to a peak, then strictly decreases.  The approach involves iterating through the array, identifying potential peaks. For each potential peak, we expand outwards in both directions (left and right) to determine the length of the mountain. We keep track of the maximum mountain length encountered during the iteration.  The algorithm efficiently avoids redundant checks by using a <code>base</code> index to track starting points of potential mountains.  It avoids revisiting already processed portions of the array because once a peak is found, it checks left and right for increasing/decreasing sequences, then moves the <code>base</code> to the end of the found mountain to continue searching efficiently.</p>"},{"location":"dsa/medium/Longest_Mountain_in_Array/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(N)</li> <li>Space: O(1)</li> </ul> <p>The algorithm iterates through the array at most once.  While there are nested loops within the <code>while</code> condition, these loops only process elements within a single mountain, and the total number of processed elements remains linear with respect to the input size.  No extra data structures of significant size are used; all operations are performed in-place, resulting in constant space complexity.</p>"},{"location":"dsa/medium/Longest_Substring_Without_Repeating_Characters/","title":"Problem: Longest Substring Without Repeating Characters","text":""},{"location":"dsa/medium/Longest_Substring_Without_Repeating_Characters/#summary-of-approach","title":"Summary of Approach","text":"<p>The \"Longest Substring Without Repeating Characters\" problem aims to find the length of the longest substring within a given string that contains no repeating characters.  A sliding window approach is efficient for solving this.  We use two pointers, <code>left</code> and <code>right</code>, representing the start and end of the sliding window.  A <code>set</code> (or dictionary/hashmap) is used to track the characters currently within the window.</p> <p>The algorithm iterates, expanding the window to the right (<code>right++</code>) as long as the next character is not already in the set.  If a repeating character is encountered, the window is contracted from the left (<code>left++</code>) until the repeating character is removed from the window (removed from the set).  The length of the longest substring is tracked throughout the process.</p>"},{"location":"dsa/medium/Longest_Substring_Without_Repeating_Characters/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(n) - The algorithm iterates through the string at most twice (once expanding the window, and potentially again contracting it).  The set lookup and insertion operations are O(1) on average.</li> <li>Space: O(min(m, n)) - The space used by the set is proportional to the number of unique characters in the substring, where 'n' is the length of the input string and 'm' is the size of the character set (e.g., 256 for ASCII). In the worst case (all characters unique), it's O(n), while in the best case (all characters the same), it's O(1).  The space used is bounded by the minimum of the input string length and the size of the character set.</li> </ul>"},{"location":"dsa/medium/Longest_Substring_Without_Repeating_Characters/#java-solution","title":"Java Solution","text":"<pre><code>//Longest Substring Without Repeating Characters\n//Difficulty: Medium\n\nclass LongestSubstringWithoutRepeatingCharacters {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        int ans = 0;\n        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();\n        int j = 0;\n        for (int i = 0; i &lt; n; i++) {\n            if (map.containsKey(s.charAt(i))) {\n                j = Math.max(j, map.get(s.charAt(i)) + 1);\n            }\n            map.put(s.charAt(i), i);\n            ans = Math.max(ans, i - j + 1);\n        }\n        return ans;\n    }\n}\n</code></pre>"},{"location":"dsa/medium/Max_Area_of_Island/","title":"Problem: Max Area of Island","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Max_Area_of_Island/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/MaximalSquare/","title":"MaximalSquare","text":""},{"location":"dsa/medium/MaximalSquare/#summary-of-approach","title":"Summary of Approach","text":"<p>The \"Maximal Square\" problem aims to find the largest square submatrix containing only '1's within a given matrix of '0's and '1's.  A dynamic programming approach is highly efficient.  We create a DP table of the same dimensions as the input matrix.  <code>dp[i][j]</code> stores the size of the largest square ending at position <code>(i, j)</code>.</p> <p>The DP table is populated iteratively.  If the current cell <code>matrix[i][j]</code> is '1', the size of the square ending at this cell is 1 plus the minimum of the sizes of squares ending at the cells directly above, to the left, and diagonally above-left (<code>dp[i-1][j]</code>, <code>dp[i][j-1]</code>, <code>dp[i-1][j-1]</code>).  If <code>matrix[i][j]</code> is '0', then <code>dp[i][j]</code> is 0. The maximum value in the <code>dp</code> table represents the side length of the maximal square, and its square is the maximal square's area.</p>"},{"location":"dsa/medium/MaximalSquare/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(m*n) where 'm' and 'n' are the dimensions of the input matrix.  We iterate through the matrix once to populate the DP table.</li> <li>Space: O(m*n)  The space is dominated by the DP table we create, which has the same dimensions as the input matrix.  We could potentially optimize space to O(n) if we only keep track of the previous row, but this would make the code slightly more complex.</li> </ul>"},{"location":"dsa/medium/Maximal_Square/","title":"Problem: Maximal Square","text":""},{"location":"dsa/medium/Maximal_Square/#summary-of-approach","title":"Summary of Approach","text":"<p>The Maximal Square problem aims to find the largest square submatrix containing only '1's within a given matrix of '0's and '1's.  A dynamic programming approach is highly efficient.  We create a DP table of the same size as the input matrix.  <code>dp[i][j]</code> stores the size of the largest square ending at (i, j).  If the current cell is '1', its value is 1 plus the minimum of the values above, to the left, and diagonally above and to the left in the DP table. This minimum represents the limiting factor in extending the square.  If the current cell is '0', the value is 0.  The maximum value in the DP table represents the side length of the maximal square, and its square is the maximal square's area.</p>"},{"location":"dsa/medium/Maximal_Square/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(m*n) where 'm' and 'n' are the dimensions of the input matrix.  We iterate through the matrix once to build the DP table.</li> <li>Space: O(m*n) to store the DP table.  While we could potentially optimize space to O(min(m,n)) by using only one row or column of the DP table at a time, the standard DP solution uses the full table.</li> </ul>"},{"location":"dsa/medium/Maximal_Square/#java-solution","title":"Java Solution","text":"<pre><code>/*\nGiven an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n\nDifficulty: Medium\n*/\nclass MaximalSquare {\n    public int maximalSquare(char[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return 0;\n        }\n\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int[][] dp = new int[m + 1][n + 1];\n        int maxSide = 0;\n\n        for (int i = 1; i &lt;= m; i++) {\n            for (int j = 1; j &lt;= n; j++) {\n                if (matrix[i - 1][j - 1] == '1') {\n                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;\n                    maxSide = Math.max(maxSide, dp[i][j]);\n                }\n            }\n        }\n\n        return maxSide * maxSide;\n    }\n}\n</code></pre>"},{"location":"dsa/medium/Merge_Intervals/","title":"Problem: Merge Intervals","text":""},{"location":"dsa/medium/Merge_Intervals/#summary-of-approach","title":"Summary of Approach","text":"<p>The Merge Intervals problem aims to merge overlapping intervals in a list.  The approach typically involves sorting the intervals by their start times.  Then, we iterate through the sorted intervals, maintaining a stack or a result list.  If the current interval overlaps with the last interval in the stack/list (meaning the current interval's start time is less than or equal to the last interval's end time), we merge them by taking the minimum start time and the maximum end time. Otherwise, we add the current interval to the stack/list.  The final stack/list contains the merged intervals.</p>"},{"location":"dsa/medium/Merge_Intervals/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(n log n)  The dominant factor is the sorting step, which typically uses a comparison-based sorting algorithm like merge sort or quicksort with O(n log n) complexity. The iteration through the sorted intervals takes O(n) time.</li> <li>Space: O(n)  In the worst case (no overlapping intervals), the space used to store the result list will be proportional to the number of input intervals.  If using an in-place approach, the space complexity can be reduced to O(log n) due to the sorting algorithm's space usage.  However, an extra space of O(n) is often used for simplicity and readability.</li> </ul>"},{"location":"dsa/medium/Merge_Intervals/#java-solution","title":"Java Solution","text":"<pre><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\n/*\nMerge Intervals\n\nGiven an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\nDifficulty: Medium\n*/\nclass MergeIntervals {\n    public int[][] merge(int[][] intervals) {\n        if (intervals == null || intervals.length &lt;= 1) {\n            return intervals;\n        }\n\n        // Sort intervals by start time\n        Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a[0]));\n\n        List&lt;int[]&gt; mergedIntervals = new ArrayList&lt;&gt;();\n        int[] currentInterval = intervals[0];\n        mergedIntervals.add(currentInterval);\n\n        for (int i = 1; i &lt; intervals.length; i++) {\n            int[] nextInterval = intervals[i];\n            if (nextInterval[0] &lt;= currentInterval[1]) {\n                // Overlap: merge intervals\n                currentInterval[1] = Math.max(currentInterval[1], nextInterval[1]);\n            } else {\n                // No overlap: add next interval to merged list\n                currentInterval = nextInterval;\n                mergedIntervals.add(currentInterval);\n            }\n        }\n\n        return mergedIntervals.toArray(new int[mergedIntervals.size()][]);\n    }\n}\n</code></pre>"},{"location":"dsa/medium/Merge_K_Sorted_Lists/","title":"Problem: Merge K Sorted Lists","text":""},{"location":"dsa/medium/Merge_K_Sorted_Lists/#summary-of-approach","title":"Summary of Approach","text":"<p>The Merge K Sorted Lists problem involves merging k sorted linked lists into a single sorted linked list.  A common and efficient approach uses a priority queue (min-heap).  The algorithm works as follows:</p> <ol> <li> <p>Initialization: Create a min-heap data structure.  Insert the first node from each of the k sorted lists into the heap.  Each element in the heap is a pair (node value, list index) to track which list the node belongs to.</p> </li> <li> <p>Iteration: While the heap is not empty:</p> </li> <li>Extract the minimum element (node) from the heap.  This is the next smallest node overall.</li> <li>Add this node to the result list.</li> <li> <p>If the extracted node's list still has more nodes, insert the next node from that list into the heap.</p> </li> <li> <p>Result: The resulting linked list contains all nodes from the k input lists, sorted in ascending order.</p> </li> </ol>"},{"location":"dsa/medium/Merge_K_Sorted_Lists/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li> <p>Time: O(N log k), where N is the total number of nodes across all k lists.  This is because inserting and extracting from a heap of size k takes O(log k) time, and we do this N times.</p> </li> <li> <p>Space: O(k). The space complexity is dominated by the heap, which at most contains one node from each of the k lists.  The output list's space is O(N), but this is not considered in space complexity analysis because the problem asks us to construct the output, so the result's space usage is not counted against the algorithm.</p> </li> </ul>"},{"location":"dsa/medium/Merge_K_Sorted_Lists/#java-solution","title":"Java Solution","text":"<pre><code>/**\n * Merge k Sorted Lists\n * Difficulty: Hard\n */\nclass MergeKSortedLists {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n\n        return mergeSort(lists, 0, lists.length - 1);\n    }\n\n    private ListNode mergeSort(ListNode[] lists, int start, int end) {\n        if (start == end) {\n            return lists[start];\n        }\n\n        int mid = start + (end - start) / 2;\n        ListNode left = mergeSort(lists, start, mid);\n        ListNode right = mergeSort(lists, mid + 1, end);\n\n        return mergeTwoLists(left, right);\n    }\n\n    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode tail = dummy;\n\n        while (l1 != null &amp;&amp; l2 != null) {\n            if (l1.val &lt; l2.val) {\n                tail.next = l1;\n                l1 = l1.next;\n            } else {\n                tail.next = l2;\n                l2 = l2.next;\n            }\n            tail = tail.next;\n        }\n\n        tail.next = (l1 == null) ? l2 : l1;\n        return dummy.next;\n    }\n\n    public class ListNode {\n        int val;\n        ListNode next;\n        ListNode() {}\n        ListNode(int val) { this.val = val; }\n        ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n    }\n}\n</code></pre>"},{"location":"dsa/medium/Minimum_Size_Subarray_Sum/","title":"Problem: Minimum Size Subarray Sum","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Minimum_Size_Subarray_Sum/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Path_Sum_II/","title":"Problem: Path Sum II","text":""},{"location":"dsa/medium/Path_Sum_II/#summary-of-approach","title":"Summary of Approach","text":"<p>The Path Sum II problem requires finding all root-to-leaf paths in a binary tree that sum up to a target value.  The solution uses a Depth-First Search (DFS) approach.  We recursively traverse the tree.  For each node, we:</p> <ol> <li> <p>Subtract the node's value from the remaining sum. This keeps track of the remaining sum needed to reach the target.</p> </li> <li> <p>Check for base cases:</p> </li> <li>If we reach a leaf node:<ul> <li>If the remaining sum is 0, we've found a valid path.  We add a copy of the current path to the result list.</li> <li>Otherwise, we've reached a leaf node without the sum matching the target; we backtrack.</li> </ul> </li> <li> <p>If the remaining sum becomes negative, we know it's impossible for any path stemming from this node to reach the target. We backtrack.</p> </li> <li> <p>Recursively explore the left and right subtrees.  Before each recursive call, we add the current node's value to the path list (to build the path). After the recursive call returns, we remove the current node's value from the path list (to backtrack properly).</p> </li> </ol> <p>This approach systematically explores all possible root-to-leaf paths and efficiently identifies those that meet the target sum.  The use of a path list and backtracking ensures we can reconstruct all valid paths.</p>"},{"location":"dsa/medium/Path_Sum_II/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(Nlog N)  or O(NM) where N is the number of nodes in the tree and M is the maximum length of any path (which can be equal to the tree height in the worst case,  log N for a balanced tree or N for a skewed tree). Each node might be visited multiple times as the paths are explored, and in the worst case we may need to build a path list of length M for each valid path.</li> <li>Space: O(N) or O(M) in the worst case. This is primarily due to the recursive call stack (depth of the recursion is the height of the tree, which can be N in a skewed tree) and the space used to store the path (which is bounded by M) during the DFS traversal. The result list also consumes space proportional to the number of valid paths found, which in the worst case, might be proportional to N.</li> </ul>"},{"location":"dsa/medium/Path_Sum_II/#java-solution","title":"Java Solution","text":"<pre><code>/**\n * Path Sum II\n * Medium\n * Given a binary tree and a target sum, find all root-to-leaf paths where each path's sum equals the target sum.\n * A leaf is a node with no children.\n */\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass PathSumII {\n    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) {\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        if (root == null) {\n            return result;\n        }\n        List&lt;Integer&gt; currentPath = new ArrayList&lt;&gt;();\n        findPath(root, targetSum, currentPath, result);\n        return result;\n    }\n\n    private void findPath(TreeNode node, int targetSum, List&lt;Integer&gt; currentPath, List&lt;List&lt;Integer&gt;&gt; result) {\n        currentPath.add(node.val);\n        if (node.left == null &amp;&amp; node.right == null) {\n            if (node.val == targetSum) {\n                result.add(new ArrayList&lt;&gt;(currentPath));\n            }\n        } else {\n            if (node.left != null) {\n                findPath(node.left, targetSum - node.val, currentPath, result);\n            }\n            if (node.right != null) {\n                findPath(node.right, targetSum - node.val, currentPath, result);\n            }\n        }\n        currentPath.remove(currentPath.size() - 1);\n    }\n\n    public class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode() {}\n        TreeNode(int val) { this.val = val; }\n        TreeNode(int val, TreeNode left, TreeNode right) {\n            this.val = val;\n            this.left = left;\n            this.right = right;\n        }\n    }\n}\n</code></pre>"},{"location":"dsa/medium/Perfect_Squares/","title":"Problem: Perfect Squares","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Perfect_Squares/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Plus_One_Linked_List/","title":"Problem: Plus One Linked List","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Plus_One_Linked_List/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Populating_Next_Right_Pointers_in_Each_Node/","title":"Problem: Populating Next Right Pointers in Each Node","text":""},{"location":"dsa/medium/Populating_Next_Right_Pointers_in_Each_Node/#summary-of-approach","title":"Summary of Approach","text":"<p>The problem \"Populating Next Right Pointers in Each Node\" involves modifying a perfect binary tree (or a complete binary tree up to a certain level) such that each node's <code>next</code> pointer points to the next node on the same level.  The solution uses a level-order traversal (breadth-first search) to process the nodes level by level.  We utilize a queue to manage the traversal.  For each level, we iterate through the nodes in the queue, setting the <code>next</code> pointer of the current node to the next node in the queue.  The key is that the order of nodes in the queue naturally reflects the level-order traversal, allowing us to easily link adjacent nodes on the same level.</p>"},{"location":"dsa/medium/Populating_Next_Right_Pointers_in_Each_Node/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(N)</li> <li>Space: O(W)</li> </ul> <p>where N is the total number of nodes in the tree, and W is the maximum width (maximum number of nodes at any level) of the tree.  In a perfect binary tree, W = O(N). In a skewed tree, W = O(1).  Therefore, the space complexity is O(N) in the worst case (a perfect binary tree) and O(1) in the best case (a completely skewed tree).</p>"},{"location":"dsa/medium/Populating_Next_Right_Pointers_in_Each_Node/#java-solution","title":"Java Solution","text":"<pre><code>/*\nGiven a perfect binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n\nInitially, all next pointers are set to NULL.\n\nExample:\n\nInput:\n     1\n   /  \\\n  2    3\n / \\  / \\\n4  5  6  7\n\nOutput:\n     1 -&gt; NULL\n   /  \\\n  2 -&gt; 3 -&gt; NULL\n / \\  / \\\n4-&gt;5-&gt;6-&gt;7 -&gt; NULL\n\nDifficulty: Medium\n*/\nclass PopulatingNextRightPointersInEachNode {\n    class Node {\n        public int val;\n        public Node left;\n        public Node right;\n        public Node next;\n\n        public Node() {}\n\n        public Node(int _val) {\n            val = _val;\n        }\n\n        public Node(int _val, Node _left, Node _right, Node _next) {\n            val = _val;\n            left = _left;\n            right = _right;\n            next = _next;\n        }\n    };\n\n    public Node connect(Node root) {\n        if (root == null) return null;\n        Node levelStart = root;\n        while (levelStart != null) {\n            Node curr = levelStart;\n            while (curr != null) {\n                if (curr.left != null) {\n                    curr.left.next = curr.right;\n                }\n                if (curr.right != null &amp;&amp; curr.next != null) {\n                    curr.right.next = curr.next.left;\n                }\n                curr = curr.next;\n            }\n            levelStart = levelStart.left;\n        }\n        return root;\n    }\n}\n</code></pre>"},{"location":"dsa/medium/Remove_Duplicates_from_Sorted_Array_II/","title":"Problem: Remove Duplicates from Sorted Array II","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Remove_Duplicates_from_Sorted_Array_II/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Remove_Duplicates_from_Sorted_List_II/","title":"Problem: Remove Duplicates from Sorted List II","text":""},{"location":"dsa/medium/Remove_Duplicates_from_Sorted_List_II/#summary-of-approach","title":"Summary of Approach","text":"<p>The problem \"Remove Duplicates from Sorted List II\" asks to remove all nodes with duplicate values from a sorted linked list, leaving only unique nodes.  The solution iterates through the linked list.  A \"dummy\" node is often used to simplify handling the head of the list.  We maintain a pointer to the current node being examined and a pointer to the previous node. If the current node's value is the same as the next node's value (a duplicate), the current node is skipped by connecting the previous node to the node after the current one. If the current node's value is different from the next node's value (not a duplicate), the pointers are simply moved forward.  This process continues until the end of the list is reached. The resulting list contains only unique nodes.</p>"},{"location":"dsa/medium/Remove_Duplicates_from_Sorted_List_II/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(N) - The algorithm iterates through the linked list once, where N is the number of nodes.</li> <li>Space: O(1) - The algorithm uses a constant amount of extra space to store pointers.  It doesn't use any additional data structures whose size depends on the input size.</li> </ul>"},{"location":"dsa/medium/Remove_Duplicates_from_Sorted_List_II/#java-solution","title":"Java Solution","text":"<pre><code>/**\n * Remove Duplicates from Sorted List II\n * Difficulty: Medium\n * Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the head of the modified linked list.\n *\n * Example 1:\n * Input: head = [1,2,3,3,4,4,5]\n * Output: [1,2,5]\n *\n * Example 2:\n * Input: head = [1,1,1,2,3]\n * Output: [2,3]\n *\n * Constraints:\n * The number of nodes in the list is in the range [0, 300].\n * -100 &lt;= Node.val &lt;= 100\n * The list is guaranteed to be sorted.\n */\nclass RemoveDuplicatesFromSortedListII {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode prev = dummy;\n        ListNode curr = head;\n\n        while (curr != null) {\n            boolean duplicate = false;\n            while (curr.next != null &amp;&amp; curr.val == curr.next.val) {\n                duplicate = true;\n                curr = curr.next;\n            }\n\n            if (duplicate) {\n                prev.next = curr.next;\n            } else {\n                prev = curr;\n            }\n            curr = curr.next;\n        }\n\n        return dummy.next;\n    }\n\n    public class ListNode {\n        int val;\n        ListNode next;\n        ListNode() {}\n        ListNode(int val) { this.val = val; }\n        ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n    }\n}\n</code></pre>"},{"location":"dsa/medium/Remove_Nth_Node_From_End_of_List/","title":"Problem: Remove Nth Node From End of List","text":"<p>\u26a0\ufe0f Error generating content: 404 Publisher Model <code>projects/generativelanguage-ga/locations/us-central1/publishers/google/models/gemini-1.5-flash-002</code> was not found or your project does not have access to it. Please ensure you are using a valid model version. For more information, see: https://cloud.google.com/vertex-ai/generative-ai/docs/learn/model-versions</p>"},{"location":"dsa/medium/Remove_Nth_Node_From_End_of_List/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 Publisher Model `projects/generativelanguage-ga/locations/us-central1/publishers/google/models/gemini-1.5-flash-002` was not found or your project does not have access to it. Please ensure you are using a valid model version. For more information, see: https://cloud.google.com/vertex-ai/generative-ai/docs/learn/model-versions\n</code></pre>"},{"location":"dsa/medium/Smallest_Subtree_with_all_the_Deepest_Nodes/","title":"Problem: Smallest Subtree with all the Deepest Nodes","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Smallest_Subtree_with_all_the_Deepest_Nodes/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/SortColors/","title":"SortColors","text":""},{"location":"dsa/medium/SortColors/#summary-of-approach","title":"Summary of Approach","text":"<p>The \"Sort Colors\" problem asks to sort an array of 0s, 1s, and 2s in-place.  A highly efficient approach uses a three-pointer technique.  We maintain three pointers: <code>p0</code>, <code>p1</code>, and <code>p2</code>.</p> <ul> <li><code>p0</code>: Points to the last index of the 0s section.  Everything before <code>p0</code> is a 0.</li> <li><code>p1</code>: Points to the current element being considered.</li> <li><code>p2</code>: Points to the first index of the 2s section. Everything after <code>p2</code> is a 2.</li> </ul> <p>The algorithm iterates through the array with <code>p1</code>.</p> <ul> <li>If <code>arr[p1]</code> is 0, we swap <code>arr[p1]</code> and <code>arr[p0]</code>, then increment both <code>p0</code> and <code>p1</code>.</li> <li>If <code>arr[p1]</code> is 1, we simply increment <code>p1</code>.</li> <li>If <code>arr[p1]</code> is 2, we swap <code>arr[p1]</code> and <code>arr[p2]</code>, then decrement <code>p2</code>.</li> </ul> <p>This process partitions the array into three sections: 0s, 1s, and 2s, efficiently sorting the array in-place.  Note that the swaps are done carefully to avoid overwriting unsorted elements.</p>"},{"location":"dsa/medium/SortColors/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(n) - The algorithm iterates through the array once.  While there are swaps, the number of swaps is proportional to n in the worst case.</li> <li>Space: O(1) - The algorithm uses only a constant amount of extra space to store the pointers.</li> </ul>"},{"location":"dsa/medium/Sort_Colors/","title":"Problem: Sort Colors","text":""},{"location":"dsa/medium/Sort_Colors/#summary-of-approach","title":"Summary of Approach","text":"<p>The \"Sort Colors\" problem requires sorting an array of integers representing colors (0, 1, and 2) in-place, without using any sorting library functions.  A common and efficient approach is the two-pointer (or three-pointer) technique.  We use two pointers, <code>low</code> and <code>high</code>, initialized to the beginning and end of the array, respectively.  A <code>mid</code> pointer iterates through the array.</p> <p>The algorithm proceeds as follows:</p> <ol> <li>Iterate: The <code>mid</code> pointer iterates through the array.</li> <li>0 encountered: If <code>arr[mid] == 0</code>, swap <code>arr[mid]</code> and <code>arr[low]</code>, then increment both <code>low</code> and <code>mid</code>. This ensures all 0s are moved to the beginning.</li> <li>1 encountered: If <code>arr[mid] == 1</code>, only increment <code>mid</code>.  The 1s will be in their correct position after processing the 0s and 2s.</li> <li>2 encountered: If <code>arr[mid] == 2</code>, swap <code>arr[mid]</code> and <code>arr[high]</code>, then decrement <code>high</code>. This ensures all 2s are moved to the end.</li> <li>Repeat: Continue until <code>mid</code> surpasses <code>high</code>.</li> </ol> <p>This approach efficiently sorts the array in-place by partitioning it into three sections: 0s, 1s, and 2s.</p>"},{"location":"dsa/medium/Sort_Colors/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(n) - The algorithm iterates through the array once.  Swapping elements takes constant time.</li> <li>Space: O(1) - The algorithm uses only a constant amount of extra space for the pointers (<code>low</code>, <code>mid</code>, <code>high</code>).</li> </ul>"},{"location":"dsa/medium/Sort_Colors/#java-solution","title":"Java Solution","text":"<pre><code>/*\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n\nYou must solve this problem without using the library's sort function.\n\nDifficulty: Medium\n*/\nclass SortColors {\n    public void sortColors(int[] nums) {\n        int n = nums.length;\n        int p0 = 0, p1 = 0;\n        for (int i = 0; i &lt; n; ++i) {\n            if (nums[i] == 0) {\n                swap(nums, i, p0);\n                if (p0 &lt; p1)\n                    swap(nums, i, p1);\n                p0++;\n                p1++;\n            } else if (nums[i] == 1) {\n                swap(nums, i, p1);\n                p1++;\n            }\n        }\n    }\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n</code></pre>"},{"location":"dsa/medium/String_to_Integer_atoi/","title":"Problem: String to Integer (atoi)","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/String_to_Integer_atoi/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Subarray_Sum_Equals_K/","title":"Problem: Subarray Sum Equals K","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Subarray_Sum_Equals_K/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Subsets/","title":"Problem: Subsets","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Subsets/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Substring_with_Concatenation_of_All_Words/","title":"Problem: Substring with Concatenation of All Words","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Substring_with_Concatenation_of_All_Words/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Unique_Paths_II/","title":"Problem: Unique Paths II","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Unique_Paths_II/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Unique_Paths_III/","title":"Problem: Unique Paths III","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Unique_Paths_III/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"dsa/medium/Valid_Parentheses/","title":"Problem: Valid Parentheses","text":"<p>\u26a0\ufe0f Error generating content: 404 Publisher Model <code>projects/generativelanguage-ga/locations/us-central1/publishers/google/models/gemini-1.5-flash-002</code> was not found or your project does not have access to it. Please ensure you are using a valid model version. For more information, see: https://cloud.google.com/vertex-ai/generative-ai/docs/learn/model-versions</p>"},{"location":"dsa/medium/Valid_Parentheses/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 Publisher Model `projects/generativelanguage-ga/locations/us-central1/publishers/google/models/gemini-1.5-flash-002` was not found or your project does not have access to it. Please ensure you are using a valid model version. For more information, see: https://cloud.google.com/vertex-ai/generative-ai/docs/learn/model-versions\n</code></pre>"},{"location":"dsa/medium/Word_Ladder/","title":"Problem: Word Ladder","text":""},{"location":"dsa/medium/Word_Ladder/#summary-of-approach","title":"Summary of Approach","text":"<p>The Word Ladder problem aims to find the shortest transformation sequence from a starting word to an ending word, changing only one letter at a time, and using only words from a given dictionary.  A common approach uses Breadth-First Search (BFS).  The algorithm starts with the beginning word and explores its neighbors (words differing by one letter) at each level.  It continues this exploration level by level until it finds the target word or exhausts all possibilities.  Each visited word is marked to prevent cycles.  The length of the shortest path found represents the length of the word ladder.  If the target word is unreachable, the algorithm returns -1 or an empty list.</p>"},{"location":"dsa/medium/Word_Ladder/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li>Time: O(M * N), where N is the number of words in the dictionary and M is the average length of a word. In the worst case, BFS might visit all words in the dictionary. Each visit involves checking its neighbors which can take O(M) time in the worst case (checking against all other words).</li> <li>Space: O(N),  In the worst case, all words in the dictionary might be added to the queue during the BFS traversal.  The space used for visited words also depends on the dictionary size (N).</li> </ul>"},{"location":"dsa/medium/Word_Ladder/#java-solution","title":"Java Solution","text":"<pre><code>import java.util.*;\n\n/*\nGiven two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\n\nOnly one letter can be changed at a time.\nEach intermediate word must exist in the word list.\nIf no such transformation sequence exists, return 0.\n\nExample 1:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: As one shortest transformation is \"hit\" -&gt; \"hot\" -&gt; \"dot\" -&gt; \"dog\" -&gt; \"cog\", return its length 5.\nExample 2:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: 0\nExplanation: The endWord \"cog\" is not in wordList, therefore no possible transformation.\n\nConstraints:\n\n1 &lt;= beginWord.length &lt;= 10\nendWord.length == beginWord.length\n1 &lt;= wordList.length &lt;= 5000\nwordList[i].length == beginWord.length\nbeginWord, endWord, and wordList[i] consist of lowercase English letters.\nbeginWord != endWord\nAll the strings in wordList are unique.\n\n\nDifficulty: Medium\n*/\nclass WordLadder {\n    public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) {\n        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();\n        Set&lt;String&gt; visited = new HashSet&lt;&gt;();\n        Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList);\n\n        if (!wordSet.contains(endWord)) {\n            return 0;\n        }\n\n        queue.offer(beginWord);\n        visited.add(beginWord);\n        int level = 1;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i &lt; size; i++) {\n                String currentWord = queue.poll();\n                if (currentWord.equals(endWord)) {\n                    return level;\n                }\n                for (String neighbor : getNeighbors(currentWord, wordSet)) {\n                    if (!visited.contains(neighbor)) {\n                        visited.add(neighbor);\n                        queue.offer(neighbor);\n                    }\n                }\n            }\n            level++;\n        }\n        return 0;\n    }\n\n    private List&lt;String&gt; getNeighbors(String word, Set&lt;String&gt; wordSet) {\n        List&lt;String&gt; neighbors = new ArrayList&lt;&gt;();\n        char[] chars = word.toCharArray();\n        for (int i = 0; i &lt; chars.length; i++) {\n            char originalChar = chars[i];\n            for (char c = 'a'; c &lt;= 'z'; c++) {\n                chars[i] = c;\n                String newWord = new String(chars);\n                if (wordSet.contains(newWord) &amp;&amp; !newWord.equals(word)) {\n                    neighbors.add(newWord);\n                }\n            }\n            chars[i] = originalChar;\n        }\n        return neighbors;\n    }\n}\n</code></pre>"},{"location":"dsa/medium/Zigzag_Conversion/","title":"Problem: Zigzag Conversion","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"dsa/medium/Zigzag_Conversion/#java-solution","title":"Java Solution","text":"<pre><code>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\n</code></pre>"},{"location":"notes/","title":"Notes","text":"<p>General notes and references.</p>"},{"location":"notes/dsa/AVL_Tree/","title":"AVL Tree","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Applications_Priority_Queues_Dijkstras_Algorithm/","title":"Applications Priority Queues Dijkstras Algorithm","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Bellman-Ford_Algorithm_for_negative_weights/","title":"Bellman Ford Algorithm for negative weights","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Big_Omega_Notation__Lower_Bound/","title":"Big Omega Notation  Lower Bound","text":""},{"location":"notes/dsa/Big_Omega_Notation__Lower_Bound/#big-omega-notation-lower-bound","title":"Big Omega Notation (\u03a9): Lower Bound","text":"<p>## 1. Introduction</p> <p>Big Omega (\u03a9) notation is a crucial concept in algorithm analysis used to describe the lower bound of a function's growth rate.  Unlike Big O notation, which provides an upper bound (worst-case scenario), Big Omega gives a lower bound \u2013 a guarantee of at least how fast an algorithm will run, even in the best-case scenario.  Understanding Big Omega is essential for comprehensively evaluating algorithm efficiency and making informed choices when selecting algorithms for specific tasks.  It complements Big O notation, providing a more complete picture of an algorithm's performance characteristics.  While Big O often dominates discussions, neglecting Big Omega can lead to an incomplete understanding of an algorithm's potential.</p> <p>## 2. Core Concepts</p> <ul> <li> <p>Formal Definition:  A function f(n) is said to be Big Omega of g(n), written as f(n) = \u03a9(g(n)), if there exist positive constants c and n\u2080 such that 0 \u2264 c * g(n) \u2264 f(n) for all n \u2265 n\u2080.  This means that for sufficiently large inputs (n \u2265 n\u2080), f(n) is always greater than or equal to a constant multiple (c) of g(n).  The constant c accounts for variations in machine architecture and implementation details; the focus remains on the growth trend.</p> </li> <li> <p>Lower Bound:  Big Omega provides a lower bound on the growth rate. It guarantees that the algorithm will never perform worse than \u03a9(g(n)), regardless of the input data.  This is valuable for identifying algorithms that are inherently efficient, even under optimal conditions.</p> </li> <li> <p>Asymptotic Behavior: Like Big O, Big Omega focuses on the asymptotic behavior of the function \u2013 how it grows as the input size (n) approaches infinity.  Small variations for small inputs are ignored; the emphasis is on the long-term growth trend.</p> </li> <li> <p>Relationship with Big O and Big Theta:</p> <ul> <li>Big O (O):  Provides an upper bound on the growth rate (worst-case).</li> <li>Big Omega (\u03a9): Provides a lower bound on the growth rate (best-case).</li> <li>Big Theta (\u0398):  Provides both an upper and lower bound, indicating a tight bound on the growth rate (both best-case and worst-case are the same order).  If f(n) = \u0398(g(n)), then f(n) = O(g(n)) and f(n) = \u03a9(g(n)).</li> </ul> </li> <li> <p>Types of Big Omega:</p> <ul> <li>\u03a9(g(n)): This is the standard Big Omega notation, indicating a lower bound.</li> <li>\u03c9(g(n)):  This represents a strict lower bound, meaning f(n) grows strictly faster than g(n).  It implies f(n) = \u03a9(g(n)) but not f(n) = \u0398(g(n)).</li> </ul> </li> </ul> <p>## 3. Practical Examples</p> <p>Example 1: Linear Search</p> <p>Consider a linear search algorithm that searches for a specific element in an unsorted array.</p> <ul> <li>Worst-case (Big O): O(n) - The element might be at the end of the array.</li> <li>Best-case (Big Omega): \u03a9(1) - The element might be at the beginning of the array.</li> </ul> <p>This illustrates that even in the best-case scenario, the linear search will take at least constant time (\u03a9(1)), as it only needs to check the first element.</p> <p>Example 2: Optimized Sorting Algorithm</p> <p>Imagine a sorting algorithm that boasts a best-case time complexity of O(n).  In reality this best-case performance might only apply to a specific class of inputs.  The Big Omega provides context. If its Big Omega is also \u03a9(n log n), then while the algorithm might achieve O(n) in some cases, you can't expect it to perform better than n log n in the general case.  This provides a more accurate description of the algorithm's performance compared to relying on Big O alone.</p> <p>Example 3:  Finding the Minimum Element</p> <p>Finding the minimum element in an unsorted array:</p> <ul> <li>Worst-case (Big O): O(n) \u2013 You might need to examine all elements.</li> <li>Best-case (Big Omega): \u03a9(n) \u2013 You must at least examine one element to know that the array is not empty and to find a starting minimum.</li> </ul> <p>In this case, the best-case and worst-case complexities are both linear, so the algorithm's complexity is \u0398(n).</p> <p>## 4. Conclusion</p> <p>Big Omega notation is a fundamental tool in algorithm analysis that complements Big O notation by providing a lower bound on an algorithm's runtime.  It helps provide a more complete and nuanced understanding of an algorithm's efficiency by highlighting its best-case performance.  While Big O often receives more attention, the use of Big Omega prevents an overly optimistic assessment of an algorithm's capabilities and assists in making more informed choices regarding algorithm selection and optimization.  Combining Big O, Big Omega, and Big Theta provides the most comprehensive understanding of an algorithm's performance characteristics.</p>"},{"location":"notes/dsa/Binary_Search_Tree_BST__Self-Balancing_BSTs/","title":"Binary Search Tree BST  Self Balancing BSTs","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Binary_Tree_BT/","title":"Binary Tree BT","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Bitwise_Operators_AND_OR_XOR_NOT_Shifts/","title":"Bitwise Operators AND OR XOR NOT Shifts","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Breadth-First_Search_BFS/","title":"Breadth First Search BFS","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Bucket_Sort/","title":"Bucket Sort","text":""},{"location":"notes/dsa/Bucket_Sort/#bucket-sort-premium-study-notes","title":"Bucket Sort: Premium Study Notes","text":"<p>1. Introduction</p> <p>Bucket Sort is a distribution-based sorting algorithm that works by distributing the elements of an array into a number of buckets or containers.  Each bucket is then sorted individually, either using a different sorting algorithm (often insertion sort for small buckets) or recursively using bucket sort itself. Finally, the sorted buckets are concatenated to produce the fully sorted output.  Bucket sort is efficient when the input is uniformly distributed over a range.  Its performance is highly dependent on the distribution of input data;  a skewed distribution can lead to significantly degraded performance.  Unlike comparison-based sorting algorithms like merge sort or quicksort, bucket sort doesn't rely on comparing elements directly; instead, it leverages the distribution of data to achieve sorting. This makes it a non-comparison sort.</p> <p>2. Core Concepts</p> <ul> <li> <p>Buckets:  The fundamental data structure in bucket sort. These are typically lists or arrays used to hold a subset of the input elements. The number of buckets is a crucial parameter that affects the algorithm's efficiency.</p> </li> <li> <p>Distribution Function:  A function that maps each input element to a specific bucket. This function is critical for the efficiency of the algorithm. A good distribution function will distribute elements evenly across the buckets.  A common approach is to use a hash function or a simple division-based mapping (e.g., <code>bucketIndex = floor(elementValue / bucketRange)</code>).</p> </li> <li> <p>Bucket Size: The number of elements each bucket can hold.  This can be fixed or variable.  Variable bucket size can adapt to uneven data distributions more effectively.</p> </li> <li> <p>Individual Bucket Sorting: Once elements are distributed, each bucket needs to be sorted individually.  This is often done with a simple algorithm like insertion sort, which is efficient for small, nearly-sorted lists.  Alternatively, bucket sort can be applied recursively to each bucket.</p> </li> <li> <p>Concatenation: After each bucket is sorted, the sorted buckets are concatenated to form the final sorted array.</p> </li> </ul> <p>3. Practical Examples</p> <p>Example 1: Sorting floating-point numbers between 0 and 1</p> <p>Let's sort the array <code>[0.897, 0.565, 0.656, 0.123, 0.665, 0.343, 0.912]</code> using 5 buckets.</p> <ol> <li> <p>Distribution: We'll use the simple division-based mapping: <code>bucketIndex = floor(element * 5)</code>.  This maps each element to a bucket based on its value.</p> </li> <li> <p>Bucketing:</p> <ul> <li>Bucket 0: [0.123]</li> <li>Bucket 1: [0.343]</li> <li>Bucket 2: [0.565]</li> <li>Bucket 3: [0.656, 0.665]</li> <li>Bucket 4: [0.897, 0.912]</li> </ul> </li> <li> <p>Sorting Buckets: Each bucket is already sorted (or requires only trivial sorting in this example).</p> </li> <li> <p>Concatenation: Concatenating the buckets gives the sorted array: <code>[0.123, 0.343, 0.565, 0.656, 0.665, 0.897, 0.912]</code></p> </li> </ol> <p>Example 2 (Illustrating recursive application):  If a bucket contains a significant number of elements, instead of using insertion sort, we can recursively apply bucket sort to that bucket.  This adds a layer of complexity but can improve performance for uneven distributions.</p> <p>Code Example (Python):  This example utilizes insertion sort for individual buckets.</p> <pre><code>def insertion_sort(bucket):\n    for i in range(1, len(bucket)):\n        key = bucket[i]\n        j = i - 1\n        while j &gt;= 0 and key &lt; bucket[j]:\n            bucket[j + 1] = bucket[j]\n            j -= 1\n        bucket[j + 1] = key\n\ndef bucket_sort(arr, num_buckets):\n    buckets = [[] for _ in range(num_buckets)]\n    for num in arr:\n        index = int(num * num_buckets) # assumes numbers are between 0 and 1\n        buckets[index].append(num)\n\n    for bucket in buckets:\n        insertion_sort(bucket)\n\n    sorted_arr = []\n    for bucket in buckets:\n        sorted_arr.extend(bucket)\n\n    return sorted_arr\n\narr = [0.897, 0.565, 0.656, 0.123, 0.665, 0.343, 0.912]\nsorted_arr = bucket_sort(arr, 5)\nprint(sorted_arr)\n</code></pre> <p>4. Conclusion</p> <p>Bucket sort offers an efficient alternative to comparison-based sorting algorithms when the input data is uniformly distributed.  Its average-case time complexity is O(n+k), where n is the number of elements and k is the number of buckets.  However, its worst-case complexity can be O(n^2) if the data is highly clustered in a few buckets.  The choice of the distribution function and the method used to sort individual buckets significantly impacts the algorithm's performance. The optimal number of buckets often depends on the data and needs to be determined empirically or through analysis of the data distribution.  It's crucial to understand the limitations of bucket sort and to choose an appropriate sorting algorithm based on the characteristics of the input data.</p>"},{"location":"notes/dsa/Coin_Change_Problem/","title":"Coin Change Problem","text":""},{"location":"notes/dsa/Coin_Change_Problem/#coin-change-problem-premium-study-notes","title":"Coin Change Problem: Premium Study Notes","text":"<p>## 1. Introduction</p> <p>The Coin Change problem is a classic combinatorial optimization problem in computer science and mathematics.  The problem statement is deceptively simple: given a set of coin denominations and a target amount, determine the minimum number of coins needed to make up that amount.  While seemingly straightforward, the problem's complexity arises from the potential for numerous combinations of coins and the need to find the optimal solution (minimum number of coins).  This problem has applications in various fields, including:</p> <ul> <li>Finance: Optimizing cash transactions and minimizing the number of coins/bills dispensed by ATMs or vending machines.</li> <li>Operations Research: Resource allocation and inventory management.</li> <li>Computer Science: Algorithm design and dynamic programming.</li> </ul> <p>This document provides a comprehensive understanding of the Coin Change problem, covering its core concepts, various approaches to solving it, and illustrative examples.</p> <p>## 2. Core Concepts</p> <p>The core of the Coin Change problem revolves around several key concepts:</p> <ul> <li> <p>Coin Denominations: A set of positive integer values representing the available coin denominations (e.g., {1, 5, 10, 25} for US currency).  These denominations are typically assumed to be sorted in ascending order for efficiency.</p> </li> <li> <p>Target Amount: A positive integer representing the total amount that needs to be made up using the available coin denominations.</p> </li> <li> <p>Minimum Number of Coins: The objective is to find the combination of coins that sums up to the target amount while using the fewest number of coins possible.  It's crucial to note that this doesn't necessarily imply using the largest denominations first.</p> </li> <li> <p>Greedy Approach: A simple, intuitive approach where you repeatedly select the largest available coin that is less than or equal to the remaining amount.  While often efficient, the greedy approach doesn't guarantee an optimal solution for all coin denominations.  It works optimally only for certain coin systems (e.g., {1, 5, 10, 25}).</p> </li> <li> <p>Dynamic Programming: A more robust technique that explores all possible combinations of coins to find the optimal solution.  It typically involves building a table (or array) to store the minimum number of coins needed for amounts from 0 up to the target amount.  This approach guarantees the optimal solution but may have higher space and time complexity compared to the greedy approach.</p> </li> </ul> <p>## 3. Practical Examples</p> <p>Let's illustrate the Coin Change problem with examples and different solution approaches:</p> <p>Example 1:</p> <ul> <li>Coin Denominations: {1, 2, 5}</li> <li> <p>Target Amount: 11</p> </li> <li> <p>Greedy Approach:</p> <ol> <li>5 + 5 + 1 = 11 (3 coins) This is the optimal solution in this case.</li> </ol> </li> <li> <p>Dynamic Programming Approach: A dynamic programming solution would systematically explore all possibilities, even though the greedy approach yields the optimal solution here.  The dynamic programming table would show the minimum coins needed for each amount from 0 to 11.</p> </li> </ul> <p>Example 2 (Greedy Approach Fails):</p> <ul> <li>Coin Denominations: {1, 3, 4}</li> <li> <p>Target Amount: 6</p> </li> <li> <p>Greedy Approach:</p> <ol> <li>4 + 1 + 1 = 6 (3 coins)</li> </ol> </li> <li> <p>Optimal Solution:</p> <ol> <li>3 + 3 = 6 (2 coins)  The greedy approach fails to find the optimal solution here.</li> </ol> </li> </ul> <p>This example highlights the limitation of the greedy approach.  Dynamic programming would correctly identify the optimal solution of using two coins (two 3's).</p> <p>## 4. Conclusion</p> <p>The Coin Change problem is a valuable case study demonstrating the trade-offs between algorithmic approaches.  While the greedy approach offers simplicity and speed in certain scenarios, its limitations are exposed when dealing with arbitrary coin denominations. Dynamic programming, although more computationally expensive, guarantees the optimal solution for all instances of the problem.  The choice of algorithm depends on the specific context \u2013 the size of the coin denominations set, the frequency of problem occurrences, and the tolerance for suboptimal solutions.  Understanding both approaches provides a deep insight into algorithmic design and optimization techniques.  Further exploration could involve analyzing the time and space complexities of both algorithms and examining variations of the problem, such as unbounded knapsack problems.</p>"},{"location":"notes/dsa/Common_Techniques_Get_Set_Clear_bit_Counting_set_b/","title":"Common Techniques Get Set Clear bit Counting set b","text":""},{"location":"notes/dsa/Common_Techniques_Get_Set_Clear_bit_Counting_set_b/#bit-manipulation-techniques-a-comprehensive-guide","title":"Bit Manipulation Techniques: A Comprehensive Guide","text":""},{"location":"notes/dsa/Common_Techniques_Get_Set_Clear_bit_Counting_set_b/#1-introduction","title":"1. Introduction","text":"<p>Bit manipulation, the art of directly manipulating individual bits within a data type (like integers), is a fundamental skill in computer science with broad applications.  While seemingly low-level, mastering bit manipulation can lead to significant performance improvements in algorithms and a deeper understanding of how computers work. This guide explores common bit manipulation techniques, including getting, setting, clearing bits, and counting set bits. These techniques are crucial for working with bit flags, optimizing algorithms, and understanding low-level programming.  Proficiency in these techniques is beneficial for areas such as embedded systems, graphics programming, and algorithm optimization.</p>"},{"location":"notes/dsa/Common_Techniques_Get_Set_Clear_bit_Counting_set_b/#2-core-concepts","title":"2. Core Concepts","text":"<p>This section details the core concepts and underlying logic behind common bit manipulation techniques. We will primarily focus on unsigned integers for simplicity, though the principles apply to signed integers as well (with considerations for two's complement representation).</p> <p>a) Bitwise Operators: The foundation of bit manipulation lies in bitwise operators.  These operators work on individual bits of operands:</p> <ul> <li><code>&amp;</code> (AND):  Sets a bit to 1 if both corresponding bits are 1; otherwise, it's 0.</li> <li><code>|</code> (OR): Sets a bit to 1 if at least one of the corresponding bits is 1.</li> <li><code>^</code> (XOR): Sets a bit to 1 if exactly one of the corresponding bits is 1.</li> <li><code>~</code> (NOT): Inverts all bits (0 becomes 1, 1 becomes 0).</li> <li><code>&lt;&lt;</code> (Left Shift): Shifts bits to the left by a specified number of positions.  Vacated bits are filled with 0s.  Equivalent to multiplying by 2<sup>n</sup> (where n is the number of shifts).</li> <li><code>&gt;&gt;</code> (Right Shift): Shifts bits to the right by a specified number of positions. The behavior of the vacated bits depends on whether the integer is signed or unsigned.  For unsigned integers, they are filled with 0s. For signed integers, the sign bit is replicated (arithmetic right shift).</li> </ul> <p>b) Get Bit: To get the value of a specific bit (e.g., the <code>i</code>-th bit), use the bitwise AND operator with a mask.  The mask is a number with only the <code>i</code>-th bit set to 1.</p> <pre><code>bool getBit(unsigned int n, int i) {\n  return (n &gt;&gt; i) &amp; 1;\n}\n</code></pre> <p>c) Set Bit: To set the <code>i</code>-th bit to 1, use the bitwise OR operator with a mask where only the <code>i</code>-th bit is 1.</p> <pre><code>unsigned int setBit(unsigned int n, int i) {\n  return n | (1 &lt;&lt; i);\n}\n</code></pre> <p>d) Clear Bit: To clear (set to 0) the <code>i</code>-th bit, use the bitwise AND operator with the complement of the mask used for setting the bit.</p> <pre><code>unsigned int clearBit(unsigned int n, int i) {\n  return n &amp; ~(1 &lt;&lt; i);\n}\n</code></pre> <p>e) Counting Set Bits (Hamming Weight):  Several methods exist for efficiently counting the number of 1s in a binary representation of an integer.  These include:</p> <ul> <li>Iterative Approach:  Repeatedly check each bit using the <code>&amp;</code> operator.</li> <li>Brian Kernighan's Algorithm:  Repeatedly clear the least significant set bit until the number becomes 0.  The number of iterations equals the number of set bits. This is generally the most efficient method.</li> <li>Built-in functions: Many processors and programming languages provide built-in functions (<code>__builtin_popcount</code> in GCC/Clang, <code>Integer.bitCount()</code> in Java) for efficient bit counting.</li> </ul>"},{"location":"notes/dsa/Common_Techniques_Get_Set_Clear_bit_Counting_set_b/#3-practical-examples","title":"3. Practical Examples","text":"<p>a) Representing Flags:  Bit manipulation is ideal for representing a collection of boolean flags. Each bit can represent a different flag, saving memory and improving efficiency compared to using an array of booleans.</p> <pre><code>// Flags: 0 - IsActive, 1 - IsAdmin, 2 - IsLoggedIn\nunsigned int userFlags = 0b011; // User is Admin and Logged In\n\nbool isActive = getBit(userFlags, 0);\nuserFlags = setBit(userFlags, 1); // Set Admin flag\n</code></pre> <p>b) Optimizing Algorithms:  Consider calculating the parity of a number (whether it has an odd or even number of 1s in its binary representation). Bit manipulation provides a more efficient solution than iterative checking.</p> <pre><code>bool isEvenParity(unsigned int n) {\n  int count = 0;\n  while (n &gt; 0) {\n    n &amp;= (n - 1); // Clears the least significant set bit\n    count++;\n  }\n  return count % 2 == 0;\n}\n</code></pre>"},{"location":"notes/dsa/Common_Techniques_Get_Set_Clear_bit_Counting_set_b/#4-conclusion","title":"4. Conclusion","text":"<p>Bit manipulation techniques offer a powerful set of tools for optimizing algorithms, compactly representing data, and gaining a deeper understanding of computer architecture.  While the concepts are relatively straightforward, mastering these techniques requires practice and a solid understanding of binary arithmetic and bitwise operators.  The examples provided illustrate the versatility and efficiency that can be achieved through proficient use of bit manipulation.  Remember to choose the most appropriate algorithm for counting set bits based on the target platform and performance requirements; built-in functions are often the most efficient option when available.</p>"},{"location":"notes/dsa/Deque_Double-Ended_Queue/","title":"Deque Double Ended Queue","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Dijkstras_Algorithm_for_non-negative_weights/","title":"Dijkstras Algorithm for non negative weights","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Disjoint_Set_Union_DSU_Union-Find/","title":"Disjoint Set Union DSU Union Find","text":""},{"location":"notes/dsa/Disjoint_Set_Union_DSU_Union-Find/#disjoint-set-union-dsu-union-find-study-notes","title":"Disjoint Set Union (DSU) / Union-Find: Study Notes","text":"<p>## 1. Introduction</p> <p>Disjoint Set Union (DSU), also known as Union-Find, is a data structure that efficiently tracks a set of elements partitioned into a number of disjoint (non-overlapping) subsets.  It excels at solving problems involving connectivity, grouping, and determining whether two elements belong to the same group.  Its core operations are:</p> <ul> <li>Find: Determine which subset a particular element belongs to.</li> <li>Union: Merge two subsets into a single subset.</li> </ul> <p>DSU's efficiency stems from its ability to perform both <code>Find</code> and <code>Union</code> operations in (amortized) near-constant time, making it a powerful tool for various graph algorithms and other applications where managing disjoint sets is crucial.  The key to this efficiency lies in its path compression and union by rank (or size) optimizations.</p> <p>## 2. Core Concepts</p> <p>2.1 Representation:</p> <p>DSU typically uses a parent array (or a linked-list based structure) to represent the disjoint sets.  Each element is associated with a parent node.  If an element is the root of its set, its parent is itself.  All elements in a set form a tree-like structure, with the root representing the set.</p> <p>2.2 Find Operation:</p> <p>The <code>Find</code> operation determines the root of the set containing a given element.  This involves traversing the parent array until the root (parent == element) is reached.  Path compression optimizes this:  during traversal, all nodes along the path are directly linked to the root, shortening future <code>Find</code> operations on those nodes.</p> <p>Algorithm (Find with Path Compression):</p> <pre><code>def find(parent, i):\n  if parent[i] == i:\n    return i\n  parent[i] = find(parent, parent[i]) # Path compression\n  return parent[i]\n</code></pre> <p>2.3 Union Operation:</p> <p>The <code>Union</code> operation merges two sets.  It finds the roots of the two sets using the <code>Find</code> operation.  Then, it connects the root of one set to the root of the other.  Union by rank (or union by size) optimizes this by attaching the smaller tree (lower rank) to the root of the larger tree (higher rank), minimizing tree height and maintaining near-constant time complexity.  Rank (or size) is a heuristic representing the height (or number of nodes) of the tree.</p> <p>Algorithm (Union by Rank):</p> <pre><code>def union(parent, rank, i, j):\n  root_i = find(parent, i)\n  root_j = find(parent, j)\n  if root_i != root_j:\n    if rank[root_i] &lt; rank[root_j]:\n      parent[root_i] = root_j\n    elif rank[root_i] &gt; rank[root_j]:\n      parent[root_j] = root_i\n    else:\n      parent[root_j] = root_i\n      rank[root_i] += 1\n</code></pre> <p>2.4 Amortized Analysis:</p> <p>The combination of path compression and union by rank (or size) leads to an amortized time complexity of nearly O(\u03b1(n)) for both <code>Find</code> and <code>Union</code> operations, where \u03b1(n) is the inverse Ackermann function\u2014a function that grows incredibly slowly, practically constant for all practical input sizes.</p> <p>## 3. Practical Examples</p> <ul> <li>Connectivity in Graphs: Determining if two nodes are connected in an undirected graph.</li> <li>Minimum Spanning Trees (MST): Kruskal's algorithm uses DSU to efficiently manage the connected components during the MST construction.</li> <li>Network Problems: Detecting cycles in networks, identifying connected components in a network.</li> <li>Image Segmentation: Grouping pixels into regions based on similarity.</li> <li>Percolation: Simulating fluid flow through a porous medium.</li> </ul> <p>Example: Kruskal's Algorithm (Conceptual)</p> <p>Kruskal's algorithm iterates through edges sorted by weight. For each edge, it checks if the two nodes belong to different sets using <code>Find</code>. If they do, it adds the edge to the MST and merges the sets using <code>Union</code>.  The DSU ensures efficient checking of cycles and merging of components.</p> <p>## 4. Conclusion</p> <p>Disjoint Set Union is a remarkably efficient data structure with a wide range of applications. Its near-constant time complexity for <code>Find</code> and <code>Union</code> operations, achieved through path compression and union by rank, makes it a valuable tool for solving problems related to connectivity, grouping, and set manipulation. Understanding its core concepts and optimization techniques is essential for efficiently tackling various computational challenges.  While the implementation details may vary slightly depending on the programming language and specific needs, the fundamental principles remain consistent.</p>"},{"location":"notes/dsa/Doubly_Linked_List/","title":"Doubly Linked List","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/FIFO_First-In_First-Out_Principle/","title":"FIFO First In First Out Principle","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Floyd-Warshall_Algorithm_All-Pairs_Shortest_Path/","title":"Floyd Warshall Algorithm All Pairs Shortest Path","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Generating_Permutations_and_Combinations/","title":"Generating Permutations and Combinations","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Linear_Search/","title":"Linear Search","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Matrix_Chain_Multiplication/","title":"Matrix Chain Multiplication","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Maximum_Flow_Ford-Fulkerson_Edmonds-Karp/","title":"Maximum Flow Ford Fulkerson Edmonds Karp","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Merge_Sort/","title":"Merge Sort","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Merge_Sort_Quick_Sort/","title":"Merge Sort Quick Sort","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Prims_Algorithm/","title":"Prims Algorithm","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Quick_Sort_with_partitioning_schemes/","title":"Quick Sort with partitioning schemes","text":""},{"location":"notes/dsa/Quick_Sort_with_partitioning_schemes/#quick-sort-a-deep-dive-into-partitioning-schemes","title":"Quick Sort: A Deep Dive into Partitioning Schemes","text":"<p>## 1. Introduction</p> <p>QuickSort is a highly efficient divide-and-conquer sorting algorithm known for its average-case time complexity of O(n log n).  Unlike merge sort, which requires auxiliary space for merging, QuickSort operates in-place, minimizing memory usage.  Its performance hinges critically on the choice of partitioning scheme, which dictates how the input array is divided into sub-arrays before recursive sorting.  A poorly chosen partitioning strategy can lead to worst-case O(n\u00b2) performance, highlighting the importance of understanding the nuances of different partitioning methods.  This document explores the core mechanics of QuickSort, focusing on the impact of various partitioning schemes on its efficiency and stability.</p> <p>## 2. Core Concepts</p> <p>QuickSort's fundamental principle lies in recursively partitioning the input array around a chosen \"pivot\" element.  The algorithm proceeds as follows:</p> <ol> <li> <p>Partitioning: Select a pivot element from the array.  The chosen pivot's position is crucial for efficiency.  All elements smaller than the pivot are moved to its left, and all elements larger are moved to its right.  This results in a partitioned array where the pivot is in its final sorted position.</p> </li> <li> <p>Recursion: Recursively apply QuickSort to the sub-arrays to the left and right of the pivot.  These sub-arrays now contain elements exclusively smaller and larger than the pivot, respectively.  The recursion continues until sub-arrays become trivially small (typically of size 0 or 1), at which point they are inherently sorted.</p> </li> </ol> <p>Partitioning Schemes:  The efficiency of QuickSort heavily relies on the chosen partitioning scheme. Several popular methods exist, each with its strengths and weaknesses:</p> <ul> <li> <p>Lomuto Partition Scheme:  This scheme is relatively simple to implement but can be less efficient than others. It selects the last element as the pivot.  It iterates through the array, keeping track of an index for elements smaller than the pivot. Elements smaller than the pivot are swapped with elements at this index.  While easy to understand, its worst-case performance is more likely with already sorted or nearly sorted data.</p> </li> <li> <p>Hoare Partition Scheme:  Considered more efficient than Lomuto, Hoare's scheme uses two pointers, one starting from the beginning and the other from the end of the array.  These pointers move towards each other, swapping elements that are out of order (one smaller, one larger than the pivot). The process stops when the pointers cross, resulting in the pivot's correct position.  It's generally less prone to worst-case scenarios than Lomuto.</p> </li> <li> <p>Randomized Partitioning: To mitigate the impact of consistently bad pivot choices (like always selecting the smallest or largest element), a randomized approach is often employed.  This involves selecting the pivot randomly from the array.  This significantly reduces the likelihood of encountering the worst-case O(n\u00b2) time complexity.</p> </li> </ul> <p>Stability:  QuickSort, as typically implemented, is unstable. This means that the relative order of equal elements may not be preserved after sorting.  While modifications can be made to ensure stability, it usually comes at the cost of increased complexity.</p> <p>## 3. Practical Examples</p> <p>Lomuto Partitioning Example:</p> <p>Let's sort the array <code>[8, 3, 1, 7, 0, 10, 2]</code> using Lomuto's scheme with the last element (2) as the pivot.</p> <ol> <li>Pivot: 2</li> <li>Iteration: The algorithm iterates, swapping elements smaller than 2 to the left.</li> <li>Result: <code>[1, 0, 3, 7, 8, 10, 2]</code> (partitioned array \u2013 note 2 is in its final position)</li> <li>Recursion: Recursively sort <code>[1, 0, 3, 7, 8, 10]</code> and <code>[]</code>.</li> </ol> <p>Hoare Partitioning Example:</p> <p>Using the same array, Hoare's scheme would use two pointers, one starting at index 0 and the other at index 6. The process would involve swapping and pointer movement until the pointers cross, placing the pivot (2) in its correct position.  This results in a more efficient partitioning process than Lomuto's method, particularly for larger arrays.</p> <p>## 4. Conclusion</p> <p>QuickSort is a powerful and widely used sorting algorithm.  Its average-case efficiency makes it a strong contender in various applications.  However, its performance is directly tied to the choice of partitioning scheme.  While Lomuto's scheme is simpler to implement, Hoare's scheme generally offers better performance.  Employing a randomized pivot selection significantly improves the algorithm's robustness against worst-case scenarios, ensuring near-optimal performance in most practical situations.  Understanding the nuances of these partitioning schemes is crucial for writing efficient and reliable sorting implementations.  The choice of scheme should be made considering factors such as implementation complexity, expected data distributions, and the need for stability.</p>"},{"location":"notes/dsa/Radix_Sort/","title":"Radix Sort","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Red-Black_Tree/","title":"Red Black Tree","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Selection_Sort/","title":"Selection Sort","text":""},{"location":"notes/dsa/Selection_Sort/#selection-sort-study-notes","title":"Selection Sort: Study Notes","text":"<p>1. Introduction</p> <p>Selection sort is a simple and intuitive sorting algorithm.  It works by repeatedly finding the minimum element from the unsorted part of the list and placing it at the beginning.  While conceptually straightforward, its efficiency is relatively low compared to more advanced algorithms like merge sort or quicksort, making it unsuitable for large datasets. However, its simplicity makes it a valuable tool for educational purposes and understanding fundamental sorting concepts.  It's an in-place algorithm, meaning it sorts the list without requiring significant extra memory.  It's also a stable sort in its basic implementation, meaning the relative order of equal elements is preserved.</p> <p>2. Core Concepts</p> <p>The core idea behind selection sort revolves around these steps:</p> <ol> <li>Find the Minimum:  Iterate through the unsorted portion of the list to locate the element with the minimum value.</li> <li>Swap: Exchange the minimum element found with the element at the beginning of the unsorted portion.</li> <li>Repeat: Repeat steps 1 and 2, progressively shrinking the unsorted portion of the list until the entire list is sorted.</li> </ol> <p>Let's break down the process with pseudocode:</p> <pre><code>function selectionSort(arr):\n  n = length(arr)\n  for i from 0 to n-1:\n    minIndex = i\n    for j from i+1 to n-1:\n      if arr[j] &lt; arr[minIndex]:\n        minIndex = j\n    swap arr[i] and arr[minIndex]\n  return arr\n</code></pre> <p>Key aspects to understand:</p> <ul> <li>Nested Loops: The algorithm uses nested loops. The outer loop iterates through each position in the array, while the inner loop finds the minimum element in the remaining unsorted portion.</li> <li>In-place Sorting:  The algorithm only uses a constant amount of extra space (for storing <code>minIndex</code>), making it memory-efficient.</li> <li>Time Complexity: Selection sort has a time complexity of O(n\u00b2) in all cases (best, average, and worst), making it inefficient for large datasets.  This is because the nested loops require a number of comparisons proportional to n\u00b2.</li> <li>Space Complexity:  Its space complexity is O(1), making it space-efficient.</li> </ul> <p>3. Practical Examples</p> <p>Example 1: Sorting a small array</p> <p>Let's sort the array <code>[64, 25, 12, 22, 11]</code> using selection sort:</p> <ol> <li>Iteration 1: Minimum is 11. Swap 64 and 11: <code>[11, 25, 12, 22, 64]</code></li> <li>Iteration 2: Minimum is 12. Swap 25 and 12: <code>[11, 12, 25, 22, 64]</code></li> <li>Iteration 3: Minimum is 22. Swap 25 and 22: <code>[11, 12, 22, 25, 64]</code></li> <li>Iteration 4: Minimum is 25. No swap needed: <code>[11, 12, 22, 25, 64]</code></li> <li>The array is now sorted.</li> </ol> <p>Example 2 (Python Code):</p> <pre><code>def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] &lt; arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]  # Pythonic swap\n    return arr\n\nmy_list = [64, 25, 12, 22, 11]\nsorted_list = selection_sort(my_list)\nprint(f\"Sorted array: {sorted_list}\")\n</code></pre> <p>4. Conclusion</p> <p>Selection sort, despite its O(n\u00b2) time complexity, provides a valuable learning experience in understanding basic sorting algorithms. Its simplicity and in-place nature make it an excellent starting point for grasping fundamental concepts like iterative processes and nested loops.  However, for real-world applications involving large datasets, more efficient algorithms like merge sort or quicksort are strongly recommended.  Understanding selection sort's strengths and limitations is crucial for a comprehensive grasp of algorithm design and analysis.</p>"},{"location":"notes/dsa/Singly_Linked_List/","title":"Singly Linked List","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Terminology_Root_Node_Leaf_Height_Depth/","title":"Terminology Root Node Leaf Height Depth","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Terminology_Vertex_Edge_Path_Cycle/","title":"Terminology Vertex Edge Path Cycle","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Ternary_Search/","title":"Ternary Search","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Time_Complexity_Analyzing_iterative_and_recursive_/","title":"Time Complexity Analyzing iterative and recursive","text":""},{"location":"notes/dsa/Time_Complexity_Analyzing_iterative_and_recursive_/#time-complexity-analyzing-iterative-and-recursive-algorithms","title":"Time Complexity: Analyzing Iterative and Recursive Algorithms","text":"<p>1. Introduction</p> <p>Understanding time complexity is crucial for writing efficient algorithms.  It allows us to predict how the runtime of an algorithm scales with the size of the input data.  This isn't about measuring the exact execution time in seconds (which depends on hardware, etc.), but rather about characterizing the growth rate of runtime as the input size increases. We typically use Big O notation (O(n)) to express this growth rate, focusing on the dominant factors as the input size becomes very large.  This document will explore time complexity analysis, focusing on the comparison between iterative and recursive approaches to problem-solving.</p> <p>2. Core Concepts</p> <ul> <li> <p>Big O Notation:  A mathematical notation used to describe the upper bound of an algorithm's growth rate.  It expresses how the runtime increases as the input size (usually denoted as 'n') approaches infinity. Common complexities include:</p> <ul> <li>O(1): Constant time:  The runtime remains the same regardless of input size (e.g., accessing an element in an array by index).</li> <li>O(log n): Logarithmic time: The runtime increases logarithmically with input size (e.g., binary search).</li> <li>O(n): Linear time: The runtime increases linearly with input size (e.g., iterating through an array).</li> <li>O(n log n): Linearithmic time:  A common complexity for efficient sorting algorithms (e.g., merge sort).</li> <li>O(n\u00b2): Quadratic time: The runtime increases proportionally to the square of the input size (e.g., nested loops iterating through an array).</li> <li>O(2\u207f): Exponential time: The runtime doubles with each addition to the input size (e.g., brute-force solving the traveling salesman problem).</li> <li>O(n!): Factorial time: The runtime grows factorially with the input size (e.g., generating all permutations of a sequence).</li> </ul> </li> <li> <p>Iterative Algorithms: These algorithms use loops (e.g., <code>for</code>, <code>while</code>) to repeat a block of code. They typically have a simpler structure and often exhibit better performance than recursive algorithms due to lower overhead.</p> </li> <li> <p>Recursive Algorithms: These algorithms call themselves within their own definition. They break down a problem into smaller, self-similar subproblems until a base case is reached.  Recursion can lead to elegant and concise code but may incur higher overhead due to function call stacks.</p> </li> <li> <p>Analyzing Time Complexity: To analyze an algorithm's time complexity:</p> <ol> <li>Identify the basic operations: Determine the operations that contribute most significantly to the runtime.</li> <li>Count the number of basic operations: Express this count as a function of the input size 'n'.</li> <li>Determine the dominant term: Ignore constant factors and lower-order terms, focusing on the term that grows fastest as 'n' increases.</li> <li>Express the complexity using Big O notation:  The dominant term represents the algorithm's Big O complexity.</li> </ol> </li> </ul> <p>3. Practical Examples</p> <p>Let's compare iterative and recursive approaches to calculating the factorial of a number:</p> <p>Iterative Factorial:</p> <pre><code>def iterative_factorial(n):\n  if n == 0:\n    return 1\n  result = 1\n  for i in range(1, n + 1):\n    result *= i\n  return result\n</code></pre> <p>Time Complexity: O(n) \u2013 The loop iterates 'n' times.</p> <p>Recursive Factorial:</p> <pre><code>def recursive_factorial(n):\n  if n == 0:\n    return 1\n  else:\n    return n * recursive_factorial(n - 1)\n</code></pre> <p>Time Complexity: O(n) \u2013 The function calls itself 'n' times.</p> <p>Analysis: Both algorithms have the same time complexity, O(n). However, the recursive version might be slightly slower due to function call overhead.  For very large 'n', the recursive approach could lead to stack overflow errors.</p> <p>Example with different complexities:</p> <p>Consider searching for an element in a sorted array:</p> <ul> <li>Linear Search (Iterative): O(n) - Worst-case scenario involves checking every element.</li> <li>Binary Search (Recursive): O(log n) -  Repeatedly divides the search interval in half.</li> </ul> <p>4. Conclusion</p> <p>Choosing between iterative and recursive approaches depends on the specific problem and its constraints.  Iterative solutions often offer better performance and avoid stack overflow issues, especially for large inputs.  However, recursive solutions can provide more elegant and concise code for problems that naturally lend themselves to a recursive breakdown.  Thorough time complexity analysis is essential to ensure that chosen algorithm scales efficiently with increasing input size, avoiding performance bottlenecks in real-world applications.  Remember to consider both Big O notation (worst-case scenario) and potentially average-case complexity for a comprehensive understanding.</p>"},{"location":"notes/dsa/Tree_Traversals_Pre-order_In-order_Post-order_Leve/","title":"Tree Traversals Pre order In order Post order Leve","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/dsa/Types_Directed_vs_Undirected_Weighted_vs_Unweighte/","title":"Types Directed vs Undirected Weighted vs Unweighte","text":""},{"location":"notes/dsa/Types_Directed_vs_Undirected_Weighted_vs_Unweighte/#graph-theory-directed-vs-undirected-weighted-vs-unweighted","title":"Graph Theory: Directed vs. Undirected, Weighted vs. Unweighted","text":"<p>## 1. Introduction</p> <p>Graph theory is a fundamental branch of mathematics with widespread applications in computer science, networking, operations research, and numerous other fields.  At its core, a graph is a structure representing relationships between objects. These objects are represented as nodes (or vertices), and the relationships between them are represented as edges.  This study note will focus on two crucial characteristics of graphs: their directionality (directed vs. undirected) and whether they have associated weights (weighted vs. unweighted). Understanding these distinctions is critical for selecting the appropriate graph model and algorithms for a given problem.</p> <p>## 2. Core Concepts</p> <p>2.1 Directed vs. Undirected Graphs:</p> <ul> <li> <p>Undirected Graph: In an undirected graph, edges represent bidirectional relationships.  If there's an edge between node A and node B, it implies a connection in both directions (A to B and B to A).  Edges are typically represented as unordered pairs {A, B}.  Think of a social network where friendship is mutual \u2013 if A is friends with B, B is also friends with A.</p> </li> <li> <p>Directed Graph (Digraph): In a directed graph, edges represent unidirectional relationships. An edge from node A to node B indicates a connection only from A to B, not necessarily the other way around. Edges are represented as ordered pairs (A, B).  Think of a one-way street network, where traveling from A to B doesn't guarantee you can travel from B to A.  A directed graph can contain cycles (a path that starts and ends at the same node)</p> </li> </ul> <p>2.2 Weighted vs. Unweighted Graphs:</p> <ul> <li> <p>Unweighted Graph:  In an unweighted graph, edges simply represent the existence of a connection between two nodes; there's no quantitative measure associated with the relationship.  Think of a simple friendship network where the strength of the friendship isn't considered.</p> </li> <li> <p>Weighted Graph: In a weighted graph, each edge is assigned a numerical weight, representing the cost, distance, strength, or any other relevant quantitative measure of the relationship. This weight can represent distance between cities, capacity of a communication link, or the cost of travel between two locations.  Shortest path algorithms (like Dijkstra's algorithm) are crucial for analyzing weighted graphs.</p> </li> </ul> <p>2.3 Combinations:</p> <p>It's crucial to note that these properties are independent.  We can have:</p> <ul> <li>Unweighted, Undirected Graphs:  Simple graphs representing relationships without direction or quantitative measure.</li> <li>Weighted, Undirected Graphs: Graphs representing relationships without direction but with associated costs or distances.</li> <li>Unweighted, Directed Graphs: Graphs representing directional relationships without quantitative measures.</li> <li>Weighted, Directed Graphs: Graphs representing directional relationships with associated costs or distances.  This is a very common model for representing real-world networks like road networks with one-way streets.</li> </ul> <p>## 3. Practical Examples</p> <ul> <li>Unweighted, Undirected Graph: Representing a social network where friendship is mutual. Nodes are individuals, and edges represent friendships.</li> <li>Weighted, Undirected Graph: Representing a road network where nodes are cities and edges represent roads with associated distances or travel times.  Finding the shortest route between two cities involves finding the shortest path in this graph.</li> <li>Unweighted, Directed Graph: Representing a website's link structure where nodes are web pages and directed edges represent hyperlinks.  Analyzing the flow of traffic across the website might require examining paths in this digraph.</li> <li>Weighted, Directed Graph: Representing a flight network where nodes are airports and directed edges represent flights with associated costs and durations. Finding the cheapest flight route between two cities involves finding the shortest weighted path in this directed graph.</li> </ul> <p>## 4. Conclusion</p> <p>The choice between directed/undirected and weighted/unweighted graphs depends entirely on the nature of the problem being modeled.  A careful consideration of the relationships between objects and the relevant quantitative measures is crucial for selecting the most appropriate graph representation. This will, in turn, determine the types of algorithms that can be effectively applied to analyze the graph and extract meaningful insights. Understanding these fundamental distinctions is a cornerstone of successful graph theory application in various fields.</p>"},{"location":"notes/dsa/Z-Algorithm/","title":"Z Algorithm","text":""},{"location":"notes/dsa/Z-Algorithm/#z-algorithm-a-deep-dive","title":"Z-Algorithm: A Deep Dive","text":"<p>1. Introduction</p> <p>The Z-algorithm is a linear-time stringology algorithm used to preprocess a string <code>S</code> of length <code>n</code> to efficiently find all occurrences of substrings of <code>S</code> that are also prefixes of <code>S</code>.  It achieves this by computing a Z-array, <code>Z[i]</code>, where <code>Z[i]</code> represents the length of the longest substring starting at index <code>i</code> that is also a prefix of <code>S</code>.  In simpler terms, <code>Z[i]</code> tells us how far the substring starting at index <code>i</code> matches the beginning of the string. This pre-computation allows for incredibly fast pattern searching within the string <code>S</code>.  Unlike naive string matching algorithms which have a time complexity of O(mn) (where 'm' is the length of the pattern and 'n' is the length of the text), the Z-algorithm boasts a linear time complexity of O(n), making it significantly more efficient for large strings.  This efficiency makes it a valuable tool in various string processing tasks, including pattern matching, finding repetitions, and solving problems related to string manipulations.</p> <p>2. Core Concepts</p> <p>The Z-algorithm's core lies in the computation of the Z-array.  The algorithm cleverly avoids redundant comparisons by leveraging information obtained from previously computed Z-values.  Here's a breakdown of the key concepts:</p> <ul> <li> <p>Z-array: As mentioned, this is the heart of the algorithm.  <code>Z[i]</code> stores the length of the longest substring starting at index <code>i</code> that is also a prefix of <code>S</code>.  <code>Z[0]</code> is always defined as 0.</p> </li> <li> <p>Right boundary (r) and left boundary (l): During the algorithm's execution, <code>r</code> denotes the rightmost index of the currently identified longest substring that is also a prefix.  <code>l</code> denotes the leftmost index of this substring.  The interval <code>[l, r]</code> represents the region for which Z values are already calculated.</p> </li> <li> <p>Z-box: The region <code>[l, r]</code> forms a \"Z-box\".  Any substring within this box whose starting index is <code>k</code> such that <code>l \u2264 k \u2264 r</code> can benefit from the previously computed Z values.</p> </li> <li> <p>Algorithm Steps: The algorithm iterates through the string. For each index <code>i</code>:</p> <ul> <li> <p>Inside the Z-box (l \u2264 i \u2264 r): If <code>i</code> is within the Z-box, we can calculate <code>Z[i]</code> by leveraging the Z-value of the mirrored index <code>k = i - l</code>.  Specifically, <code>Z[i] = min(r - i + 1, Z[k])</code>.  This avoids unnecessary comparisons.</p> </li> <li> <p>Outside the Z-box (i &gt; r): If <code>i</code> is outside the Z-box, we need to perform naive comparisons from <code>S[i]</code> onwards to determine <code>Z[i]</code>.  If a new <code>r</code> is found (meaning a longer matching prefix), the <code>l</code> and <code>r</code> boundaries are updated.</p> </li> </ul> </li> <li> <p>Linearity: The clever utilization of the Z-box and leveraging previously computed Z-values ensures that each index <code>i</code> is processed at most once, leading to the algorithm's linear time complexity.</p> </li> </ul> <p>3. Practical Examples</p> <p>Let's illustrate the Z-algorithm with two examples:</p> <p>Example 1:</p> <p>String S = \"aabcaabxaaaz\"</p> i S[i] Z[i] Explanation 0 a 0 Z[0] is always 0 1 a 1 \"aa\" matches the prefix 2 b 0 No match 3 c 0 No match 4 a 1 \"a\" matches the prefix 5 a 4 \"aabxaa\" matches the prefix (r and l update) 6 b 0 No match 7 x 0 No match 8 a 1 \"a\" matches the prefix 9 a 1 \"aa\" matches the prefix 10 z 0 No match <p>Example 2 (Pattern Searching):</p> <p>To find occurrences of pattern \"aab\" in string S = \"baabcaabxaaaz\":</p> <ol> <li>Concatenate the pattern and the string with a special character (e.g., '$'):  \"aab$baabcaabxaaaz\"</li> <li>Apply the Z-algorithm to this concatenated string.</li> <li>Look for Z-values equal to the length of the pattern (3 in this case).  The indices where <code>Z[i] == 3</code> indicate the starting positions of the pattern in the original string.</li> </ol> <p>4. Conclusion</p> <p>The Z-algorithm is a powerful and efficient algorithm for string processing, offering linear-time complexity for finding all occurrences of prefixes within a string. Its elegant use of previously computed information significantly reduces computation, making it superior to naive approaches for large-scale string analysis.  Understanding its core concepts \u2013 the Z-array, the Z-box, and the interplay between <code>l</code> and <code>r</code> \u2013 is crucial to grasping its efficiency and practical application in diverse string-related problems.  Its applications extend beyond simple pattern matching to more complex scenarios involving string manipulation and analysis, making it a valuable tool in any programmer's or computational biologist's arsenal.</p>"},{"location":"notes/java/Annotations_and_Reflection/","title":"Annotations and Reflection","text":""},{"location":"notes/java/Annotations_and_Reflection/#annotations-and-reflection-premium-study-notes","title":"Annotations and Reflection: Premium Study Notes","text":"<p>## 1. Introduction</p> <p>Annotations and reflection are crucial metacognitive strategies for enhancing learning and understanding.  Unlike passive reading or listening, these active learning techniques demand engagement with the material, fostering deeper processing and retention.  Annotations involve marking up a text with notes, highlighting key ideas, and adding personal interpretations. Reflection, on the other hand, goes beyond simple annotation; it's a deliberate process of examining your understanding, identifying gaps in knowledge, and connecting new information to existing frameworks.  Combining annotations and reflection creates a powerful cycle of learning, leading to improved comprehension, critical thinking skills, and long-term memory consolidation. This study guide explores these processes in detail, providing practical strategies and examples.</p> <p>## 2. Core Concepts</p> <p>A. Annotation Techniques:</p> <ul> <li> <p>Highlighting:  Emphasize key concepts, arguments, and supporting evidence.  Avoid over-highlighting \u2013 focus on the most crucial information.  Use different colors for different categories (e.g., main ideas, supporting details, questions).</p> </li> <li> <p>Underlining:  Similar to highlighting, but can be used for specific words or phrases within a sentence.</p> </li> <li> <p>Marginal Notes:  Add concise summaries, definitions, connections to other ideas, questions, or personal reactions in the margins.</p> </li> <li> <p>Symbols:  Develop a system of symbols (e.g., *, !, ?) to quickly identify key points, important insights, or areas needing clarification.</p> </li> <li> <p>Summarizing:  Write brief summaries at the end of sections or chapters to synthesize the main points.</p> </li> <li> <p>Quoting:  Record significant passages that resonate with you or provide valuable insights.  Always cite the source.</p> </li> </ul> <p>B. Reflection Strategies:</p> <ul> <li> <p>Self-Questioning:  Actively ask yourself questions about the material: What is the main idea? What are the supporting arguments?  What are the limitations?  How does this relate to what I already know?</p> </li> <li> <p>Concept Mapping:  Visually represent relationships between concepts using diagrams or mind maps.</p> </li> <li> <p>Journaling:  Record your thoughts, feelings, and insights about the material in a journal.  Reflect on your learning process, identify challenges, and plan future learning strategies.</p> </li> <li> <p>Connecting to Prior Knowledge:  Actively link new information to your existing knowledge base.  This strengthens understanding and facilitates long-term retention.</p> </li> <li> <p>Identifying Gaps in Understanding:  Recognize areas where you need further clarification or exploration.  Develop strategies to address these gaps.</p> </li> <li> <p>Evaluating Sources:  Critically assess the credibility and bias of the source material.</p> </li> </ul> <p>C. The Synergistic Relationship: Annotations provide the raw material for reflection.  By actively engaging with the text through annotation, you generate the data necessary for meaningful reflection.  Reflection, in turn, deepens your understanding of the annotated material and guides future annotation strategies.</p> <p>## 3. Practical Examples</p> <p>Scenario: Reading a chapter on the causes of the American Civil War.</p> <p>Annotation Example:</p> <ul> <li> <p>Highlighting: Key terms like \"slavery,\" \"states' rights,\" \"sectionalism\" are highlighted in yellow.  Important dates are highlighted in green.</p> </li> <li> <p>Marginal Notes:  Next to a passage discussing the economic differences between the North and South, a note: \"Significant economic disparity fueled political tensions.\"  Next to a discussion of Lincoln's election: \"Catalyst for secession.\"</p> </li> <li> <p>Symbols:  A * next to particularly impactful quotes.  A ? next to arguments that seem unclear or require further research.</p> </li> </ul> <p>Reflection Example:</p> <ul> <li> <p>Journal Entry: \"The chapter highlighted the complex interplay of economic, social, and political factors leading to the Civil War.  I found the discussion of states' rights particularly insightful, but I need to do more research on the different interpretations of this concept.  I also want to explore the role of abolitionist movements in shaping the political landscape.\"</p> </li> <li> <p>Concept Map: A mind map with \"Causes of the American Civil War\" in the center, branching out to \"Economic Differences,\" \"Social Tensions,\" \"Political Factors,\" and \"Abolitionist Movement,\" with sub-branches detailing specific events and figures.</p> </li> </ul> <p>## 4. Conclusion</p> <p>Effective annotation and reflection are essential for transforming passive reading into active learning. By combining these strategies, learners move beyond surface-level comprehension to deeper understanding, critical analysis, and meaningful retention.  Consistent practice with annotation and reflection will cultivate essential skills in critical thinking, research, and self-regulated learning, ultimately leading to improved academic performance and lifelong learning.  The key is to develop a personalized system that works best for your learning style and the specific material you are studying.  Experiment with different techniques and refine your approach over time to maximize the benefits of this powerful learning strategy.</p>"},{"location":"notes/java/Basics_Variables_Data_Types_Operators_Control_Flow/","title":"Basics Variables Data Types Operators Control Flow","text":""},{"location":"notes/java/Basics_Variables_Data_Types_Operators_Control_Flow/#programming-fundamentals-variables-data-types-operators-and-control-flow","title":"Programming Fundamentals: Variables, Data Types, Operators, and Control Flow","text":"<p>## 1. Introduction</p> <p>This document provides a comprehensive overview of fundamental programming concepts: variables, data types, operators, and control flow.  Mastering these building blocks is crucial for any aspiring programmer, regardless of the specific language they choose to learn.  These concepts form the basis for all more advanced programming techniques and are applicable across virtually all programming paradigms.  We'll explore these concepts with a focus on clarity and practical application, aiming to provide a solid foundation for further learning.</p> <p>## 2. Core Concepts</p> <p>2.1 Variables:</p> <p>Variables are named storage locations in a computer's memory that hold data. They act as containers for information that your program needs to manipulate.  Think of them as labeled boxes where you can store different things.  Each variable has a name (identifier), a data type (specifying the kind of data it can hold), and a value (the data stored within).</p> <ul> <li> <p>Naming Conventions: Variable names should be descriptive and follow the language's specific rules (e.g., starting with a letter or underscore, using only alphanumeric characters and underscores).  Good naming practices enhance code readability.  Example: <code>userName</code>, <code>totalScore</code>, <code>productPrice</code>.</p> </li> <li> <p>Declaration and Initialization:  Most programming languages require you to declare a variable before using it. This involves specifying its name and data type. Initialization assigns an initial value to the variable.</p> </li> </ul> <p><code>python    userName = \"Alice\"  # Declaration and initialization in Python    int age = 30;      // Declaration and initialization in C++ (type explicitly stated)</code></p> <p>2.2 Data Types:</p> <p>Data types classify the kind of data a variable can hold.  Common data types include:</p> <ul> <li>Integer (int): Whole numbers (e.g., -2, 0, 10, 1000).</li> <li>Floating-Point (float): Numbers with decimal points (e.g., 3.14, -2.5, 0.0).</li> <li>Boolean (bool): Represents truth values (true or false).</li> <li>Character (char): Single characters (e.g., 'A', 'b', '$').</li> <li>String (str): Sequences of characters (e.g., \"Hello, world!\", \"Programming\").</li> </ul> <p>The choice of data type is important because it dictates the operations you can perform on the data and how much memory it consumes.</p> <p>2.3 Operators:</p> <p>Operators perform actions on variables and values.  They are categorized as:</p> <ul> <li> <p>Arithmetic Operators: <code>+</code> (addition), <code>-</code> (subtraction), <code>*</code> (multiplication), <code>/</code> (division), <code>%</code> (modulo \u2013 remainder after division), <code>**</code> (exponentiation).</p> </li> <li> <p>Relational Operators: Compare values and return a boolean result (true or false). <code>==</code> (equal to), <code>!=</code> (not equal to), <code>&gt;</code> (greater than), <code>&lt;</code> (less than), <code>&gt;=</code> (greater than or equal to), <code>&lt;=</code> (less than or equal to).</p> </li> <li> <p>Logical Operators: Combine or modify boolean expressions. <code>&amp;&amp;</code> or <code>and</code> (logical AND), <code>||</code> or <code>or</code> (logical OR), <code>!</code> or <code>not</code> (logical NOT).</p> </li> <li> <p>Assignment Operators: Assign values to variables. <code>=</code> (assignment), <code>+=</code>, <code>-=</code>, <code>*=</code> etc. (compound assignment).</p> </li> </ul> <p>2.4 Control Flow:</p> <p>Control flow statements determine the order in which instructions are executed.  They allow programs to make decisions and repeat actions based on conditions.  Key control flow statements include:</p> <ul> <li>Conditional Statements (if-else): Execute different blocks of code based on whether a condition is true or false.</li> </ul> <p><code>python    if age &gt;= 18:        print(\"You are an adult.\")    else:        print(\"You are a minor.\")</code></p> <ul> <li>Loops (for, while): Repeat a block of code multiple times.  <code>for</code> loops are typically used when you know the number of iterations in advance; <code>while</code> loops continue as long as a condition is true.</li> </ul> <p>```python    for i in range(5):  # Python 'for' loop        print(i)</p> <p>count = 0    while count &lt; 5:  # Python 'while' loop        print(count)        count += 1    ```</p> <ul> <li>Switch Statements (or similar constructs):  (Available in some languages)  Efficiently handle multiple conditional branches based on the value of a single expression.</li> </ul> <p>## 3. Practical Examples</p> <p>Example 1: Calculating the area of a rectangle:</p> <pre><code>length = 10\nwidth = 5\narea = length * width\nprint(\"The area of the rectangle is:\", area)\n</code></pre> <p>Example 2: Checking if a number is even or odd:</p> <pre><code>number = 15\nif number % 2 == 0:\n    print(\"The number is even.\")\nelse:\n    print(\"The number is odd.\")\n</code></pre> <p>Example 3:  Printing numbers from 1 to 10 using a loop:</p> <pre><code>for i in range(1, 11):  #Starts from 1, goes up to (but not including) 11.\n    print(i)\n</code></pre> <p>## 4. Conclusion</p> <p>Understanding variables, data types, operators, and control flow is fundamental to programming.  These concepts provide the building blocks for constructing more complex programs and algorithms.  Practicing with these elements through various examples and exercises will solidify your understanding and pave the way for exploring more advanced programming topics. Remember to always strive for clean, readable, and efficient code.  By mastering these fundamentals, you'll build a strong foundation for a successful programming journey.</p>"},{"location":"notes/java/Build_Tools_Maven_Gradle/","title":"Build Tools Maven Gradle","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/java/Classes_and_Objects/","title":"Classes and Objects","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/java/Constructors/","title":"Constructors","text":""},{"location":"notes/java/Constructors/#constructors-study-notes","title":"Constructors: Study Notes","text":"<p>1. Introduction</p> <p>Constructors are special methods within a class that are automatically called when an object of that class is created (instantiated).  They are responsible for initializing the object's attributes (member variables) to a valid state.  Think of them as the setup routine for your objects.  Without constructors, your objects might start in an unpredictable or invalid state, leading to errors in your program.  Understanding constructors is fundamental to object-oriented programming because they ensure that objects are properly initialized before they are used.  This eliminates the risk of accessing uninitialized data and improves the robustness of your code.</p> <p>2. Core Concepts</p> <ul> <li>Purpose: To initialize the attributes (fields, member variables) of an object upon its creation.</li> <li>Name:  Constructors always have the same name as the class.</li> <li>Return Type: Constructors have no return type (not even <code>void</code>).</li> <li>Types of Constructors:<ul> <li>Default Constructor: A constructor with no arguments.  The compiler automatically provides a default constructor if you don't define any constructors in your class. This default constructor typically initializes member variables to their default values (e.g., 0 for numbers, null for objects, false for booleans).</li> <li>Parameterized Constructor: A constructor that accepts arguments, allowing you to initialize member variables with specific values during object creation. This is crucial for creating objects in a variety of states.</li> <li>Copy Constructor: A constructor that creates a new object as a copy of an existing object.  It takes an object of the same class as an argument.  Important for deep vs. shallow copying considerations (avoiding unintended side effects when modifying copies).</li> <li>Move Constructor (C++):  A constructor that takes an rvalue reference as an argument, allowing efficient transfer of resources from a temporary object to a new object, avoiding unnecessary copying.  (Specific to C++).</li> </ul> </li> <li>Constructor Overloading: You can define multiple constructors in a class, each with a different set of parameters. This allows you to create objects in various ways, based on the provided initialization data.  The compiler selects the appropriate constructor based on the arguments used during object creation.</li> <li>Initialization Lists: (Especially relevant in C++):  A more efficient way to initialize member variables, particularly for classes with member objects that require constructors themselves.  Initialization lists are placed after the constructor's parameter list and before the constructor's body, using the syntax <code>: memberVariable(value), anotherMember(anotherValue) { ... }</code>.  This avoids the default constructor being called for the member variable and then overridden in the body.</li> </ul> <p>3. Practical Examples</p> <p>Example 1 (Java):</p> <pre><code>public class Dog {\n    String name;\n    String breed;\n    int age;\n\n    // Default constructor\n    public Dog() {\n        name = \"Unknown\";\n        breed = \"Unknown\";\n        age = 0;\n    }\n\n    // Parameterized constructor\n    public Dog(String name, String breed, int age) {\n        this.name = name;\n        this.breed = breed;\n        this.age = age;\n    }\n\n    public static void main(String[] args) {\n        Dog dog1 = new Dog(); // Uses default constructor\n        Dog dog2 = new Dog(\"Buddy\", \"Golden Retriever\", 3); // Uses parameterized constructor\n        System.out.println(dog1.name); // Output: Unknown\n        System.out.println(dog2.name); // Output: Buddy\n    }\n}\n</code></pre> <p>Example 2 (C++):</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Dog {\npublic:\n  std::string name;\n  std::string breed;\n  int age;\n\n  // Default constructor\n  Dog() : name(\"Unknown\"), breed(\"Unknown\"), age(0) {}\n\n  // Parameterized constructor using initializer list\n  Dog(std::string name, std::string breed, int age) : name(name), breed(breed), age(age) {}\n\n  // Copy constructor (demonstrates deep copy)\n  Dog(const Dog&amp; other) : name(other.name), breed(other.breed), age(other.age) {}\n\n  ~Dog(){}; // Destructor for good practice in C++\n\n};\n\nint main() {\n  Dog dog1;\n  Dog dog2(\"Buddy\", \"Golden Retriever\", 3);\n  Dog dog3 = dog2; //Uses copy constructor\n\n  std::cout &lt;&lt; dog1.name &lt;&lt; std::endl; // Output: Unknown\n  std::cout &lt;&lt; dog2.name &lt;&lt; std::endl; // Output: Buddy\n  std::cout &lt;&lt; dog3.name &lt;&lt; std::endl; // Output: Buddy\n  return 0;\n}\n</code></pre> <p>4. Conclusion</p> <p>Constructors are essential tools in object-oriented programming.  They guarantee that objects are initialized correctly before use, preventing errors and improving code reliability.  Mastering different types of constructors, including default, parameterized, copy, and (in C++) move constructors, and understanding initialization lists enhances your ability to create robust and flexible classes.  Choosing the appropriate constructor based on your needs is crucial for writing efficient and maintainable code. Remember to consider the implications of shallow vs. deep copying when implementing copy constructors to avoid unintended side effects.</p>"},{"location":"notes/java/Date_and_Time_API/","title":"Date and Time API","text":"<p>\u26a0\ufe0f Error generating content: 404 Publisher Model <code>projects/generativelanguage-ga/locations/us-central1/publishers/google/models/gemini-1.5-flash-002</code> was not found or your project does not have access to it. Please ensure you are using a valid model version. For more information, see: https://cloud.google.com/vertex-ai/generative-ai/docs/learn/model-versions</p>"},{"location":"notes/java/Exception_Handling_try-catch-finally_checked_vs_un/","title":"Exception Handling try catch finally checked vs un","text":""},{"location":"notes/java/Exception_Handling_try-catch-finally_checked_vs_un/#exception-handling-try-catch-finally-and-checked-vs-unchecked-exceptions","title":"Exception Handling: Try-Catch-Finally and Checked vs. Unchecked Exceptions","text":"<p>## 1. Introduction</p> <p>Exception handling is a crucial mechanism in programming that allows us to gracefully manage errors and unexpected events during program execution.  Without it, even minor issues like a file not being found could lead to a program crash.  Exception handling promotes robust and reliable software by providing a structured way to deal with exceptional situations without halting the entire application.  This involves anticipating potential problems, detecting them at runtime, and responding appropriately to prevent program failure.  This document will explore the fundamental concepts of exception handling, focusing on the <code>try-catch-finally</code> block structure and the distinction between checked and unchecked exceptions.</p> <p>## 2. Core Concepts</p> <p>2.1 The <code>try-catch-finally</code> Block:</p> <p>This is the core structure for handling exceptions in many programming languages (including Java, C++, C#, Python etc., although syntax may differ slightly).</p> <ul> <li> <p><code>try</code> block: This encloses the code that might throw an exception.  If an exception occurs within the <code>try</code> block, the program's execution immediately jumps to the appropriate <code>catch</code> block.</p> </li> <li> <p><code>catch</code> block: This handles the exception. It specifies the type of exception it can handle (e.g., <code>IOException</code>, <code>ArithmeticException</code>).  Multiple <code>catch</code> blocks can be used to handle different exception types.  The code within a <code>catch</code> block should attempt to recover from the error or at least log it appropriately.</p> </li> <li> <p><code>finally</code> block (optional): This block always executes, regardless of whether an exception occurred or not.  It's typically used for cleanup tasks like closing files, releasing resources (database connections, network sockets), etc., ensuring that these actions are performed even if an error occurs.</p> </li> </ul> <p>Example (Java):</p> <pre><code>try {\n    // Code that might throw an exception\n    int result = 10 / 0; \n} catch (ArithmeticException e) {\n    System.err.println(\"Error: Division by zero! \" + e.getMessage());\n} finally {\n    System.out.println(\"This always executes.\");\n}\n</code></pre> <p>2.2 Checked vs. Unchecked Exceptions:</p> <p>The classification of exceptions into checked and unchecked categories influences how the compiler and programmer interact with exception handling.</p> <ul> <li> <p>Checked Exceptions: These are exceptions that the compiler forces you to handle.  If a method might throw a checked exception, you must either handle it using a <code>try-catch</code> block within the method or declare that the method itself throws the exception using a <code>throws</code> clause in the method signature.  This helps prevent common errors by ensuring that programmers think about potential problems during development.  Examples include <code>IOException</code>, <code>SQLException</code>.</p> </li> <li> <p>Unchecked Exceptions: These are exceptions that the compiler does not force you to handle.  They typically indicate programming errors (e.g., <code>NullPointerException</code>, <code>ArrayIndexOutOfBoundsException</code>, <code>IllegalArgumentException</code>).  While you should strive to handle them (for robustness), the compiler won't explicitly require it.</p> </li> </ul> <p>Example (Java - illustrating checked exception):</p> <pre><code>import java.io.FileReader;\nimport java.io.IOException;\n\npublic class CheckedExceptionExample {\n    public void readFile(String filename) throws IOException { // Declaring that the method throws IOException\n        FileReader reader = new FileReader(filename);\n        // ... code to read from the file ...\n        reader.close(); // Crucial cleanup in finally block or explicitly in try-catch structure\n    }\n}\n</code></pre> <p>## 3. Practical Examples</p> <p>3.1 File I/O:</p> <p>When working with files, exceptions like <code>FileNotFoundException</code> (checked) can occur.  Proper exception handling ensures that the program doesn't crash if the file isn't found, instead handling the situation gracefully (e.g., displaying an error message, using a default file).</p> <p>3.2 Network Communication:</p> <p>Network operations can fail due to various reasons (connection refused, timeouts).  Exceptions like <code>SocketException</code> or <code>IOException</code> (often checked) need to be handled to prevent the application from halting unexpectedly.</p> <p>3.3 User Input:</p> <p>When processing user input, exceptions like <code>NumberFormatException</code> (unchecked) can occur if the user enters non-numeric data where a number is expected.  Appropriate error handling can prompt the user for correct input or provide helpful feedback.</p> <p>3.4 Database Interactions:</p> <p>Database operations can throw exceptions (e.g., <code>SQLException</code>, often checked) if the database is unavailable, a query fails, or data integrity issues arise.  Robust error handling is vital for ensuring the reliability of database-driven applications.</p> <p>## 4. Conclusion</p> <p>Exception handling is paramount for creating robust and reliable software.  Understanding the <code>try-catch-finally</code> structure and the difference between checked and unchecked exceptions is key to effectively managing errors.  Properly handling exceptions improves the user experience by preventing unexpected crashes and provides informative error messages.  While unchecked exceptions often signal programming flaws, comprehensive error handling ensures that even these issues are managed safely, leading to more stable and user-friendly applications.  Remember that good exception handling involves not just catching exceptions, but also logging them appropriately and recovering gracefully or taking appropriate action based on the type of exception encountered.</p>"},{"location":"notes/java/File_I_O_and_NIO/","title":"File I O and NIO","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/java/Generics/","title":"Generics","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/java/Interfaces_and_Abstract_Classes/","title":"Interfaces and Abstract Classes","text":""},{"location":"notes/java/Interfaces_and_Abstract_Classes/#interfaces-and-abstract-classes-a-comparative-study","title":"Interfaces and Abstract Classes: A Comparative Study","text":"<p>1. Introduction</p> <p>Interfaces and abstract classes are fundamental concepts in object-oriented programming (OOP) that promote code reusability, flexibility, and maintainability.  They both define a blueprint for classes, specifying methods that derived classes must implement. However, they differ significantly in their capabilities and how they're used. Understanding these differences is crucial for designing robust and scalable software.  This document explores the core concepts of interfaces and abstract classes, highlighting their similarities and distinctions through practical examples.</p> <p>2. Core Concepts</p> <p>2.1 Abstract Classes:</p> <ul> <li>Definition: An abstract class is a class that cannot be instantiated directly. It serves as a template for other classes (subclasses) to inherit from.  It can contain both abstract methods (methods without implementation) and concrete methods (methods with implementation).</li> <li>Key Features:<ul> <li>Can have both abstract and concrete methods.</li> <li>Can have instance variables.</li> <li>Can have constructors (used for initialization of instance variables).</li> <li>Supports inheritance through the <code>extends</code> keyword (in Java, C# etc.).</li> <li>Enforces a partial implementation, providing a base for subclasses to build upon.</li> </ul> </li> <li>Use Cases:<ul> <li>Defining a common base for a group of related classes, providing default implementations for some methods.</li> <li>Enforcing a specific structure and behavior among subclasses.</li> <li>Implementing the Template Method pattern (defining a skeleton algorithm in the abstract class and letting subclasses provide specific implementations).</li> </ul> </li> </ul> <p>2.2 Interfaces:</p> <ul> <li>Definition: An interface is a contract that defines a set of methods that a class must implement. Unlike abstract classes, interfaces cannot contain concrete methods (with some exceptions in languages like Java 8 and later).  They solely specify the signature of methods.</li> <li>Key Features:<ul> <li>Contains only abstract methods (implicitly in many languages; explicit declaration may be required in some).</li> <li>Cannot have instance variables (except for <code>static final</code> constants in Java).</li> <li>Cannot have constructors.</li> <li>Supports multiple inheritance (a class can implement multiple interfaces).  This is a key advantage over abstract classes which usually support only single inheritance.</li> <li>Enforces complete abstraction, focusing on what should be done rather than how it should be done.</li> </ul> </li> <li>Use Cases:<ul> <li>Defining a common set of methods for unrelated classes (achieving polymorphism).</li> <li>Supporting multiple inheritance.</li> <li>Achieving loose coupling between classes.</li> <li>Implementing the Strategy pattern (providing different algorithms interchangeable through a common interface).</li> </ul> </li> </ul> <p>2.3 Similarities and Differences Summarized:</p> Feature Abstract Class Interface Instantiation Cannot be instantiated Cannot be instantiated Methods Can have abstract and concrete methods Contains only abstract methods (typically) Variables Can have instance variables Can only have <code>static final</code> constants (typically) Constructors Can have constructors Cannot have constructors Inheritance Single inheritance (usually) Multiple inheritance Implementation Partial implementation Complete abstraction <p>3. Practical Examples (Java)</p> <p>3.1 Abstract Class:</p> <pre><code>abstract class Animal {\n    String name;\n\n    Animal(String name) { this.name = name; }\n\n    abstract void makeSound(); // Abstract method\n\n    void eat() { // Concrete method\n        System.out.println(name + \" is eating.\");\n    }\n}\n\nclass Dog extends Animal {\n    Dog(String name) { super(name); }\n\n    @Override\n    void makeSound() {\n        System.out.println(\"Woof!\");\n    }\n}\n\nclass Cat extends Animal {\n    Cat(String name) { super(name); }\n\n    @Override\n    void makeSound() {\n        System.out.println(\"Meow!\");\n    }\n}\n</code></pre> <p>3.2 Interface:</p> <pre><code>interface Drawable {\n    void draw(); // Abstract method\n}\n\nclass Circle implements Drawable {\n    @Override\n    public void draw() {\n        System.out.println(\"Drawing a circle.\");\n    }\n}\n\nclass Square implements Drawable {\n    @Override\n    public void draw() {\n        System.out.println(\"Drawing a square.\");\n    }\n}\n</code></pre> <p>4. Conclusion</p> <p>Abstract classes and interfaces are powerful tools for designing flexible and maintainable object-oriented systems. The choice between them depends on the specific requirements of your design.  Abstract classes are suitable when you need to provide a partial implementation and enforce a common structure among related classes. Interfaces are better suited for defining contracts for unrelated classes, achieving polymorphism, and supporting multiple inheritance.  Often, a combination of both is employed to leverage the strengths of each.  Careful consideration of the differences outlined above will lead to more robust and elegant software designs.</p>"},{"location":"notes/java/Introduction_to_JVM_Internals/","title":"Introduction to JVM Internals","text":"<p>\u26a0\ufe0f Error generating content: 404 Publisher Model <code>projects/generativelanguage-ga/locations/us-central1/publishers/google/models/gemini-1.5-flash-002</code> was not found or your project does not have access to it. Please ensure you are using a valid model version. For more information, see: https://cloud.google.com/vertex-ai/generative-ai/docs/learn/model-versions</p>"},{"location":"notes/java/Introduction_to_the_Collections_Framework/","title":"Introduction to the Collections Framework","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/java/Iterators_and_For-Each_Loop/","title":"Iterators and For Each Loop","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/java/JDBC_for_database_connectivity/","title":"JDBC for database connectivity","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/java/Java_8_Features_Lambda_Expressions_Streams_API_Opt/","title":"Java 8 Features Lambda Expressions Streams API Opt","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/java/Java_Memory_Model/","title":"Java Memory Model","text":""},{"location":"notes/java/Java_Memory_Model/#java-memory-model-jmm-premium-study-notes","title":"Java Memory Model (JMM): Premium Study Notes","text":"<p>1. Introduction</p> <p>The Java Memory Model (JMM) defines how threads interact through shared memory.  Unlike a simple shared memory model where all threads see the same memory state instantaneously, JMM introduces constraints and guarantees that dictate how threads observe changes made by other threads. This is crucial for writing correct and efficient multithreaded Java applications, preventing race conditions and ensuring data consistency.  The JMM is a crucial component of Java's platform and significantly impacts concurrency. It doesn't dictate where memory resides (e.g., on-chip cache, main memory), but rather how changes in one thread are visible to another.  Understanding the JMM is essential for building robust and scalable concurrent applications.  Failure to understand it can lead to subtle, hard-to-debug concurrency bugs.</p> <p>2. Core Concepts</p> <p>Several key concepts underpin the JMM:</p> <ul> <li> <p>Threads and Shared Memory: Java programs use threads to perform tasks concurrently. These threads often share access to the same memory locations (heap memory, static variables).  Changes made by one thread in shared memory must be visible to other threads in a predictable way.</p> </li> <li> <p>Happens-Before Relationship: This is the cornerstone of the JMM.  It defines a partial ordering of operations within a program.  If action A \"happens-before\" action B, it guarantees that the effects of A are visible to B.  This ordering isn't necessarily chronological; it's a logical ordering defined by specific rules:</p> <ul> <li>Program Order:  Within a single thread, operations are ordered as they appear in the code.</li> <li>Monitor Lock: An unlock operation on a monitor happens-before any subsequent lock operation on that same monitor by another thread.  This ensures atomicity within synchronized blocks.</li> <li>Volatile Variables: A write to a volatile variable happens-before any subsequent read of that volatile variable by another thread.</li> <li>Thread Start:  The <code>Thread.start()</code> method happens-before any action in the newly started thread.</li> <li>Thread Join:  The <code>Thread.join()</code> method completes only after all actions in the joined thread have completed.</li> <li>Transitivity: If A happens-before B, and B happens-before C, then A happens-before C.</li> </ul> </li> <li> <p>Memory Barriers/Fences:  These are instructions inserted by the JVM to enforce ordering constraints defined by the happens-before relationship.  They prevent compiler and processor optimizations that could reorder memory accesses, leading to unexpected behavior.  Different architectures implement these differently, but the JMM abstracts away those details.</p> </li> <li> <p>Atomicity:  An operation is atomic if it's indivisible; it either completes entirely or not at all.  Many operations in Java are not inherently atomic (e.g., incrementing an integer).  <code>volatile</code> and <code>synchronized</code> keywords can help achieve atomicity.</p> </li> <li> <p>Visibility:  This refers to when changes made by one thread become visible to other threads.  The happens-before relationship ensures visibility, but improper synchronization can lead to invisibility.</p> </li> <li> <p>Ordering:  The JMM ensures a certain level of ordering of memory operations, although it doesn't guarantee strict total order.  The happens-before relationship dictates partial order, leaving room for reordering within the constraints.</p> </li> </ul> <p>3. Practical Examples</p> <ul> <li>Race Condition (without synchronization):</li> </ul> <pre><code>class Counter {\n    int count = 0;\n\n    public void increment() {\n        count++; // Not atomic!\n    }\n}\n</code></pre> <p>Multiple threads calling <code>increment()</code> concurrently can lead to incorrect results because the increment operation (read, add, write) isn't atomic.</p> <ul> <li>Using <code>volatile</code>:</li> </ul> <pre><code>class Counter {\n    volatile int count = 0; // Ensures visibility\n\n    public void increment() {\n        count++; // Still not atomic, but visibility is improved\n    }\n}\n</code></pre> <p><code>volatile</code> ensures that changes to <code>count</code> are immediately visible to other threads, mitigating some visibility issues but not the atomicity problem.  A better solution would use <code>AtomicInteger</code>.</p> <ul> <li>Using <code>synchronized</code>:</li> </ul> <pre><code>class Counter {\n    int count = 0;\n\n    public synchronized void increment() { // Atomic operation within the block\n        count++;\n    }\n}\n</code></pre> <p><code>synchronized</code> guarantees atomicity within the <code>increment()</code> method.  Only one thread can execute the code within the synchronized block at a time.</p> <ul> <li>Double-Checked Locking (flawed):  Without proper memory barrier handling (which the <code>volatile</code> keyword provides a form of), double-checked locking can fail.</li> </ul> <p>```java class Singleton {     private static Singleton instance;</p> <pre><code>public static Singleton getInstance() {\n    if (instance == null) {\n        synchronized (Singleton.class) { // Inefficient synchronization\n            if (instance == null) {\n                instance = new Singleton();\n            }\n        }\n    }\n    return instance;\n}\n</code></pre> <p>} ```  The first null check should be made volatile to avoid race conditions.  Using static initialization blocks are typically preferred for better safety.</p> <p>4. Conclusion</p> <p>The Java Memory Model is a complex but essential part of Java's concurrency model. Understanding its core concepts\u2014happens-before, atomicity, visibility, and ordering\u2014is crucial for writing correct and efficient multithreaded Java applications.  Ignoring the JMM can lead to subtle and difficult-to-debug concurrency bugs.  Leveraging features like <code>volatile</code>, <code>synchronized</code>, and atomic variables is essential for ensuring data consistency and avoiding race conditions in your concurrent programs.  While the details can be intricate, a grasp of the fundamental principles is sufficient for many applications, allowing developers to build reliable and performant concurrent systems.</p>"},{"location":"notes/java/Keywords_static_final_this_super/","title":"Keywords static final this super","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/java/List_Interface_ArrayList_LinkedList/","title":"List Interface ArrayList LinkedList","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/java/Map_Interface_HashMap_TreeMap_LinkedHashMap/","title":"Map Interface HashMap TreeMap LinkedHashMap","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/java/Multithreading_and_Concurrency_Thread_class_Runnab/","title":"Multithreading and Concurrency Thread class Runnab","text":"<p>\u26a0\ufe0f Error generating content: 429 You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits. [violations {   quota_metric: \"generativelanguage.googleapis.com/generate_content_free_tier_requests\"   quota_id: \"GenerateRequestsPerDayPerProjectPerModel-FreeTier\"   quota_dimensions {     key: \"model\"     value: \"gemini-1.5-flash\"   }   quota_dimensions {     key: \"location\"     value: \"global\"   }   quota_value: 50 } , links {   description: \"Learn more about Gemini API quotas\"   url: \"https://ai.google.dev/gemini-api/docs/rate-limits\" } , retry_delay {   seconds: 20 } ]</p>"},{"location":"notes/java/Object-Oriented_Programming_OOP_Encapsulation_Inhe/","title":"Object Oriented Programming OOP Encapsulation Inhe","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/java/Packages_and_Access_Modifiers/","title":"Packages and Access Modifiers","text":""},{"location":"notes/java/Packages_and_Access_Modifiers/#packages-and-access-modifiers-study-notes","title":"Packages and Access Modifiers: Study Notes","text":"<p>1. Introduction</p> <p>Packages and access modifiers are fundamental concepts in object-oriented programming (OOP) that contribute significantly to code organization, maintainability, and security.  Packages provide a mechanism for grouping related classes and interfaces, promoting modularity and preventing naming conflicts. Access modifiers control the visibility and accessibility of classes, methods, and variables, enabling encapsulation and protecting sensitive data.  Understanding these concepts is crucial for writing robust, scalable, and well-structured programs.  This document will explore these concepts in detail, providing clear explanations and practical examples.</p> <p>2. Core Concepts</p> <p>2.1 Packages:</p> <ul> <li>Purpose: Packages are namespaces that organize related classes and interfaces into logical units. They prevent naming collisions (two classes with the same name) and improve code readability and maintainability by grouping logically related elements together.</li> <li>Structure: Packages are organized hierarchically using dot notation (e.g., <code>com.example.mypackage</code>).  This mirrors the file system structure where packages are typically represented by directories.</li> <li>Import Statements: To use classes from another package, you need to import them using an <code>import</code> statement.  For example: <code>import java.util.ArrayList;</code></li> <li>Default Package:  If a class is not explicitly placed in a package, it belongs to the default (unnamed) package.  It's generally recommended to always place classes in named packages.</li> <li>Benefits: Improved code organization, reduced naming conflicts, better reusability, and enhanced modularity.</li> </ul> <p>2.2 Access Modifiers:</p> <p>Access modifiers determine the scope of accessibility for class members (fields, methods, constructors).  Java offers four access modifiers:</p> <ul> <li><code>public</code>:  Accessible from anywhere \u2013 within the same class, other classes in the same package, subclasses in different packages, and even from other projects.</li> <li><code>protected</code>: Accessible within the same package and by subclasses, even if those subclasses are in a different package.  This promotes inheritance while restricting access from unrelated classes.</li> <li><code>default</code> (package-private):  Accessible only within the same package. No explicit keyword is used; it's the default if no access modifier is specified.  This is useful for internal implementation details that shouldn't be exposed outside the package.</li> <li><code>private</code>: Accessible only within the same class.  This is the strictest access modifier and is fundamental to encapsulation, hiding internal implementation details.</li> </ul> <p>2.3  Encapsulation:</p> <p>Encapsulation is a core OOP principle closely tied to access modifiers. It involves bundling data (fields) and methods that operate on that data within a class, and controlling access to that data using access modifiers.  This protects data integrity and simplifies code maintenance by hiding internal complexity.  Private fields are accessed and manipulated through public or protected methods (getters and setters), providing controlled access.</p> <p>3. Practical Examples (Java)</p> <pre><code>// com.example.mypackage\npackage com.example.mypackage;\n\npublic class MyClass { // public class accessible from anywhere\n\n    private int privateVariable; // accessible only within MyClass\n    protected String protectedVariable; // accessible within the package and subclasses\n    int defaultVariable; // accessible only within com.example.mypackage\n    public double publicVariable; // accessible from anywhere\n\n    private void privateMethod() { } // accessible only within MyClass\n    protected void protectedMethod() { } // accessible within the package and subclasses\n    void defaultMethod() { } // accessible only within com.example.mypackage\n    public void publicMethod() { } // accessible from anywhere\n\n    public int getPrivateVariable() { return privateVariable; } // Getter method for private field\n    public void setPrivateVariable(int value) { privateVariable = value; } // Setter method for private field\n}\n\n//Another class in the same package\nclass AnotherClassInSamePackage{\n    public void accessMembers(){\n        MyClass myObject = new MyClass();\n        myObject.defaultVariable = 10; // Allowed - default access\n        myObject.protectedVariable = \"Hello\"; // Allowed - protected access\n        myObject.publicVariable = 3.14; // Allowed - public access\n        myObject.publicMethod();//Allowed - public method\n    }\n}\n\n\n//Class in a different package\npackage com.example.anotherpackage;\n\nimport com.example.mypackage.MyClass;\n\npublic class SubClass extends MyClass{\n    public void accessMembers(){\n        // Accessing members from parent class\n        this.protectedVariable = \"World\"; //Allowed - protected access in subclass\n        this.publicVariable = 2.71; //Allowed - public access\n        this.publicMethod(); //Allowed - public access\n        //this.privateVariable = 5; //Error: private access\n        //this.privateMethod();//Error: private access\n    }\n}\n</code></pre> <p>4. Conclusion</p> <p>Packages and access modifiers are essential tools for building robust and maintainable software.  Packages promote modularity and organization, while access modifiers support encapsulation and data protection. Mastering these concepts is vital for writing clean, efficient, and secure Java code, and indeed code in most object-oriented languages.  Careful consideration of package structure and access levels is crucial in larger projects to ensure code clarity, reusability, and prevent unexpected behavior due to unintended access.</p>"},{"location":"notes/java/Queue_Interface_PriorityQueue_ArrayDeque/","title":"Queue Interface PriorityQueue ArrayDeque","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/java/Set_Interface_HashSet_TreeSet/","title":"Set Interface HashSet TreeSet","text":""},{"location":"notes/java/Set_Interface_HashSet_TreeSet/#set-interface-hashset-treeset-study-notes","title":"Set Interface (HashSet, TreeSet) - Study Notes","text":"<p>1. Introduction</p> <p>The <code>Set</code> interface in Java, part of the Collections Framework, represents an unordered collection of unique elements.  Unlike <code>List</code>, which allows duplicate elements and maintains insertion order, a <code>Set</code> guarantees that each element is distinct.  This uniqueness constraint is the defining characteristic of a <code>Set</code>.  The primary implementations of the <code>Set</code> interface are <code>HashSet</code> and <code>TreeSet</code>, each offering different performance characteristics and functionalities based on their underlying data structures.  Understanding the nuances of these implementations is crucial for effective Java programming.</p> <p>2. Core Concepts</p> <ul> <li> <p>Uniqueness: The core principle of a <code>Set</code> is that it contains only one instance of each element.  Attempts to add duplicate elements are ignored.  The equality of elements is determined by the <code>equals()</code> method.  If two objects are considered equal by <code>equals()</code>, only one will be present in the Set.  It's crucial to override <code>equals()</code> and <code>hashCode()</code> consistently for custom classes used within <code>Set</code>s to ensure proper functionality.</p> </li> <li> <p>Unordered (HashSet): <code>HashSet</code>s, backed by a hash table, do not maintain any specific order of elements.  Iteration order is not guaranteed and may vary between runs.  This allows for fast <code>add</code>, <code>remove</code>, and <code>contains</code> operations (average O(1) time complexity).</p> </li> <li> <p>Ordered (TreeSet): <code>TreeSet</code>s, backed by a red-black tree, maintain elements in a sorted order (natural ordering or based on a provided <code>Comparator</code>). This comes at the cost of slightly slower operations compared to <code>HashSet</code> (average O(log n) time complexity).  The sorted order allows for efficient retrieval of elements within a specific range.</p> </li> <li> <p>Iteration: Both <code>HashSet</code> and <code>TreeSet</code> implement the <code>Iterable</code> interface, allowing easy iteration over their elements using enhanced for loops or iterators.  The iteration order for <code>HashSet</code> is unpredictable, while for <code>TreeSet</code>, it's sorted according to the specified ordering.</p> </li> <li> <p>Null Elements: Both <code>HashSet</code> and <code>TreeSet</code> can hold at most one null element.</p> </li> </ul> <p>3. Practical Examples</p> <p>Example 1: HashSet</p> <pre><code>import java.util.HashSet;\nimport java.util.Set;\n\npublic class HashSetExample {\n    public static void main(String[] args) {\n        Set&lt;String&gt; mySet = new HashSet&lt;&gt;();\n        mySet.add(\"apple\");\n        mySet.add(\"banana\");\n        mySet.add(\"apple\"); // Duplicate - ignored\n        mySet.add(\"orange\");\n\n        System.out.println(mySet); // Output: [banana, apple, orange] (order not guaranteed)\n        System.out.println(mySet.contains(\"banana\")); // Output: true\n        System.out.println(mySet.size()); // Output: 3\n    }\n}\n</code></pre> <p>Example 2: TreeSet</p> <pre><code>import java.util.TreeSet;\nimport java.util.Set;\nimport java.util.Comparator;\n\npublic class TreeSetExample {\n    public static void main(String[] args) {\n        // Natural ordering (based on String's compareTo method)\n        Set&lt;String&gt; myTreeSet = new TreeSet&lt;&gt;();\n        myTreeSet.add(\"apple\");\n        myTreeSet.add(\"banana\");\n        myTreeSet.add(\"orange\");\n\n        System.out.println(myTreeSet); // Output: [apple, banana, orange] (sorted)\n\n\n        // Custom ordering using Comparator\n        Comparator&lt;String&gt; reverseComparator = (s1, s2) -&gt; s2.compareTo(s1);\n        Set&lt;String&gt; myTreeSetReverse = new TreeSet&lt;&gt;(reverseComparator);\n        myTreeSetReverse.add(\"apple\");\n        myTreeSetReverse.add(\"banana\");\n        myTreeSetReverse.add(\"orange\");\n        System.out.println(myTreeSetReverse); //Output: [orange, banana, apple] (reverse sorted)\n    }\n}\n</code></pre> <p>Example 3:  Custom Class in a Set</p> <pre><code>import java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\n\nclass Person {\n    String name;\n    int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age &amp;&amp; Objects.equals(name, person.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n\n    @Override\n    public String toString(){\n        return name + \" (\" + age + \")\";\n    }\n}\n\npublic class CustomClassInSet {\n    public static void main(String[] args) {\n        Set&lt;Person&gt; people = new HashSet&lt;&gt;();\n        people.add(new Person(\"Alice\", 30));\n        people.add(new Person(\"Bob\", 25));\n        people.add(new Person(\"Alice\", 30)); // Duplicate - ignored due to equals/hashCode\n\n        System.out.println(people); // Output will show only unique Person objects.\n    }\n}\n</code></pre> <p>4. Conclusion</p> <p>The choice between <code>HashSet</code> and <code>TreeSet</code> depends on the specific application requirements. If order doesn't matter and fast lookups are prioritized, <code>HashSet</code> is the better choice. If maintaining a sorted order is essential or range-based queries are frequent, <code>TreeSet</code> is preferred.  Remember that correctly implementing <code>equals()</code> and <code>hashCode()</code> is crucial when using custom classes with <code>Set</code> implementations to ensure uniqueness and proper functionality.  Understanding these fundamental concepts enables efficient and robust use of the <code>Set</code> interface in Java.</p>"},{"location":"notes/java/Spring_Framework_Spring_Boot_for_backend_developme/","title":"Spring Framework Spring Boot for backend developme","text":""},{"location":"notes/java/Spring_Framework_Spring_Boot_for_backend_developme/#spring-framework-spring-boot-for-backend-development-premium-study-notes","title":"Spring Framework / Spring Boot (for backend development): Premium Study Notes","text":"<p>## 1. Introduction</p> <p>Spring is a powerful, lightweight, and widely-adopted Java framework for building robust and scalable applications. It simplifies the development process by providing a comprehensive set of tools and features that address various aspects of enterprise application development.  Spring Boot, built on top of Spring Framework, further streamlines the development experience by offering auto-configuration, starter dependencies, and embedded servers, significantly reducing boilerplate code and speeding up development cycles.  It's particularly well-suited for microservices architectures and rapid prototyping.</p> <p>Key Advantages of using Spring/Spring Boot:</p> <ul> <li>Dependency Injection (DI): Decouples components, enhancing testability and maintainability.  Loose coupling is achieved by injecting dependencies into classes instead of hardcoding them.</li> <li>Aspect-Oriented Programming (AOP): Separates cross-cutting concerns (like logging, security, and transaction management) from core business logic, improving modularity and code reusability.</li> <li>Data Access: Provides seamless integration with various databases through technologies like JDBC, JPA (Java Persistence API), and Hibernate.  Simplifies database interactions and manages transactions efficiently.</li> <li>Transaction Management: Ensures data consistency and integrity through declarative and programmatic transaction management.</li> <li>Testing: Provides robust testing capabilities, making it easier to write unit, integration, and functional tests.</li> <li>Security:  Offers strong security features, including authentication and authorization mechanisms, to protect applications from unauthorized access.</li> <li>RESTful Web Services:  Facilitates the creation of RESTful APIs using Spring MVC or Spring WebFlux (reactive programming).</li> <li>Microservices: Enables the development of microservices through auto-configuration, embedded servers, and actuator features for monitoring and management.</li> </ul> <p>Target Audience:  These notes are intended for Java developers with some basic understanding of Java programming concepts who want to learn and master the Spring Framework and Spring Boot.</p> <p>## 2. Core Concepts</p> <p>2.1 Dependency Injection (DI):</p> <ul> <li>Inversion of Control (IoC):  The core principle of DI.  Instead of objects creating their dependencies, dependencies are \"injected\" into objects. This inverts the control of dependency creation from the object itself to a container (like the Spring container).</li> <li>Types of DI: Constructor Injection (dependencies are passed through the constructor), Setter Injection (dependencies are set using setter methods), and Field Injection (dependencies are directly injected into fields \u2013 generally less preferred for testability reasons).</li> <li>Bean Definition:  Describes the configuration of an object (bean) managed by the Spring container.  It specifies the class, properties, and dependencies of the bean.</li> <li>Bean Scope: Defines the lifecycle and visibility of a bean (e.g., singleton, prototype, request, session).</li> </ul> <p>2.2 Aspect-Oriented Programming (AOP):</p> <ul> <li>Cross-cutting concerns:  Functionality that cuts across multiple parts of an application (e.g., logging, security, transaction management).</li> <li>Aspects: Modules encapsulating cross-cutting concerns.</li> <li>Advice:  Action taken by an aspect (e.g., before, after, around advice).</li> <li>Join points: Points in the application where an aspect can be applied (e.g., method execution, exception handling).</li> <li>Pointcuts:  Expressions that define which join points an aspect should apply to.</li> <li>Weaving:  The process of integrating aspects into the application.</li> </ul> <p>2.3 Spring Data Access:</p> <ul> <li>JDBC:  Provides a low-level API for interacting with relational databases.</li> <li>JPA (Java Persistence API):  Provides a higher-level, object-relational mapping (ORM) framework.</li> <li>Hibernate: A popular implementation of JPA.</li> <li>Spring Data JPA:  Simplifies JPA usage by providing repository interfaces and automatic implementation.</li> <li>Spring Data REST:  Creates RESTful APIs automatically from JPA repositories.</li> </ul> <p>2.4 Spring Boot Specifics:</p> <ul> <li>Auto-configuration:  Automatically configures Spring beans based on dependencies in the classpath.</li> <li>Starter dependencies:  Pre-packaged dependencies that simplify project setup.</li> <li>Embedded servers:  Includes embedded Tomcat, Jetty, or Undertow servers for easy deployment.</li> <li>Actuator:  Provides production-ready features for monitoring and managing applications.</li> <li>Spring Initializr: A web-based tool or command-line tool for creating Spring Boot projects.</li> </ul> <p>## 3. Practical Examples</p> <p>(Note:  These examples would be fleshed out with complete code snippets in a real document.  Here, I provide conceptual outlines.)</p> <p>3.1 Simple Spring Boot REST Controller:</p> <ul> <li>Create a Spring Boot project with Spring Web dependency.</li> <li>Create a REST controller class annotated with <code>@RestController</code>.</li> <li>Define endpoint methods annotated with <code>@GetMapping</code>, <code>@PostMapping</code>, etc.</li> <li>Return data in JSON format using <code>@ResponseBody</code> or by directly returning objects.</li> </ul> <p>3.2 Spring Data JPA Example:</p> <ul> <li>Define a JPA entity class with <code>@Entity</code> annotation.</li> <li>Create a repository interface extending <code>JpaRepository</code>.</li> <li>Inject the repository into a service class.</li> <li>Use repository methods (e.g., <code>save</code>, <code>findAll</code>, <code>findById</code>) to interact with the database.</li> </ul> <p>3.3 Implementing AOP for Logging:</p> <ul> <li>Create an aspect class annotated with <code>@Aspect</code>.</li> <li>Define pointcuts using <code>@Pointcut</code> to specify which methods to intercept.</li> <li>Use <code>@Before</code>, <code>@After</code>, or <code>@Around</code> advice to add logging functionality before, after, or around method execution.</li> </ul> <p>3.4 Spring Boot Testing:</p> <ul> <li>Use <code>@SpringBootTest</code> to test Spring Boot applications.</li> <li>Use <code>@Autowired</code> to inject dependencies into test classes.</li> <li>Use mocking frameworks (e.g., Mockito) to mock dependencies.</li> <li>Write unit tests for individual components and integration tests for entire modules.</li> </ul> <p>## 4. Conclusion</p> <p>Spring and Spring Boot have significantly impacted the Java ecosystem by providing a comprehensive and efficient framework for building enterprise-grade applications.  The concepts of DI and AOP promote modularity, testability, and maintainability.  Spring Boot's auto-configuration and starter dependencies drastically reduce development time and complexity. Mastering these frameworks equips developers with the skills to build scalable, robust, and maintainable applications.  Further exploration of advanced topics like Spring Security, Spring Cloud (for distributed systems), and reactive programming with Spring WebFlux will expand capabilities and allow developers to tackle complex challenges effectively.  Continuous learning and practice are key to becoming proficient in Spring and Spring Boot development.</p>"},{"location":"notes/java/Strings_and_String_Manipulation/","title":"Strings and String Manipulation: Premium Study Notes","text":""},{"location":"notes/java/Strings_and_String_Manipulation/#1-introduction","title":"1. Introduction","text":"<p>Strings are fundamental data structures in virtually all programming languages. They represent sequences of characters, forming the basis for text manipulation, data storage, and user interface elements.  Understanding strings and their manipulation is crucial for any programmer, regardless of their specialization. This document provides a comprehensive overview of string concepts and techniques, focusing on practical application and efficient methods. We'll explore core concepts, common operations, and advanced techniques to empower you to work confidently with strings in your coding endeavors.  The efficiency and readability of your code will significantly benefit from mastering string manipulation.</p>"},{"location":"notes/java/Strings_and_String_Manipulation/#2-core-concepts","title":"2. Core Concepts","text":"<p>This section delves into the essential concepts related to strings:</p> <ul> <li> <p>String Representation:  Strings are typically stored internally as arrays of characters (Unicode characters in modern systems).  Understanding this underlying structure aids in grasping the efficiency of various string operations.  Different programming languages may have variations in how strings are implemented (e.g., immutable vs. mutable strings).  Immutability implies that once a string is created, its value cannot be changed; instead, operations create new strings.  Mutable strings allow in-place modification.</p> </li> <li> <p>Character Encoding:  Understanding character encoding (e.g., ASCII, UTF-8, UTF-16) is crucial.  Different encodings represent characters using different numbers of bytes, potentially leading to issues if not handled correctly (e.g., mojibake). UTF-8 is the dominant encoding for web and most modern applications due to its variable-length encoding efficiently handling various character sets.</p> </li> <li> <p>String Immutability (in many languages):  In languages like Python and Java, strings are immutable.  Operations that appear to modify a string actually create a new string in memory. This behavior affects memory management and performance considerations, particularly with frequent string manipulations.</p> </li> <li> <p>String Literals:  Strings are typically defined using quotation marks (single or double, depending on the language).  Escape sequences (e.g., <code>\\n</code> for newline, <code>\\t</code> for tab) allow embedding special characters within string literals.</p> </li> <li> <p>String Length: The number of characters in a string. Efficient algorithms often rely on knowing the string's length beforehand.</p> </li> <li> <p>String Indexing:  Access individual characters within a string using their index (position), typically starting from 0.  Negative indices can access characters from the end of the string.</p> </li> </ul>"},{"location":"notes/java/Strings_and_String_Manipulation/#3-practical-examples","title":"3. Practical Examples","text":"<p>This section provides practical examples using Python, but the concepts are transferable to other languages:</p> <p>Basic Operations:</p> <pre><code>my_string = \"Hello, World!\"\n\n# Length\nprint(len(my_string))  # Output: 13\n\n# Indexing\nprint(my_string[0])  # Output: H\nprint(my_string[-1]) # Output: !\nprint(my_string[7:12]) # Output: World (slicing)\n\n# Concatenation\nnew_string = my_string + \" How are you?\"\nprint(new_string)\n\n# String Methods:**\n\n# Uppercase/Lowercase\nprint(my_string.upper()) # Output: HELLO, WORLD!\nprint(my_string.lower()) # Output: hello, world!\n\n# Finding Substrings\nprint(my_string.find(\"World\")) # Output: 7 (index of the first occurrence)\n\n# Replacing Substrings\nprint(my_string.replace(\"World\", \"Python\")) # Output: Hello, Python!\n\n# Splitting Strings\nwords = my_string.split(\",\")\nprint(words) # Output: ['Hello', ' World!']\n\n# Checking for Substrings\nprint(\"World\" in my_string) # Output: True\n\n\n# Formatting Strings (f-strings):\nname = \"Alice\"\nage = 30\nprint(f\"My name is {name} and I am {age} years old.\") #Output: My name is Alice and I am 30 years old.\n</code></pre> <p>Advanced Techniques:</p> <ul> <li> <p>Regular Expressions:  Powerful tools for pattern matching and manipulation within strings.  Libraries like Python's <code>re</code> module provide functionalities for complex string searches and replacements.  (Example omitted for brevity, but highly recommended for study).</p> </li> <li> <p>String Parsing:  Extracting specific information from strings, often using delimiters or regular expressions.  Common in data processing and web scraping.</p> </li> <li> <p>String Formatting:  Creating formatted output strings,  including aligning text, padding, and specifying data types (e.g., using <code>printf</code>-style formatting or f-strings in Python).</p> </li> </ul>"},{"location":"notes/java/Strings_and_String_Manipulation/#4-conclusion","title":"4. Conclusion","text":"<p>String manipulation is a fundamental skill for programmers.  Understanding core concepts like character encoding, immutability, and efficient operations is crucial for writing clear, efficient, and maintainable code.  This document has provided a foundation in string manipulation, but continued practice with various techniques, including regular expressions and advanced formatting, is essential to mastering this important aspect of programming. Remember to consult the documentation for your specific programming language for detailed information on its string functions and methods.</p>"},{"location":"notes/java/Unit_Testing_with_JUnit_and_Mockito/","title":"Unit Testing with JUnit and Mockito","text":""},{"location":"notes/java/Unit_Testing_with_JUnit_and_Mockito/#unit-testing-with-junit-and-mockito","title":"Unit Testing with JUnit and Mockito","text":"<p>## 1. Introduction</p> <p>Unit testing is a crucial aspect of software development, focusing on verifying the correctness of individual units (typically methods or classes) in isolation.  This ensures that each component functions as expected before integration, leading to more robust and maintainable code.  JUnit is a popular Java unit testing framework that provides the infrastructure for writing and running tests. Mockito is a mocking framework that simplifies testing by simulating the behavior of external dependencies, allowing you to focus on the unit under test without the complexities of real-world interactions.  Together, JUnit and Mockito form a powerful combination for effective unit testing in Java. This document will explore core concepts and provide practical examples to solidify your understanding.</p> <p>## 2. Core Concepts</p> <p>2.1 JUnit:</p> <ul> <li><code>@Test</code> annotation: Marks a method as a test case.  JUnit will automatically execute methods annotated with <code>@Test</code>.</li> <li>Assertions:  Methods used to verify expected outcomes.  Common assertions include <code>assertEquals()</code>, <code>assertTrue()</code>, <code>assertFalse()</code>, <code>assertNull()</code>, <code>assertNotNull()</code>, etc.  Failures in assertions cause the test to fail.</li> <li>Test Runner:  Executes the test methods.  JUnit provides various runners (e.g., <code>JUnit4</code>, <code>JUnitJupiter</code>).</li> <li>Test Suites:  Group multiple test classes together for efficient execution.</li> <li>Test Lifecycle:  JUnit manages the lifecycle of tests, including setup (<code>@Before</code> or <code>@BeforeEach</code>) and teardown (<code>@After</code> or <code>@AfterEach</code>) methods.  <code>@BeforeClass</code> and <code>@AfterClass</code> methods are used for setup and teardown at the class level.  <code>@BeforeAll</code> and <code>@AfterAll</code> are their counterparts in JUnit Jupiter.</li> <li>Expected Exceptions: <code>@Test(expected = Exception.class)</code> allows you to verify that a specific exception is thrown.</li> </ul> <p>2.2 Mockito:</p> <ul> <li>Mocking:  Creating simulated objects (mocks) that mimic the behavior of real objects.  Mocks are controlled by the test and allow you to define specific responses to method calls.</li> <li><code>Mockito.mock()</code>: Creates a mock object of a given class or interface.</li> <li>Stubbing:  Defining the behavior of mock objects.  <code>when(mockObject.method()).thenReturn(value)</code> sets the return value of a method call.</li> <li>Verification:  Checking if methods on mock objects were called as expected.  <code>verify(mockObject).method()</code> verifies that the method was called.</li> <li>Spies:  Partial mocks that record actual method invocations while allowing some methods to be stubbed.  Useful when you want to test interactions with real objects alongside mocks.</li> <li>Argument Matchers:  Used to verify method calls with specific arguments, such as <code>anyString()</code>, <code>eq(value)</code>, <code>anyInt()</code>, etc.</li> </ul> <p>## 3. Practical Examples</p> <p>Let's consider a simple example of a <code>UserService</code> that interacts with a <code>UserRepository</code>:</p> <pre><code>public interface UserRepository {\n    User findById(Long id);\n    void save(User user);\n}\n\npublic class User {\n    private Long id;\n    // ... other fields and methods\n}\n\npublic class UserService {\n    private UserRepository userRepository;\n\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    public User getUserById(Long id) {\n        return userRepository.findById(id);\n    }\n\n    public void saveUser(User user) {\n        userRepository.save(user);\n    }\n}\n</code></pre> <p>Now, let's write JUnit tests using Mockito:</p> <pre><code>import org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\npublic class UserServiceTest {\n    @Test\n    void testGetUserById() {\n        UserRepository mockRepo = Mockito.mock(UserRepository.class);\n        User user = new User(); // Create a dummy User object\n        user.setId(1L);\n        when(mockRepo.findById(1L)).thenReturn(user);\n\n        UserService userService = new UserService(mockRepo);\n        User retrievedUser = userService.getUserById(1L);\n\n        assertEquals(user, retrievedUser);\n        verify(mockRepo).findById(1L);\n    }\n\n    @Test\n    void testSaveUser() {\n        UserRepository mockRepo = Mockito.mock(UserRepository.class);\n        User user = new User();\n        userService.saveUser(user);\n        verify(mockRepo).save(user);\n    }\n}\n</code></pre> <p>This example demonstrates how to mock the <code>UserRepository</code>, stub its methods, and verify interactions using Mockito within JUnit tests.  You can expand this with more complex scenarios and different assertion types.</p> <p>## 4. Conclusion</p> <p>JUnit and Mockito are invaluable tools for writing effective unit tests.  By isolating units of code and controlling their dependencies, you can thoroughly test functionality and identify defects early in the development process. Mastering these frameworks significantly improves code quality, reduces bugs, and enhances maintainability. Remember to focus on writing clear, concise, and well-organized tests that cover a range of scenarios, including edge cases and boundary conditions.  Regularly updating your tests as your code evolves is crucial to maintain their value and ensure your software remains reliable.</p>"},{"location":"notes/react/Accessibility_a11y_in_React/","title":"Accessibility a11y in React","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/Basic_Form_Handling_Controlled_Components/","title":"Basic Form Handling Controlled Components","text":""},{"location":"notes/react/Basic_Form_Handling_Controlled_Components/#basic-form-handling-controlled-components-study-notes","title":"Basic Form Handling (Controlled Components) - Study Notes","text":"<p>## 1. Introduction</p> <p>Form handling is a crucial aspect of building interactive web applications.  Users interact with applications primarily through forms, providing data that the application processes and responds to. In React (and other component-based frameworks), controlled components are the standard approach for managing form data.  Unlike uncontrolled components, which let the DOM manage the form's state, controlled components keep the form's state entirely within the React component. This provides greater predictability, easier validation, and better control over the user experience.  This approach ensures data consistency and allows for complex form logic to be implemented seamlessly.  Understanding controlled components is fundamental to building robust and user-friendly React applications.</p> <p>## 2. Core Concepts</p> <ul> <li> <p>Controlled Component: A form element whose value is controlled by the React component's state.  The component's state dictates the value displayed in the form element, and any changes made by the user update the component's state.  This bidirectional data flow is key.</p> </li> <li> <p><code>useState</code> Hook (or equivalent state management):  This is the mechanism used to manage the form data within the component's state.  Each form field typically has its own state variable.</p> </li> <li> <p><code>onChange</code> Event Handler: This event fires whenever the user interacts with the form field (e.g., typing, selecting an option).  The event handler updates the corresponding state variable with the new value, triggering a re-render of the component to reflect the changes.</p> </li> <li> <p>Event Object: The <code>onChange</code> event provides an <code>event</code> object containing information about the change, notably the <code>target.value</code> property, which holds the new value entered by the user.</p> </li> <li> <p>Synthetic Events: React uses synthetic events, which are cross-browser compatible abstractions over native browser events.  They provide a consistent interface for handling user interactions.</p> </li> <li> <p>Form Submission:  Controlled components require explicit handling of form submission.  The default browser submission behavior needs to be prevented (using <code>preventDefault</code>), and the form data should be processed within the component's logic.</p> </li> <li> <p>Validation:  Controlled components facilitate easy validation because all form data resides in the component's state.  Validation rules can be applied directly to this state before submitting the form.</p> </li> <li> <p>Error Handling:  Any errors during form submission or validation can be neatly handled within the component, providing informative feedback to the user.</p> </li> </ul> <p>## 3. Practical Examples</p> <p>Example 1: Simple Text Input</p> <pre><code>import React, { useState } from 'react';\n\nfunction MyForm() {\n  const [name, setName] = useState('');\n\n  const handleChange = (event) =&gt; {\n    setName(event.target.value);\n  };\n\n  const handleSubmit = (event) =&gt; {\n    event.preventDefault();\n    alert(`A name was submitted: ${name}`);\n  };\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;label&gt;\n        Name:\n        &lt;input type=\"text\" value={name} onChange={handleChange} /&gt;\n      &lt;/label&gt;\n      &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n\nexport default MyForm;\n</code></pre> <p>Example 2: Multiple Inputs &amp; Validation</p> <pre><code>import React, { useState } from 'react';\n\nfunction MyForm() {\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const [errors, setErrors] = useState({});\n\n  const handleChange = (event) =&gt; {\n    const { name, value } = event.target;\n    if (name === 'email') setEmail(value);\n    else if (name === 'password') setPassword(value);\n  };\n\n  const handleSubmit = (event) =&gt; {\n    event.preventDefault();\n    const newErrors = {};\n    if (!email) newErrors.email = 'Email is required';\n    if (!password) newErrors.password = 'Password is required';\n    setErrors(newErrors);\n    if (Object.keys(newErrors).length === 0) {\n      alert('Form submitted successfully!');\n    }\n  };\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;label&gt;\n        Email:\n        &lt;input type=\"email\" name=\"email\" value={email} onChange={handleChange} /&gt;\n        {errors.email &amp;&amp; &lt;span style={{color: 'red'}}&gt;{errors.email}&lt;/span&gt;}\n      &lt;/label&gt;\n      &lt;label&gt;\n        Password:\n        &lt;input type=\"password\" name=\"password\" value={password} onChange={handleChange} /&gt;\n        {errors.password &amp;&amp; &lt;span style={{color: 'red'}}&gt;{errors.password}&lt;/span&gt;}\n      &lt;/label&gt;\n      &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n\nexport default MyForm;\n</code></pre> <p>## 4. Conclusion</p> <p>Controlled components are the preferred method for handling forms in React. They offer a structured and predictable approach, simplifying state management, validation, and error handling.  By mastering the core concepts\u2014<code>useState</code>, <code>onChange</code>, and event handling\u2014developers can build robust and user-friendly forms that seamlessly integrate with their React applications.  Understanding the examples provided, and practicing building various forms, is crucial to solidifying this knowledge.  Further exploration might involve learning about more advanced form handling libraries and techniques for handling larger, more complex forms.</p>"},{"location":"notes/react/CSS-in-JS_Styled_Components_Emotion/","title":"CSS in JS Styled Components Emotion","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/CSS_Modules/","title":"CSS Modules","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/Client_State_vs_Server_State/","title":"Client State vs Server State","text":""},{"location":"notes/react/Client_State_vs_Server_State/#client-state-vs-server-state-a-comprehensive-overview","title":"Client State vs. Server State: A Comprehensive Overview","text":"<p>1. Introduction</p> <p>In distributed systems, particularly those involving client-server architectures, understanding the distinction between client state and server state is crucial for designing robust, scalable, and secure applications.  Client state refers to data stored and managed exclusively on the client machine (e.g., a web browser, mobile app), while server state resides on the server and is responsible for the application's core logic and data persistence.  The interplay and proper management of these two states determine the application's functionality, performance, and overall user experience. This document explores the key differences, practical applications, and considerations related to client and server state management.</p> <p>2. Core Concepts</p> Feature Client State Server State Location Client machine (browser, mobile device, etc.) Server machine Persistence Typically volatile; lost on browser closure, app termination, or device failure Persistent; stored in databases, files, etc. Accessibility Accessible only to the client Accessible by the server and potentially other clients (depending on architecture) Security Potentially less secure; susceptible to local attacks Generally more secure; protected by server-side measures Synchronization Requires mechanisms for synchronization with server state, if necessary Managed by the server itself Data Examples UI preferences, locally cached data, temporary forms, partially filled forms User accounts, product catalogs, transaction history, application configuration Advantages Improved performance (reduced server load), offline functionality, enhanced user experience (faster responses) Data integrity, consistency, security, central control Disadvantages Data inconsistencies, potential security risks, limited scalability, no offline usage (unless explicitly designed) Increased complexity, potential for bottlenecks, higher reliance on network connectivity <p>3. Practical Examples</p> <ul> <li> <p>E-commerce Website:</p> <ul> <li>Client State: Items added to the shopping cart (before checkout), user's preferred language or currency selection, temporary search filters. This is often managed using browser cookies or local storage.</li> <li>Server State: Product catalog, user accounts, order history, inventory levels, payment gateway information.  This data is stored persistently in a database.</li> </ul> </li> <li> <p>Online Game:</p> <ul> <li>Client State: Player's current view of the game world (rendered on the screen), temporary game statistics (e.g., current score in a single session),  in-game chat messages (before they are sent to the server).</li> <li>Server State: Game state (location of all players, items, etc.), persistent player statistics (level, experience points, inventory), game rules and configuration.</li> </ul> </li> <li> <p>Collaborative Document Editor:</p> <ul> <li>Client State: Real-time view of the document (may slightly lag server state), cursor position, local edits before syncing.</li> <li>Server State: The authoritative copy of the document, user access controls, revision history.  Mechanisms like Operational Transformation are often employed to ensure consistency.</li> </ul> </li> </ul> <p>4. Conclusion</p> <p>Effective management of both client and server state is paramount for creating responsive, secure, and scalable applications. The optimal balance between client and server state depends heavily on the specific application requirements.  Understanding the trade-offs between performance, security, data consistency, and offline capability is essential in making informed design choices.  Applications often benefit from a hybrid approach, leveraging client-side processing for performance improvements where possible, while maintaining the integrity and security of crucial data on the server.  Careful consideration should be given to synchronization mechanisms and strategies to ensure data consistency between client and server states whenever necessary.</p>"},{"location":"notes/react/Code_Splitting_with_Reactlazy_and_Suspense/","title":"Code Splitting with Reactlazy and Suspense","text":""},{"location":"notes/react/Code_Splitting_with_Reactlazy_and_Suspense/#code-splitting-with-reactlazy-and-suspense","title":"Code Splitting with <code>React.lazy()</code> and <code>&lt;Suspense&gt;</code>","text":"<p>## 1. Introduction</p> <p>Code splitting is a crucial optimization technique in React applications, especially those with large bundles.  It involves breaking down your application's JavaScript code into smaller chunks, loading only the necessary chunks when needed. This significantly improves initial load times and the overall user experience by reducing the amount of JavaScript the browser needs to parse and execute upfront.  Without code splitting, a large React app might take a long time to load, leading to a poor user experience.  <code>React.lazy()</code> and <code>&lt;Suspense&gt;</code> provide a declarative and elegant way to achieve code splitting in React.</p> <p>## 2. Core Concepts</p> <ul> <li> <p><code>React.lazy()</code>: This higher-order component allows you to import components dynamically.  Instead of importing a component directly, you pass a function to <code>React.lazy()</code> that returns a Promise resolving to the component. This function is typically an import using dynamic <code>import()</code>.  When the component is rendered, React loads the corresponding code chunk asynchronously.</p> </li> <li> <p><code>Suspense</code>: The <code>&lt;Suspense&gt;</code> component provides a fallback UI while the lazy-loaded component is being fetched.  This prevents the user from seeing a blank screen or unexpected behavior during the loading process.  It acts as a placeholder, showing a loading indicator or other message until the lazy-loaded component is ready.</p> </li> <li> <p>Dynamic <code>import()</code>: This is a JavaScript feature that allows you to load modules asynchronously.  It is essential for using <code>React.lazy()</code> as it provides the Promise required by <code>React.lazy()</code>. The import statement is wrapped in a function and is only executed when the lazy component is needed.</p> </li> </ul> <p>## 3. Practical Examples</p> <p>Example 1: Basic Code Splitting</p> <pre><code>// Dynamic import of a component\nconst MyLazyComponent = React.lazy(() =&gt; import('./MyLazyComponent'));\n\nfunction MyComponent() {\n  return (\n    &lt;div&gt;\n      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n        &lt;MyLazyComponent /&gt;\n      &lt;/Suspense&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>In this example, <code>MyLazyComponent</code> is loaded only when <code>MyComponent</code> is rendered and <code>MyLazyComponent</code> is needed. The <code>&lt;Suspense&gt;</code> component displays \"Loading...\" until <code>MyLazyComponent</code> is fully loaded.  This approach enhances initial load time by preventing the browser from initially downloading the code for <code>MyLazyComponent</code> if it's not immediately needed.</p> <p>Example 2:  Code Splitting for Routes</p> <p>This is particularly useful in larger applications with many routes.</p> <pre><code>// Import using React Router v6\nimport { lazy, Suspense } from 'react';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nconst Home = lazy(() =&gt; import('./Home'));\nconst About = lazy(() =&gt; import('./About'));\n\nfunction App() {\n  return (\n    &lt;BrowserRouter&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/\" element={\n          &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n            &lt;Home /&gt;\n          &lt;/Suspense&gt;\n        } /&gt;\n        &lt;Route path=\"/about\" element={\n          &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n            &lt;About /&gt;\n          &lt;/Suspense&gt;\n        } /&gt;\n      &lt;/Routes&gt;\n    &lt;/BrowserRouter&gt;\n  );\n}\n</code></pre> <p>This example demonstrates code splitting for different routes. The <code>Home</code> and <code>About</code> components are lazy-loaded, ensuring that only the necessary component is loaded when a particular route is accessed.</p> <p>Example 3: Handling Errors</p> <p>You can add error boundaries to gracefully handle potential errors during the loading process.</p> <pre><code>const MyLazyComponent = React.lazy(() =&gt; import('./MyLazyComponent'));\n\nfunction MyComponent() {\n  return (\n    &lt;ErrorBoundary&gt;\n      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n        &lt;MyLazyComponent /&gt;\n      &lt;/Suspense&gt;\n    &lt;/ErrorBoundary&gt;\n  );\n}\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // Log the error to an error reporting service\n    console.error(\"Error caught:\", error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return &lt;div&gt;Something went wrong.&lt;/div&gt;;\n    }\n\n    return this.props.children;\n  }\n}\n</code></pre> <p>This enhanced example includes an <code>ErrorBoundary</code> to catch any errors during the loading or rendering of <code>MyLazyComponent</code>, preventing a crash and providing a user-friendly error message instead.</p> <p>## 4. Conclusion</p> <p><code>React.lazy()</code> and <code>&lt;Suspense&gt;</code> are powerful tools for optimizing React applications by implementing code splitting.  They offer a clean and declarative way to improve initial load times and the overall user experience.  By strategically splitting your code into smaller chunks and providing appropriate fallback UIs, you can significantly enhance the performance and responsiveness of your React applications, leading to happier users.  Remember to consider error handling to create a robust and user-friendly experience.</p>"},{"location":"notes/react/Concurrent_Features_An_Overview/","title":"Concurrent Features An Overview","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/Context_API_Deep_Dive/","title":"Context API Deep Dive","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/Declarative_Routing_BrowserRouter_Routes_Route/","title":"Declarative Routing BrowserRouter Routes Route","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/End-to-End_E2E_Testing_with_Cypress_or_Playwright/","title":"End to End E2E Testing with Cypress or Playwright","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/Form_Management_Libraries_React_Hook_Form_Formik/","title":"Form Management Libraries React Hook Form Formik","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/Headless_UI_Libraries_Radix_UI_Headless_UI/","title":"Headless UI Libraries Radix UI Headless UI","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/Introduction_to_React_Frameworks_Nextjs_Remix/","title":"Introduction to React Frameworks Nextjs Remix","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/Linting_and_Formatting_ESLint_Prettier/","title":"Linting and Formatting ESLint Prettier","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/Nested_Routes_and_Layouts_Outlet/","title":"Nested Routes and Layouts Outlet","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/Profiling_with_React_DevTools/","title":"Profiling with React DevTools","text":"<p>\u26a0\ufe0f Error generating content: 429 You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits. [violations {   quota_metric: \"generativelanguage.googleapis.com/generate_content_free_tier_requests\"   quota_id: \"GenerateRequestsPerDayPerProjectPerModel-FreeTier\"   quota_dimensions {     key: \"model\"     value: \"gemini-1.5-flash\"   }   quota_dimensions {     key: \"location\"     value: \"global\"   }   quota_value: 50 } , links {   description: \"Learn more about Gemini API quotas\"   url: \"https://ai.google.dev/gemini-api/docs/rate-limits\" } , retry_delay {   seconds: 21 } ]</p>"},{"location":"notes/react/Project_Structure_and_Organization/","title":"Project Structure and Organization","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/Props_Passing_Data_to_Components/","title":"Props Passing Data to Components","text":""},{"location":"notes/react/Props_Passing_Data_to_Components/#props-passing-data-to-components","title":"Props: Passing Data to Components","text":"<p>## 1. Introduction</p> <p>In React, components are the fundamental building blocks of user interfaces.  Often, a component needs data to render correctly.  This data might represent user information, product details, or any other information needed for dynamic display.  Props (short for \"properties\") are the mechanism React uses to pass data from a parent component to its child components.  Understanding props is crucial for building reusable, maintainable, and efficient React applications.  Effectively using props is key to achieving component reusability and promoting a clean, unidirectional data flow.  This is a cornerstone principle of React's architecture, making it predictable and easier to debug.</p> <p>## 2. Core Concepts</p> <ul> <li> <p>Unidirectional Data Flow: Data flows downwards in React; from parent components to child components via props.  Children cannot directly modify their parent's props.  This principle enhances predictability and simplifies state management.</p> </li> <li> <p>Immutability of Props: Props passed to a component should be treated as read-only.  Attempting to directly modify them within the child component will not update the parent's state and can lead to unexpected behavior.  Instead, changes should be handled through the parent component's state and passed down as updated props.</p> </li> <li> <p>Prop Types (Validation):  To improve code maintainability and prevent runtime errors, it's highly recommended to use prop-types.  Prop types allow you to specify the expected data type and shape of the props a component receives.  If a component receives a prop of the incorrect type, a warning will be issued in development mode.  (Note:  While <code>prop-types</code> is a widely used library, newer versions of React utilize TypeScript for stronger type checking.)</p> </li> <li> <p>Passing Data: Props are passed as attributes within the JSX syntax.  The keys are the prop names, and the values are the data being passed.  For example, <code>&lt;MyComponent name=\"Alice\" age={30} /&gt;</code> passes <code>name</code> and <code>age</code> as props to <code>MyComponent</code>.</p> </li> <li> <p>Accessing Props:  Within the child component, props are accessed via <code>this.props</code> (for class components) or directly as parameters (for functional components with destructuring).  For example:</p> <p>```javascript // Class Component class MyComponent extends React.Component {   render() {     return Hello, {this.props.name}!;   } }</p> <p>// Functional Component const MyComponent = ({name}) =&gt; Hello, {name}!; ```</p> </li> <li> <p>Default Props:  You can set default values for props using <code>defaultProps</code> in class components, or by assigning default values to parameters in functional components.  This ensures that the component won't throw errors if a prop is missing.</p> </li> </ul> <p>## 3. Practical Examples</p> <p>Example 1: Simple Prop Passing</p> <pre><code>// Parent Component\nfunction ParentComponent() {\n  const userName = \"Bob\";\n  return (\n    &lt;div&gt;\n      &lt;ChildComponent name={userName} /&gt;\n    &lt;/div&gt;\n  );\n}\n\n// Child Component\nfunction ChildComponent({name}) {\n  return (\n    &lt;p&gt;Hello, {name}!&lt;/p&gt;\n  );\n}\n</code></pre> <p>Example 2: Passing Multiple Props and Default Props</p> <pre><code>// Child Component with Default Props\nconst ChildComponent = ({ name = \"Guest\", age = 0 }) =&gt; (\n    &lt;div&gt;\n      &lt;p&gt;Name: {name}&lt;/p&gt;\n      &lt;p&gt;Age: {age}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n\n//Parent Component\nfunction ParentComponent(){\n    return (\n        &lt;div&gt;\n            &lt;ChildComponent name=\"Alice\" age={30}/&gt;\n            &lt;ChildComponent /&gt; {/* Uses default props */}\n        &lt;/div&gt;\n    )\n}\n</code></pre> <p>Example 3:  Prop Types (using prop-types)</p> <pre><code>import PropTypes from 'prop-types';\n\nconst ChildComponent = ({ name, age }) =&gt; (\n  &lt;div&gt;\n    &lt;p&gt;Name: {name}&lt;/p&gt;\n    &lt;p&gt;Age: {age}&lt;/p&gt;\n  &lt;/div&gt;\n);\n\nChildComponent.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number\n};\n\n// ... rest of the code\n</code></pre> <p>## 4. Conclusion</p> <p>Props are the fundamental mechanism for passing data between components in React.  Understanding their unidirectional flow, immutability, and the use of prop types (or TypeScript) is essential for building well-structured and maintainable React applications. Mastering props is a crucial step towards building complex, scalable, and robust user interfaces.  By effectively leveraging props and adhering to best practices, developers can improve code readability, reduce bugs, and significantly enhance their overall development workflow.</p>"},{"location":"notes/react/Redux_Core_Concepts_Store_Actions_Reducers_Slices/","title":"Redux Core Concepts Store Actions Reducers Slices","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/Refs_and_Forwarding_Refs/","title":"Refs and Forwarding Refs","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/Render_Props_Pattern/","title":"Render Props Pattern","text":""},{"location":"notes/react/Render_Props_Pattern/#render-props-pattern-premium-study-notes","title":"Render Props Pattern: Premium Study Notes","text":"<p>1. Introduction</p> <p>The Render Props pattern is a powerful technique in React for sharing code between components using a prop whose value is a function.  Instead of directly managing child component logic within a parent, the parent passes a rendering function as a prop to its child.  This function receives data from the child component and is responsible for rendering the actual UI.  This approach promotes reusability, enhances readability, and improves maintainability, especially when dealing with complex components that require dynamic rendering based on state or data changes.  It's a more flexible alternative to higher-order components (HOCs) in many scenarios, offering a simpler, more direct way to achieve similar results.</p> <p>2. Core Concepts</p> <ul> <li> <p>The \"Render Prop\":  The core element of the pattern. This prop is a function that a parent component passes to its child. The child component calls this function, providing it with data or state information. The function then returns the JSX to be rendered.  This effectively allows the child to delegate rendering decisions to the parent.</p> </li> <li> <p>Data Flow: Data typically flows from the child component (which usually handles data fetching or complex logic) to the parent via the render prop. The parent then processes this data and uses it to control what gets rendered.</p> </li> <li> <p>Separation of Concerns: The pattern facilitates a clean separation of concerns. The child component focuses on fetching or manipulating data, while the parent handles the presentation layer.</p> </li> <li> <p>Reusability:  Components using the render prop are highly reusable. The parent component's logic (the rendering function) dictates how the data is presented, meaning the child can adapt to various display needs.</p> </li> <li> <p>Flexibility:  It allows for dynamic and conditional rendering based on the data received from the child.</p> </li> <li> <p>Composition over Inheritance: The render prop favors composition over inheritance, leading to a more flexible and maintainable codebase.</p> </li> </ul> <p>3. Practical Examples</p> <p>Example 1:  A reusable <code>DataFetcher</code> component</p> <pre><code>// DataFetcher.js\nconst DataFetcher = ({ url, render }) =&gt; {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() =&gt; {\n    const fetchData = async () =&gt; {\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const jsonData = await response.json();\n        setData(jsonData);\n      } catch (error) {\n        setError(error);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchData();\n  }, [url]);\n\n  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n  return render(data); // The render prop is called here\n};\n\n\n// Example usage:\nconst MyComponent = () =&gt; {\n  return (\n    &lt;DataFetcher url=\"/api/data\" render={(data) =&gt; (\n      &lt;ul&gt;\n        {data.map((item) =&gt; (\n          &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    )} /&gt;\n  );\n};\n</code></pre> <p>This <code>DataFetcher</code> component fetches data from a specified URL. The <code>render</code> prop allows the parent component (<code>MyComponent</code>) to determine how the fetched data is displayed, making <code>DataFetcher</code> versatile and reusable for various data presentations.</p> <p>Example 2:  A customizable <code>Button</code> component:</p> <pre><code>// CustomButton.js\nconst CustomButton = ({ render, onClick, ...props }) =&gt; {\n  return (\n      &lt;button onClick={onClick} {...props}&gt;\n        {render()}\n      &lt;/button&gt;\n  );\n};\n\n// Example usage:\nconst MyComponent = () =&gt; {\n    return (\n        &lt;CustomButton onClick={() =&gt; alert(\"Clicked!\")} render={() =&gt; &lt;span&gt;Click Me!&lt;/span&gt;} /&gt;\n    )\n}\n</code></pre> <p>Here, the <code>CustomButton</code> component uses the <code>render</code> prop to allow the parent to define the button's content, while keeping common button functionality (onClick, etc.) within the component itself.</p> <p>4. Conclusion</p> <p>The Render Props pattern provides a clean and elegant solution for sharing code and managing complex rendering logic in React applications. It promotes code reusability, readability, and maintainability, particularly when compared to more complex solutions like Higher-Order Components. By carefully separating data fetching/manipulation from the rendering logic, this pattern contributes to a more modular and scalable architecture, leading to improved development efficiency and maintainability in the long run.  While it might introduce a slight learning curve, the benefits it offers significantly outweigh the initial investment in understanding and applying this powerful pattern.</p>"},{"location":"notes/react/Rendering_Elements/","title":"Rendering Elements","text":""},{"location":"notes/react/Rendering_Elements/#rendering-elements-premium-study-notes","title":"Rendering Elements: Premium Study Notes","text":"<p>1. Introduction</p> <p>Rendering is the process of generating an image from a 2D or 3D model (or scene), often using a computer.  This encompasses a wide range of techniques, from simple 2D bitmap manipulation to complex 3D scene rendering involving realistic lighting, shadows, reflections, and refractions.  Understanding rendering elements is crucial for anyone working in computer graphics, game development, animation, or visual effects.  This document provides a concise overview of key concepts and practical examples to enhance your understanding of this fundamental aspect of computer graphics.</p> <p>2. Core Concepts</p> <p>Rendering involves several key stages and concepts:</p> <ul> <li> <p>Modeling:  Creating the 3D shapes and geometry that form the scene.  This is often done using software like Blender, Maya, or 3ds Max.  The quality of the model directly impacts the final rendered image.  Consider polygon count, texture resolution, and overall model complexity.</p> </li> <li> <p>Shading: Determining the color and appearance of surfaces within the scene. This involves calculating how light interacts with the surface's material properties (diffuse, specular, ambient reflection, etc.).  Different shading models exist, ranging from simple flat shading to sophisticated physically based rendering (PBR).  PBR aims to simulate realistic light interaction based on real-world physics.</p> </li> <li> <p>Lighting:  The illumination of the scene, crucial for establishing mood, depth, and realism.  Light sources can be directional (sun), point (light bulb), or area (softbox).  The number, type, and placement of light sources greatly influence the final render.  Techniques like global illumination (GI) simulate indirect lighting, enhancing realism by accounting for light bouncing off multiple surfaces.</p> </li> <li> <p>Texturing: Applying images or patterns to surfaces to add detail and realism.  Textures can be diffuse (color), normal (surface detail), specular (shininess), and more.  High-resolution textures significantly improve visual quality.</p> </li> <li> <p>Camera: Defines the viewpoint and perspective from which the scene is rendered. Parameters include field of view (FOV), position, and orientation.  The camera's perspective dictates what's visible and how the scene is presented.</p> </li> <li> <p>Materials: Define the physical properties of surfaces, influencing how they interact with light.  Key parameters include color, reflectivity, roughness, and transparency.  Materials significantly impact the overall realism and aesthetic quality of the rendered image.</p> </li> <li> <p>Anti-aliasing: Reduces the jagged appearance of edges in rendered images (aliasing).  Techniques like multisampling and supersampling smooth out these edges, producing cleaner visuals.</p> </li> <li> <p>Ray Tracing &amp; Rasterization:  Two fundamental rendering techniques.  Ray tracing simulates light rays bouncing through the scene, offering high realism but demanding computational power.  Rasterization, conversely, projects the 3D scene onto a 2D plane, pixel by pixel, generally faster but potentially less realistic in complex scenes.</p> </li> </ul> <p>3. Practical Examples</p> <ul> <li> <p>Simple Scene (Rasterization): Rendering a single sphere with a diffuse material under a point light source.  This demonstrates basic shading and lighting calculations.  The output will be a colored sphere with a highlight depending on the light's position.</p> </li> <li> <p>Complex Scene (Ray Tracing): A scene with multiple objects, reflective surfaces (mirrors), and refractive surfaces (glass).  Ray tracing accurately simulates reflections and refractions, creating a photorealistic image with indirect lighting effects (e.g., shadows cast by indirect light bounces).</p> </li> <li> <p>Real-time Rendering (Game Engine): A game scene with dynamic lighting, shadows, and character animation.  Real-time rendering prioritizes speed over absolute realism, using optimizations to achieve high frame rates.</p> </li> <li> <p>Offline Rendering (Film/Animation): High-quality, photorealistic render of a complex scene with meticulous attention to detail.  Offline renderers have significant processing power dedicated to achieving ultimate realism without real-time constraints.</p> </li> <li> <p>Importance of Normal Maps: Comparing a rendered sphere with and without a normal map.  The normal map adds surface detail, significantly improving the perceived realism and visual richness.</p> </li> </ul> <p>4. Conclusion</p> <p>Rendering is a multifaceted field requiring a solid understanding of various concepts and techniques.  From basic shading and lighting to advanced algorithms like ray tracing and global illumination, the pursuit of realism and visual fidelity constantly pushes the boundaries of computer graphics.  Mastering rendering elements allows for the creation of compelling visuals across numerous applications, from games and animation to scientific visualization and architectural design.  Continuous learning and experimentation with different tools and techniques are crucial for achieving mastery in this dynamic area.</p>"},{"location":"notes/react/Schema_Validation_with_Yup_or_Zod/","title":"Schema Validation with Yup or Zod","text":""},{"location":"notes/react/Schema_Validation_with_Yup_or_Zod/#schema-validation-with-yup-or-zod-study-notes","title":"Schema Validation with Yup or Zod: Study Notes","text":"<p>## 1. Introduction</p> <p>Schema validation is a crucial aspect of building robust and reliable applications.  It ensures data integrity by verifying that incoming data conforms to a predefined structure and type.  This prevents unexpected errors, improves data quality, and enhances security.  Two popular JavaScript libraries for schema validation are Yup and Zod.  Both offer similar functionality but differ in their approaches and features.  This document explores their core concepts and practical applications.</p> <p>Yup is a mature library with a more flexible and forgiving approach.  It leverages a builder-style API, offering a fluent and chainable interface.  However, this flexibility can sometimes lead to more verbose schemas.</p> <p>Zod, a newer library, prioritizes type safety and compile-time checks.  It utilizes a declarative approach, resulting in more concise and readable schemas. Zod also offers better TypeScript integration and stricter error handling.  The choice between Yup and Zod often depends on project requirements and developer preference, balancing flexibility against type safety.</p> <p>## 2. Core Concepts</p> <p>Both Yup and Zod revolve around the concept of defining a schema that specifies the structure and data types of your data. This schema acts as a blueprint against which input data is validated.  Key concepts common to both libraries include:</p> <ul> <li> <p>Schema Definition:  Defining the structure and data types of your data using a specific API (Yup's builder style vs Zod's declarative style).  This involves specifying fields, their types (string, number, boolean, array, object, etc.), and potential validation rules (required, min, max, email, etc.).</p> </li> <li> <p>Validation: The process of comparing the input data against the predefined schema. This results in either a successful validation (returning the validated data) or a validation error (indicating which parts of the data failed validation and why).</p> </li> <li> <p>Error Handling:  Managing validation errors gracefully. This includes providing informative error messages to users and handling errors within your application logic.  Both libraries provide mechanisms for accessing validation error details.</p> </li> <li> <p>Data Transformation: Some libraries allow you to perform data transformations during validation (e.g., trimming strings, converting types).  Both Yup and Zod offer ways to achieve this, albeit with slightly different syntax.</p> </li> </ul> <p>Specific to Yup:</p> <ul> <li>Builder Pattern: Yup uses a fluent API built upon a chain of methods to define schemas.  This allows for highly customizable validations.</li> <li><code>validateSync</code> and <code>validate</code>:  Synchronous and asynchronous validation methods respectively.</li> </ul> <p>Specific to Zod:</p> <ul> <li>Declarative Style: Zod utilizes a more declarative style, making schemas more concise and potentially easier to read.</li> <li>TypeScript Integration:  Zod is designed with strong TypeScript integration, providing compile-time type safety.</li> <li><code>parse</code> and <code>safeParse</code>:  Methods for parsing data against the schema, with <code>safeParse</code> providing a safer approach to handle errors.</li> </ul> <p>## 3. Practical Examples</p> <p>Example:  Validating a user registration form (using both Yup and Zod)</p> <p>Let's say we want to validate a user registration form with fields for name (required string), email (required string, must be a valid email), and age (required number, must be over 18).</p> <p>Yup:</p> <pre><code>const yup = require('yup');\n\nconst userSchema = yup.object({\n  name: yup.string().required('Name is required'),\n  email: yup.string().email('Invalid email').required('Email is required'),\n  age: yup.number().min(18, 'Must be at least 18 years old').required('Age is required'),\n});\n\nuserSchema.validate({ name: 'John Doe', email: 'john.doe@example.com', age: 25 })\n  .then(data =&gt; console.log('Validation successful:', data))\n  .catch(err =&gt; console.error('Validation failed:', err.errors));\n</code></pre> <p>Zod:</p> <pre><code>import { z } from 'zod';\n\nconst userSchema = z.object({\n  name: z.string().min(1, 'Name is required'),\n  email: z.string().email('Invalid email'),\n  age: z.number().min(18, 'Must be at least 18 years old'),\n});\n\nconst result = userSchema.parse({ name: 'John Doe', email: 'john.doe@example.com', age: 25 });\nconsole.log('Validation successful:', result);\n\nconst result2 = userSchema.safeParse({ name: 'John Doe', email: 'invalid-email', age: 10 });\nif(result2.success){\n    console.log('Validation successful:', result2.data);\n} else {\n    console.error('Validation failed:', result2.error.errors)\n}\n</code></pre> <p>## 4. Conclusion</p> <p>Both Yup and Zod are powerful tools for schema validation in JavaScript. Yup offers a flexible and fluent API, while Zod prioritizes type safety and compile-time checks, particularly beneficial for TypeScript projects.  The best choice depends on project-specific needs and developer preferences.  Consider the trade-offs between flexibility, type safety, and learning curve when making your decision.  For larger projects with a strong emphasis on type safety, Zod's features might be particularly advantageous.  For smaller projects or those requiring highly customized validation logic, Yup's flexibility might be preferred.</p>"},{"location":"notes/react/TanStack_Query_Caching_Stale-while-revalidate_Muta/","title":"TanStack Query Caching Stale while revalidate Muta","text":""},{"location":"notes/react/TanStack_Query_Caching_Stale-while-revalidate_Muta/#tanstack-query-caching-stale-while-revalidate-and-mutations-study-notes","title":"TanStack Query: Caching, Stale-while-revalidate, and Mutations - Study Notes","text":"<p>## 1. Introduction</p> <p>TanStack Query is a powerful data fetching library for JavaScript that simplifies asynchronous data management.  It excels at handling complex scenarios involving caching, background updates, and optimistic updates, leading to significantly improved user experiences. Unlike simpler approaches, TanStack Query proactively manages data fetching and caching, reducing boilerplate and improving application performance.  Its core strength lies in its sophisticated caching mechanisms and its ability to seamlessly integrate with various data sources (REST APIs, GraphQL, etc.). This document will delve into its core concepts, specifically focusing on caching, stale-while-revalidate, and mutations.</p> <p>## 2. Core Concepts</p> <p>2.1 Caching:</p> <p>TanStack Query's caching mechanism is central to its efficiency. It employs a normalized cache, meaning that data is stored based on unique keys.  This avoids redundancy and ensures data consistency.  Key features of the cache include:</p> <ul> <li>Automatic Cache Invalidation: When a query is executed again with the same key and parameters, TanStack Query checks the cache first. If a valid cached entry exists, it returns the cached data immediately, preventing unnecessary network requests.  The cache entry is considered \"stale\" after a configurable <code>staleTime</code> period.</li> <li>Cache Timeouts:  The <code>cacheTime</code> option sets a time limit for how long data remains valid in the cache, even if it's not stale.  After this period, the cache entry is removed regardless of its use.</li> <li>Query Keys:  These are unique identifiers for each query.  They are crucial for the cache to correctly identify and manage data.  Complex queries require carefully crafted keys that reflect all relevant parameters.</li> <li>Cache Invalidation Strategies: Beyond time-based invalidation, you can manually invalidate entries using <code>queryClient.invalidateQueries()</code>. This is particularly useful after mutations that affect data returned by other queries.</li> </ul> <p>2.2 Stale-while-revalidate (SWR):</p> <p>SWR is a crucial strategy for balancing responsiveness and data freshness. When a query is made:</p> <ol> <li>Stale Data Served:  If cached data exists (even if stale), it's immediately returned to the UI. This provides a snappy user experience with minimal perceived latency.</li> <li>Background Revalidation:  Simultaneously, TanStack Query fetches the latest data in the background.</li> <li>Update UI: Once the new data arrives, the UI is automatically updated, seamlessly transitioning to the fresh data.</li> </ol> <p>This approach drastically improves UX by preventing noticeable delays while ensuring data consistency eventually. The <code>staleTime</code> and <code>revalidateOnMount</code> options control the behavior of SWR.</p> <p>2.3 Mutations:</p> <p>Mutations represent changes to data (e.g., creating, updating, or deleting). TanStack Query offers several features to efficiently handle mutations:</p> <ul> <li>Optimistic Updates:  You can optimistically update the UI immediately after a mutation is initiated. This improves the perceived speed of the application.  The actual server response then confirms or corrects the optimistic update.</li> <li>Automatic Cache Invalidation:  After a successful mutation, TanStack Query can automatically invalidate relevant cached queries to ensure data consistency.  This prevents stale data from lingering in the UI.</li> <li><code>queryClient.setQueryData</code>:  This allows direct manipulation of the cache, which can be useful for complex scenarios, but should be used cautiously to maintain cache integrity.</li> <li><code>mutationCache</code>: A dedicated cache for mutations that can store the mutation status, error messages, and results.</li> </ul> <p>2.4 QueryClient:</p> <p>The <code>QueryClient</code> is the central hub for managing queries, mutations, and the cache. It provides methods for controlling the cache, executing queries, and handling mutations.  Properly configuring the <code>QueryClient</code> is essential for optimal performance.</p> <p>## 3. Practical Examples</p> <p>(Assume a React environment with TanStack Query installed.)</p> <p>3.1 Basic Query with SWR:</p> <pre><code>import { useQuery } from '@tanstack/react-query';\n\nfunction MyComponent() {\n  const { data, isLoading, isError, error } = useQuery(['todos'], fetchTodos);\n\n  if (isLoading) return &lt;p&gt;Loading...&lt;/p&gt;;\n  if (isError) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n\n  return (\n    &lt;ul&gt;\n      {data.map(todo =&gt; &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;)}\n    &lt;/ul&gt;\n  );\n}\n\nconst fetchTodos = async () =&gt; {\n  const res = await fetch('/api/todos');\n  return res.json();\n};\n</code></pre> <p>3.2 Mutation with Optimistic Update:</p> <pre><code>import { useMutation, useQueryClient } from '@tanstack/react-query';\n\nfunction AddTodo({onAdd}) {\n  const queryClient = useQueryClient();\n\n  const mutation = useMutation(addTodo, {\n    onSuccess: () =&gt; {\n      queryClient.invalidateQueries(['todos']); //Invalidate 'todos' query after success.\n    },\n  });\n\n  const handleSubmit = async (text) =&gt; {\n    await mutation.mutateAsync({text});\n  }\n  return( &lt;form onSubmit={(e) =&gt; {\n    e.preventDefault();\n    handleSubmit(e.target.elements.todoText.value)\n  }}&gt;\n  &lt;input type=\"text\" name=\"todoText\"/&gt;\n  &lt;button&gt;Add Todo&lt;/button&gt;\n  &lt;/form&gt;);\n}\n\nconst addTodo = async (newTodo) =&gt; {\n    const res = await fetch('/api/todos', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(newTodo),\n    });\n    return res.json();\n};\n</code></pre> <p>## 4. Conclusion</p> <p>TanStack Query is a highly effective library for managing asynchronous data in JavaScript applications. Its advanced caching mechanisms, especially SWR, significantly improve performance and user experience.  By understanding its core concepts, including query keys, cache invalidation, and optimistic updates, developers can build robust and efficient data fetching solutions. Mastering these concepts is crucial for building performant and scalable React applications.  The examples illustrate how to integrate TanStack Query into a React application, handling both queries and mutations effectively.  Further exploration of its advanced features, like background updates and active queries, will unlock even more potential for optimization.</p>"},{"location":"notes/react/Utility-First_CSS_Tailwind_CSS/","title":"Utility First CSS Tailwind CSS","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/Windowing_Virtualization_for_Large_Lists_react-win/","title":"Windowing Virtualization for Large Lists react win","text":""},{"location":"notes/react/Windowing_Virtualization_for_Large_Lists_react-win/#windowingvirtualization-for-large-lists-react-window","title":"Windowing/Virtualization for Large Lists (react-window)","text":"<p>## 1. Introduction</p> <p>Rendering extremely large lists (thousands or millions of items) in React directly can lead to significant performance issues.  The browser struggles to render and manage the DOM nodes for each item, causing lag, freezes, and ultimately a poor user experience.  Windowing, or virtualization, is a technique that optimizes rendering by only displaying and managing the items currently visible within the viewport.  Instead of rendering the entire list, it renders only a subset of items, significantly reducing the DOM size and improving performance.  <code>react-window</code> is a popular library that provides high-performance components for implementing windowing techniques in React applications.  It offers a variety of components suited for different use cases, handling both vertical and horizontal scrolling efficiently.  The core idea is to leverage the browser's ability to only render what's visible, drastically improving the user experience when dealing with extensive data sets.</p> <p>## 2. Core Concepts</p> <ul> <li> <p>Viewport: The visible area of the scrollable container.  Only the items within the viewport need to be rendered.</p> </li> <li> <p>Item Size:  The height (or width, for horizontal lists) of a single list item.  This can be fixed or variable, depending on the complexity of your list items. Consistent item sizes are generally more performant.</p> </li> <li> <p>Overscan:  Rendering a few extra items beyond the viewport's boundaries. This prevents jarring visual artifacts when scrolling quickly, as items are already rendered and ready to be displayed as the user scrolls.  The number of overscanned items is configurable.</p> </li> <li> <p>Item Key:  Unique identifiers for each list item.  React relies on keys for efficient updates and re-renders, making them crucial for performance and correct behavior.</p> </li> <li> <p><code>VariableSizeList</code> vs. <code>List</code>: <code>react-window</code> offers two primary components: <code>List</code> assumes a fixed item size, simplifying calculations, while <code>VariableSizeList</code> handles variable item sizes, requiring a function to calculate the size of each item.  Choosing the right component depends on the nature of your data.  <code>VariableSizeList</code> provides flexibility but comes with a slight performance overhead.</p> </li> <li> <p><code>FixedSizeList</code>: A more optimized version of <code>List</code> for cases where item sizes are truly fixed and known upfront.</p> </li> <li> <p><code>AutoSizer</code>:  A helper component that automatically detects the viewport's size and provides this information to the list component.  This simplifies handling window resizing and dynamic content.</p> </li> <li> <p>Performance Considerations:  While <code>react-window</code> drastically improves performance, there are still factors to consider.  Avoid complex calculations or expensive operations within the <code>itemData</code> prop passed to the <code>renderItem</code> function. Keep this rendering process lean.</p> </li> </ul> <p>## 3. Practical Examples</p> <p>Example 1: Fixed-size list using <code>List</code> and <code>AutoSizer</code>:</p> <pre><code>import { AutoSizer, List } from 'react-window';\n\nconst MyList = ({ items }) =&gt; (\n  &lt;AutoSizer&gt;\n    {({ height, width }) =&gt; (\n      &lt;List\n        height={height}\n        width={width}\n        itemCount={items.length}\n        itemSize={35} // Fixed height of 35px per item\n        itemData={items}\n      &gt;\n        {({ index, style }) =&gt; (\n          &lt;div style={style}&gt;\n            {items[index]}\n          &lt;/div&gt;\n        )}\n      &lt;/List&gt;\n    )}\n  &lt;/AutoSizer&gt;\n);\n</code></pre> <p>Example 2: Variable-size list using <code>VariableSizeList</code>:</p> <pre><code>import { AutoSizer, VariableSizeList } from 'react-window';\n\nconst MyVariableSizeList = ({ items }) =&gt; {\n  const getItemSize = (index) =&gt; {\n    // Calculate item height based on content, e.g., using item[index].length * 10\n    return items[index].length * 10;\n  };\n\n  return (\n    &lt;AutoSizer&gt;\n      {({ height, width }) =&gt; (\n        &lt;VariableSizeList\n          height={height}\n          width={width}\n          itemCount={items.length}\n          itemSize={getItemSize}\n          itemData={items}\n        &gt;\n          {({ index, style }) =&gt; (\n            &lt;div style={style}&gt;\n              {items[index]}\n            &lt;/div&gt;\n          )}\n        &lt;/VariableSizeList&gt;\n      )}\n    &lt;/AutoSizer&gt;\n  );\n};\n</code></pre> <p>## 4. Conclusion</p> <p><code>react-window</code> provides an efficient and straightforward solution for rendering large lists in React applications. By implementing windowing techniques, it drastically improves performance and user experience by rendering only the visible items. Understanding core concepts like viewport, item size, overscan, and choosing between <code>List</code> and <code>VariableSizeList</code> is crucial for optimal implementation.  <code>react-window</code> is a powerful tool for building scalable and performant React applications that handle massive datasets gracefully.  Remember to keep the rendering logic within the <code>renderItem</code> function as lean as possible for best performance.  The choice between <code>List</code> and <code>VariableSizeList</code> depends on the nature of your data; fixed-size lists offer better performance when applicable. Utilizing <code>AutoSizer</code> simplifies responsive behavior.</p>"},{"location":"notes/react/useEffect_Cleanup_Function/","title":"useEffect Cleanup Function","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/useMemo_Memoizing_Computed_Values/","title":"useMemo Memoizing Computed Values","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/useReducer_For_Complex_State_Logic/","title":"useReducer For Complex State Logic","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react/useState_Functional_updates_and_lazy_initial_state/","title":"useState Functional updates and lazy initial state","text":""},{"location":"notes/react/useState_Functional_updates_and_lazy_initial_state/#usestate-functional-updates-and-lazy-initial-state","title":"useState: Functional Updates and Lazy Initial State","text":"<p>## 1. Introduction</p> <p>React's <code>useState</code> hook is a fundamental tool for managing state within functional components.  It allows components to hold internal state and re-render when that state changes.  However, effectively using <code>useState</code> involves understanding two key aspects often overlooked: functional updates and lazy initial state.  This document explores these concepts, highlighting best practices and potential pitfalls.  Mastering these concepts is crucial for writing clean, efficient, and predictable React applications, particularly as component complexity increases.</p> <p>## 2. Core Concepts</p> <p>2.1 Functional Updates:</p> <p>The <code>useState</code> hook accepts a function as its second argument. This function receives the current state value as an argument and returns the new state value. This approach, known as a functional update, is crucial for ensuring state updates are consistent, especially when dealing with asynchronous operations or complex state transformations.</p> <ul> <li> <p>Why functional updates?  When the state update depends on the previous state value, using a direct assignment (<code>setState(prevState + 1)</code>) can lead to unexpected behavior.  Imagine multiple state updates occurring rapidly; direct assignment could use outdated <code>prevState</code> values, resulting in incorrect state. Functional updates guarantee that the update always operates on the latest state.</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () =&gt; {\n    // Correct: Functional update\n    setCount(prevCount =&gt; prevCount + 1); \n  };\n\n  const decrement = () =&gt; {\n    // Correct: Functional update, handles potential negative values\n    setCount(prevCount =&gt; Math.max(0, prevCount - 1));\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n      &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>2.2 Lazy Initial State:</p> <p>The initial value provided to <code>useState</code> can be a function. This function is only executed once, when the component initially mounts.  This allows for performing expensive computations or fetching data only when necessary, improving initial render performance.</p> <ul> <li> <p>Why lazy initial state?  If your initial state involves complex calculations or API calls, delaying this computation until the component mounts avoids blocking the initial render.  This leads to a smoother user experience, particularly in larger applications.</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>import React, { useState } from 'react';\n\nfunction ExpensiveComponent() {\n  const [data, setData] = useState(() =&gt; {\n    // Simulate expensive computation\n    console.log('Fetching data...');\n    const expensiveData = fetchExpensiveData(); // Replace with your actual data fetching logic\n    return expensiveData;\n  });\n\n  return (\n    &lt;div&gt;\n      {/* Render data */}\n      {data &amp;&amp; &lt;p&gt;Data: {JSON.stringify(data)}&lt;/p&gt;}\n    &lt;/div&gt;\n  );\n}\n\nfunction fetchExpensiveData() {\n    // Simulate an expensive data fetching process.  Replace with your actual implementation\n    return new Promise(resolve =&gt; {\n        setTimeout(() =&gt; resolve({ message: 'Data fetched!' }), 2000);\n    }).then(data =&gt; data);\n}\n</code></pre> <p>## 3. Practical Examples</p> <p>3.1.  Form Handling:</p> <p>Functional updates are essential when managing form input.  Avoid direct assignments to ensure updates are based on the most recent input value.</p> <pre><code>const [name, setName] = useState('');\nconst handleChange = (event) =&gt; setName(prevName =&gt; event.target.value);\n</code></pre> <p>3.2. Asynchronous Operations:</p> <p>When updating state based on API responses, functional updates prevent race conditions.  The function ensures the update utilizes the latest response data.</p> <pre><code>const [userData, setUserData] = useState(null);\nuseEffect(() =&gt; {\n  fetchUserData().then(data =&gt; setUserData(prevData =&gt; data));\n}, []);\n</code></pre> <p>3.3. Complex State Objects:</p> <p>For nested objects,  it is good practice to use the spread operator (<code>...</code>) within the functional update to avoid accidentally mutating the state:</p> <pre><code>const [user, setUser] = useState({ name: '', age: 0 });\nconst updateName = (newName) =&gt; setUser(prevUser =&gt; ({ ...prevUser, name: newName }));\n</code></pre> <p>## 4. Conclusion</p> <p><code>useState</code> is a powerful tool, but its full potential is unlocked by understanding and consistently applying functional updates and lazy initial state. Functional updates guarantee data consistency in complex scenarios, preventing race conditions and unexpected behavior. Lazy initial state optimizes performance by delaying expensive computations until necessary. By mastering these techniques, developers can build more robust, efficient, and maintainable React applications.  Remember to always prefer functional updates when the new state depends on the previous state to prevent subtle bugs in complex or concurrent scenarios.  For large initial state objects or processes, lazy initialization improves performance. Using these strategies together will lead to cleaner and more predictable code.</p>"},{"location":"notes/react-native/Accessing_Device_Permissions_Camera_Location_etc/","title":"Accessing Device Permissions Camera Location etc","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react-native/Animations_Animated_API_Reanimated/","title":"Animations Animated API Reanimated","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react-native/Bridging_Native_Modules_Java_Kotlin_for_Android_Sw/","title":"Bridging Native Modules Java Kotlin for Android Sw","text":""},{"location":"notes/react-native/Bridging_Native_Modules_Java_Kotlin_for_Android_Sw/#bridging-native-modules-javakotlin-for-android-swiftobjective-c-for-ios","title":"Bridging Native Modules (Java/Kotlin for Android, Swift/Objective-C for iOS)","text":"<p>Study Notes</p>"},{"location":"notes/react-native/Bridging_Native_Modules_Java_Kotlin_for_Android_Sw/#1-introduction","title":"1. Introduction","text":"<p>Bridging native modules involves connecting code written in different programming languages within a mobile application.  Specifically, this often refers to linking Java/Kotlin (Android) and Swift/Objective-C (iOS) code to create hybrid applications that leverage the strengths of both platforms.  Native modules offer performance advantages over purely cross-platform solutions like React Native or Flutter, particularly for computationally intensive tasks or when direct access to platform-specific APIs is required.  However, bridging introduces complexities related to data marshaling, memory management, and platform-specific quirks.  This necessitates a thorough understanding of the underlying mechanisms and potential pitfalls.  This document aims to provide a comprehensive overview of bridging native modules for Android and iOS development.</p>"},{"location":"notes/react-native/Bridging_Native_Modules_Java_Kotlin_for_Android_Sw/#2-core-concepts","title":"2. Core Concepts","text":"<p>Several key concepts underpin bridging native modules:</p> <ul> <li> <p>Inter-Process Communication (IPC): While not always explicitly implemented as separate processes, the fundamental principle is communication between distinct codebases.  This communication typically involves serialized data exchange.</p> </li> <li> <p>Data Marshaling:  Converting data structures between Java/Kotlin and Swift/Objective-C requires careful consideration.  Basic data types (integers, floats, booleans) are relatively straightforward, but complex objects require careful mapping and serialization (often using JSON or Protocol Buffers).</p> </li> <li> <p>Native Interfaces:  These define the contracts between the native and bridging code.  On Android, this often involves defining Java/Kotlin interfaces and implementing them in the native module. On iOS, this commonly utilizes Objective-C's header files (.h) to declare methods and their parameters, which are then implemented in Swift or Objective-C.</p> </li> <li> <p>Method Channels (Flutter-inspired approach):  While not a direct native-to-native bridge, method channels (popularized by Flutter) offer a structured approach to IPC.  They involve sending messages between the platform-specific code and a common, platform-agnostic layer.  This provides a degree of abstraction and simplifies the bridging process, even for native-to-native interaction.</p> </li> <li> <p>Memory Management:  Careful management is crucial to avoid memory leaks.  Understanding the different memory management paradigms of Java/Kotlin (garbage collection) and Swift/Objective-C (ARC/manual memory management) is paramount.  Proper object ownership and lifecycle management are essential to prevent crashes and ensure application stability.</p> </li> <li> <p>Error Handling:  A robust error handling strategy is vital.  Errors originating in the native module must be gracefully handled and propagated back to the calling code.</p> </li> </ul>"},{"location":"notes/react-native/Bridging_Native_Modules_Java_Kotlin_for_Android_Sw/#3-practical-examples","title":"3. Practical Examples","text":"<p>3.1 Android (Java/Kotlin):</p> <p>Let's assume we have a native C++ library that performs image processing.</p> <ol> <li> <p>JNI (Java Native Interface):  The JNI is the primary mechanism for interacting with native code on Android. We would create a Java/Kotlin interface defining methods to call into the C++ library.</p> </li> <li> <p>Native Library Implementation: The C++ code implements the functions declared in the JNI interface.  Data is marshaled between Java/Kotlin and C++ using JNI functions.</p> </li> <li> <p>Build Process:  The C++ code is compiled into a shared library (.so file) and integrated into the Android project.</p> </li> </ol> <p>Example (Conceptual):</p> <ul> <li>Java Interface:</li> </ul> <pre><code>public interface ImageProcessor {\n    Bitmap processImage(Bitmap input);\n}\n</code></pre> <ul> <li>C++ Implementation (simplified):</li> </ul> <pre><code>extern \"C\" JNIEXPORT jobject JNICALL\nJava_com_example_imageprocessor_ImageProcessorImpl_processImage(JNIEnv *env, jobject thiz, jobject bitmap) {\n  // ... C++ image processing logic ...\n  return processedBitmap; // Return processed Bitmap\n}\n</code></pre> <p>3.2 iOS (Swift/Objective-C):</p> <p>Suppose we want to access device sensors using Objective-C from Swift.</p> <ol> <li> <p>Objective-C Header File (.h):  Define the interface in an Objective-C header file.</p> </li> <li> <p>Objective-C Implementation (.m):  Implement the methods in an Objective-C file.</p> </li> <li> <p>Swift Bridging Header:  Import the Objective-C header file into your Swift code using a bridging header.</p> </li> </ol> <p>Example (Conceptual):</p> <ul> <li>Objective-C Header (SensorManager.h):</li> </ul> <pre><code>#import &lt;Foundation/Foundation.h&gt;\n\n@interface SensorManager : NSObject\n\n- (float)getAccelerometerX;\n\n@end\n</code></pre> <ul> <li>Objective-C Implementation (SensorManager.m):</li> </ul> <pre><code>#import \"SensorManager.h\"\n#import &lt;CoreMotion/CoreMotion.h&gt;\n\n@implementation SensorManager {\n    CMMotionManager *_motionManager;\n}\n\n// ... Implementation using CoreMotion ...\n@end\n</code></pre> <ul> <li>Swift Usage:</li> </ul> <pre><code>import UIKit\n\nlet sensorManager = SensorManager()\nlet accelerometerX = sensorManager.getAccelerometerX()\n</code></pre>"},{"location":"notes/react-native/Bridging_Native_Modules_Java_Kotlin_for_Android_Sw/#4-conclusion","title":"4. Conclusion","text":"<p>Bridging native modules offers a powerful approach to creating high-performance hybrid mobile applications. However, it demands a solid understanding of the underlying concepts, including data marshaling, memory management, and the nuances of each platform's development environment.  Careful planning, meticulous code design, and robust error handling are crucial for developing stable and maintainable applications.  While complexities exist, the benefits of utilizing native code for performance-critical tasks or accessing platform-specific features often outweigh the challenges.  Choosing the appropriate bridging technique (JNI, method channels, etc.) depends on the specific requirements and project architecture.  Thorough testing across different devices and iOS/Android versions is vital to ensure compatibility and stability.</p>"},{"location":"notes/react-native/Building_for_Android_APKs_App_Bundles/","title":"Building for Android APKs App Bundles","text":""},{"location":"notes/react-native/Building_for_Android_APKs_App_Bundles/#building-for-android-apks-app-bundles","title":"Building for Android (APKs, App Bundles)","text":"<p>1. Introduction</p> <p>Android application packages (APKs) and Android App Bundles are the two primary ways to distribute Android applications.  Understanding their differences and how to build each is crucial for any Android developer.  Historically, APKs were the sole method, but Google introduced App Bundles to optimize app size and improve user experience by allowing Google Play to serve only the necessary code and resources for a specific device. This leads to smaller downloads, reduced storage space usage on devices, and improved performance.  This document will detail both approaches, highlighting their strengths and weaknesses.</p> <p>2. Core Concepts</p> <ul> <li> <p>APK (Android Package Kit): An APK is a single file containing all the code, resources, assets, and manifest file needed to install and run an Android application on a specific device configuration (e.g., screen density, ABI).  This means a single APK caters to only one set of device characteristics.  Creating multiple APKs for different configurations is cumbersome and inefficient.</p> </li> <li> <p>App Bundle: An App Bundle is a publishing format that contains all your app\u2019s compiled code and resources.  However, instead of directly installing on a device, it's uploaded to Google Play. Google Play then uses its dynamic delivery system to generate and serve optimized APKs for each user's device, based on their device's characteristics (architecture, screen density, language, etc.).  This significantly reduces the size of the download and installation for each user.</p> </li> <li> <p>Dynamic Delivery: The core mechanism behind App Bundles.  It allows Google Play to generate and serve only the parts of your app that are necessary for a specific device, resulting in smaller downloads and reduced storage space. This process leverages the modularization features of Android development.</p> </li> <li> <p>Modules (App Bundles): App Bundles can be structured into modules, allowing you to separate features or functionalities into distinct components.  This enables on-demand feature delivery where users can download features only when they need them, further improving the download size and storage efficiency.  Base modules are always downloaded initially, while dynamic features can be downloaded later.</p> </li> <li> <p>Android Studio Build System (Gradle): The build system that manages the creation of both APKs and App Bundles.  Gradle scripts (build.gradle) define the build process, including dependencies, configurations, and signing information.</p> </li> <li> <p>Signing: Both APKs and App Bundles need to be signed with a digital certificate to verify their authenticity and prevent tampering.  A debug keystore is used for development and testing, while a release keystore is necessary for publishing on Google Play.</p> </li> <li> <p>Split APKs:  While deprecated in favor of App Bundles, split APKs were a way to create multiple APKs for different device configurations (e.g., different screen densities). They were a manual approach to achieving similar benefits to App Bundles, but far less efficient and manageable.</p> </li> </ul> <p>3. Practical Examples</p> <ul> <li> <p>Building an APK:  In Android Studio, building an APK is usually straightforward.  Simply select the \"Build\" -&gt; \"Generate Signed Bundle / APK\" option in the menu.  You will then be guided through the signing process and selecting the build variant (e.g., release or debug).</p> </li> <li> <p>Building an App Bundle: The process is similar to building an APK. Select the \"Build\" -&gt; \"Generate Signed Bundle / APK\" option, but choose \"Android App Bundle\" as the output format.</p> </li> <li> <p>Implementing Modules (App Bundle):  Defining modules requires modifying your <code>build.gradle</code> files.  You'll need to create separate modules for your base app and any dynamic features.  Gradle handles the packaging and distribution of these modules within the App Bundle.  Refer to the official Android documentation for detailed instructions.</p> </li> <li> <p>Example Gradle snippet for dynamic features (simplified):</p> </li> </ul> <pre><code>android {\n    ...\n    dynamicFeatures = [':featureModuleA', ':featureModuleB']\n}\n</code></pre> <p>4. Conclusion</p> <p>App Bundles are the recommended approach for distributing Android applications.  They significantly improve the user experience by optimizing download sizes and reducing storage consumption.  While building APKs is still possible, it's generally considered less efficient and should only be used in specific scenarios (e.g., internal testing where Google Play services are unavailable).  Understanding the differences between APKs and App Bundles, and mastering the use of Android Studio's build system and dynamic delivery, is essential for modern Android development practices.  Prioritizing App Bundles will result in a better user experience and more efficient app delivery.</p>"},{"location":"notes/react-native/Building_for_iOS_TestFlight_App_Store/","title":"Building for iOS TestFlight App Store","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react-native/Drawer_Navigator_for_side_menus/","title":"Drawer Navigator for side menus","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react-native/Environment_variables_for_different_build_types/","title":"Environment variables for different build types","text":""},{"location":"notes/react-native/Environment_variables_for_different_build_types/#environment-variables-for-different-build-types","title":"Environment Variables for Different Build Types","text":"<p>1. Introduction</p> <p>Environment variables provide a powerful mechanism to customize application behavior without modifying source code.  This is particularly useful in software development, where different build types (e.g., development, testing, staging, production) require distinct configurations.  By leveraging environment variables, developers can manage settings like database credentials, API keys, URLs, and feature flags seamlessly across various environments. This eliminates the need for manual code changes for each environment, reducing errors and improving maintainability.  This document explores the crucial role of environment variables in managing build type-specific configurations.</p> <p>2. Core Concepts</p> <ul> <li> <p>Environment Variables:  These are dynamic named values accessible by the operating system and applications. They are typically set outside the application code, allowing for easy modification without recompilation. Common ways to set them include system-level configuration (e.g., <code>.bashrc</code>, <code>.zshrc</code>), build systems (e.g., Makefiles, Gradle), or environment variable managers (e.g., dotenv).</p> </li> <li> <p>Build Types: Different stages of the software development lifecycle often necessitate distinct settings. Common build types include:</p> <ul> <li>Development: Used by developers during coding and debugging; often connects to local databases or uses mock services.  Prioritizes ease of development and rapid iteration.</li> <li>Testing: Used for automated testing; connects to testing databases and utilizes testing environments to mimic production as closely as possible.  Focuses on verifying functionality and identifying bugs.</li> <li>Staging: A pre-production environment closely resembling production; used for final testing and user acceptance testing (UAT) before release.  Mirrors production infrastructure and data.</li> <li>Production: The live environment accessible to end-users; configured for optimal performance, security, and stability.  Prioritizes reliability and scalability.</li> </ul> </li> <li> <p>Variable Scope: Environment variables can have different scopes, impacting their accessibility.  They can be system-wide (affecting all processes), user-specific (affecting only a particular user's processes), or process-specific (affecting only a single application instance).  Understanding scope is critical for managing variable visibility and avoiding conflicts.</p> </li> <li> <p>Best Practices:</p> <ul> <li>Use a consistent naming convention: (e.g., <code>APP_</code> prefix for application-specific variables, <code>DB_</code> for database variables).</li> <li>Store sensitive information securely: Avoid hardcoding secrets directly; use secure methods like dedicated secret management services (e.g., AWS Secrets Manager, HashiCorp Vault).</li> <li>Leverage environment variable managers: These simplify managing and loading environment variables across different environments.</li> <li>Employ configuration management tools:  Tools like Ansible, Puppet, or Chef automate the deployment and configuration of environment variables across servers.</li> <li>Document all environment variables:  Include their purpose, data type, and allowed values.</li> </ul> </li> </ul> <p>3. Practical Examples</p> <p>Example 1: Node.js with dotenv</p> <pre><code>// .env file (for development)\nDATABASE_URL=localhost:5432/mydb_dev\nAPI_KEY=dev_api_key\n\n// .env.production file\nDATABASE_URL=productiondb.example.com:5432/mydb_prod\nAPI_KEY=prod_api_key\n\n// index.js\nrequire('dotenv').config(); // Loads environment variables from .env\n\nconst databaseUrl = process.env.DATABASE_URL;\nconst apiKey = process.env.API_KEY;\n\nconsole.log(\"Database URL:\", databaseUrl);\nconsole.log(\"API Key:\", apiKey);\n</code></pre> <p>This example demonstrates using <code>dotenv</code> to load environment variables from different <code>.env</code> files depending on the environment.  In production, one would use <code>.env.production</code>, while in development, the default <code>.env</code> would be loaded.</p> <p>Example 2: Python with <code>os.environ</code></p> <pre><code>import os\n\ndatabase_url = os.environ.get(\"DATABASE_URL\")\napi_key = os.environ.get(\"API_KEY\")\n\nif database_url and api_key:\n    print(f\"Database URL: {database_url}\")\n    print(f\"API Key: {api_key}\")\nelse:\n    print(\"Missing environment variables.\")\n</code></pre> <p>This Python example uses <code>os.environ</code> to access environment variables directly.  The <code>get()</code> method provides a safe way to access variables, handling cases where a variable might not be set.</p> <p>Example 3: Setting environment variables in a shell script (Bash)</p> <pre><code>export DATABASE_URL=\"localhost:5432/mydb_dev\"\nexport API_KEY=\"dev_api_key\"\n./my_application\n</code></pre> <p>This shows how to set environment variables directly within a shell script before running the application.  These variables will be available to the application during execution.</p> <p>4. Conclusion</p> <p>Effective management of environment variables is crucial for building robust and maintainable applications. By separating configuration from code and utilizing best practices, developers can streamline the deployment process across various build types.  Adopting tools and techniques for secure storage and management of sensitive information is essential for maintaining application security. Utilizing techniques shown above helps ensure that applications adapt seamlessly to different environments without compromising code integrity or security.</p>"},{"location":"notes/react-native/Fetching_data_with_the_Fetch_API_or_Axios/","title":"Fetching data with the Fetch API or Axios","text":""},{"location":"notes/react-native/Fetching_data_with_the_Fetch_API_or_Axios/#fetching-data-with-the-fetch-api-and-axios-study-notes","title":"Fetching Data with the Fetch API and Axios: Study Notes","text":"<p>## 1. Introduction</p> <p>Fetching data from external APIs is a fundamental aspect of modern web development.  Two popular methods for achieving this are the built-in <code>fetch</code> API and the widely-used Axios library.  Both provide ways to make HTTP requests (GET, POST, PUT, DELETE, etc.) to retrieve or send data to servers. While <code>fetch</code> is a native browser API, Axios offers additional features and conveniences, making it a preferred choice in many projects.  This document explores both, highlighting their similarities and differences.</p> <p>## 2. Core Concepts</p> <p>A. The Fetch API:</p> <ul> <li>Promises: <code>fetch</code> returns a Promise, which resolves to a <code>Response</code> object.  This <code>Response</code> object contains the HTTP status code and methods to access the response body (typically in JSON format).  You then need to use <code>.json()</code> (or <code>.text()</code>, <code>.blob()</code>, etc.) to parse the body into a usable format.</li> <li>Methods: Supports all standard HTTP methods (GET, POST, PUT, DELETE, etc.) through the <code>method</code> option in the request.</li> <li>Headers:  HTTP headers (like <code>Content-Type</code>) are set using the <code>headers</code> option.</li> <li>Body:  Data to send with POST, PUT, etc. requests are included in the <code>body</code> option, often as a JSON stringified object.</li> <li>Error Handling:  Promise <code>.catch()</code> handles network errors or non-2xx HTTP status codes.  You should always check the <code>Response</code> object's <code>ok</code> property (true if status code is 2xx) before accessing the body.</li> </ul> <p>B. Axios:</p> <ul> <li>Promises: Similar to <code>fetch</code>, Axios returns a Promise that resolves to a response object containing data, status, headers, etc.  Error handling is also done via <code>.catch()</code>.</li> <li>Simplified Syntax: Generally considered easier to use than <code>fetch</code> due to its more intuitive API and built-in JSON transformation.</li> <li>Automatic JSON Transformation: Axios automatically parses JSON responses, eliminating the need for <code>.json()</code> as in <code>fetch</code>.</li> <li>Interceptors: Axios provides request and response interceptors, allowing you to modify requests before they are sent (e.g., adding authentication tokens) and responses before they are handled (e.g., error handling).</li> <li>Built-in features:  Handles various request configurations (timeout, progress, etc.) more seamlessly than <code>fetch</code>.</li> <li>Cancellation: Axios allows you to cancel pending requests. This is not directly available with <code>fetch</code>.</li> </ul> <p>## 3. Practical Examples</p> <p>A. Fetch API:</p> <pre><code>fetch('https://api.example.com/data')\n  .then(response =&gt; {\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response.json();\n  })\n  .then(data =&gt; {\n    console.log('Data:', data);\n  })\n  .catch(error =&gt; {\n    console.error('There has been a problem with your fetch operation:', error);\n  });\n\n\n// POST request with Fetch API\nfetch('https://api.example.com/data', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({ key1: 'value1', key2: 'value2' }),\n})\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n.catch(error =&gt; console.error('Error:', error));\n</code></pre> <p>B. Axios:</p> <pre><code>axios.get('https://api.example.com/data')\n  .then(response =&gt; {\n    console.log('Data:', response.data);\n  })\n  .catch(error =&gt; {\n    console.error('Error:', error);\n  });\n\n// POST request with Axios\naxios.post('https://api.example.com/data', { key1: 'value1', key2: 'value2' })\n  .then(response =&gt; {\n    console.log('Response data:', response.data);\n  })\n  .catch(error =&gt; {\n    console.error('Error:', error);\n  });\n</code></pre> <p>## 4. Conclusion</p> <p>Both <code>fetch</code> and Axios are powerful tools for fetching data.  <code>fetch</code> is a native browser API and is a good choice for simple applications where its features are sufficient. However, Axios provides a more streamlined and feature-rich experience, particularly in larger projects where features like interceptors, automatic JSON parsing, and request cancellation are valuable. The choice depends on project needs and developer preference; Axios is often favoured for its ease of use and extra features, but understanding the core principles of <code>fetch</code> is crucial for any web developer.  Remember to always handle errors gracefully in your applications to ensure robustness.</p>"},{"location":"notes/react-native/Geolocation_and_Maps/","title":"Geolocation and Maps","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react-native/Handling_User_Input_TextInput_TouchableOpacity/","title":"Handling User Input TextInput TouchableOpacity","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react-native/Layout_with_Flexbox/","title":"Layout with Flexbox","text":""},{"location":"notes/react-native/Layout_with_Flexbox/#flexbox-layout-premium-study-notes","title":"Flexbox Layout: Premium Study Notes","text":"<p>## 1. Introduction</p> <p>Flexbox (Flexible Box Layout) is a powerful CSS layout module designed to simplify the process of arranging items in one dimension (either a row or a column).  Unlike traditional layout methods like floats and tables, Flexbox offers a more intuitive and flexible approach, particularly for arranging items within a container.  Its primary strength lies in its ability to handle dynamic content and responsive design needs efficiently.  Understanding Flexbox is crucial for modern web development as it underpins many responsive and adaptable UI designs.  This document will cover the fundamental concepts and provide practical examples to solidify your understanding.</p> <p>## 2. Core Concepts</p> <p>Flexbox operates on two axes:</p> <ul> <li> <p>Flex Container: This is the parent element that holds the flex items. It's defined using the <code>display: flex;</code> or <code>display: inline-flex;</code> property.  <code>display: flex;</code> makes the container a block-level element, while <code>display: inline-flex;</code> makes it inline.</p> </li> <li> <p>Flex Items: These are the children of the flex container. They are automatically arranged according to the container's properties.</p> </li> </ul> <p>Key Flex Container Properties:</p> <ul> <li> <p><code>flex-direction</code>: Controls the direction of the items' layout.  Options include:</p> <ul> <li><code>row</code> (default): Items are placed side-by-side horizontally.</li> <li><code>row-reverse</code>: Items are placed side-by-side horizontally, in reverse order.</li> <li><code>column</code>: Items are placed vertically, one below the other.</li> <li><code>column-reverse</code>: Items are placed vertically, in reverse order.</li> </ul> </li> <li> <p><code>flex-wrap</code>: Determines what happens when items exceed the container's size.</p> <ul> <li><code>nowrap</code> (default): Items remain on a single line, potentially overflowing.</li> <li><code>wrap</code>: Items wrap onto multiple lines.</li> <li><code>wrap-reverse</code>: Items wrap onto multiple lines, in reverse order.</li> </ul> </li> <li> <p><code>justify-content</code>:  Controls the alignment of items along the main axis (horizontal for <code>row</code>, vertical for <code>column</code>). Options include:</p> <ul> <li><code>flex-start</code> (default): Items align to the start of the container.</li> <li><code>flex-end</code>: Items align to the end of the container.</li> <li><code>center</code>: Items are centered along the main axis.</li> <li><code>space-between</code>: Items are evenly distributed with space between them.</li> <li><code>space-around</code>: Items are evenly distributed with space around them.</li> <li><code>space-evenly</code>: Items are evenly distributed with equal space between them and at the edges.</li> </ul> </li> <li> <p><code>align-items</code>: Controls the alignment of items along the cross axis (vertical for <code>row</code>, horizontal for <code>column</code>). Options include:</p> <ul> <li><code>flex-start</code>: Items align to the start of the container.</li> <li><code>flex-end</code>: Items align to the end of the container.</li> <li><code>center</code>: Items are centered along the cross axis.</li> <li><code>stretch</code> (default): Items stretch to fill the container's height.</li> <li><code>baseline</code>: Items align their text baselines.</li> </ul> </li> <li> <p><code>align-content</code>:  Controls the alignment of multiple lines of flex items when <code>flex-wrap</code> is <code>wrap</code>. Options mirror <code>justify-content</code>.</p> </li> </ul> <p>Key Flex Item Properties:</p> <ul> <li> <p><code>order</code>: Controls the order of items within the container. Lower numbers appear first.</p> </li> <li> <p><code>flex-grow</code>: Specifies how much an item should grow relative to other items when space allows.  A value of <code>1</code> means the item will grow proportionally to available space.</p> </li> <li> <p><code>flex-shrink</code>: Specifies how much an item should shrink relative to other items when space is constrained.</p> </li> <li> <p><code>flex-basis</code>: Specifies the initial size of an item before any growing or shrinking occurs.  Can be a length (e.g., <code>100px</code>) or a percentage (e.g., <code>20%</code>).  The shorthand <code>flex</code> property combines <code>flex-grow</code>, <code>flex-shrink</code>, and <code>flex-basis</code> (e.g., <code>flex: 1 1 200px</code>).</p> </li> <li> <p><code>align-self</code>: Overrides the <code>align-items</code> property for a specific item. Options are the same as <code>align-items</code>.</p> </li> </ul> <p>## 3. Practical Examples</p> <p>(Code examples would be included here, demonstrating different flexbox properties and their effects.  Each example should clearly illustrate a specific concept, such as centering items, wrapping items, distributing space evenly, and controlling item order.)  For instance:</p> <p>Example 1: Centering an item:</p> <pre><code>&lt;div style=\"display: flex; justify-content: center; align-items: center; height: 200px;\"&gt;\n  &lt;div style=\"background-color: lightblue; width: 100px; height: 100px;\"&gt;Centered Item&lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Example 2:  Two-column layout with wrapping:</p> <pre><code>&lt;div style=\"display: flex; flex-wrap: wrap;\"&gt;\n  &lt;div style=\"background-color: lightcoral; width: 100px; height: 100px;\"&gt;Item 1&lt;/div&gt;\n  &lt;div style=\"background-color: lightgreen; width: 100px; height: 100px;\"&gt;Item 2&lt;/div&gt;\n  &lt;div style=\"background-color: lightskyblue; width: 100px; height: 100px;\"&gt;Item 3&lt;/div&gt;\n  &lt;div style=\"background-color: lightpink; width: 100px; height: 100px;\"&gt;Item 4&lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>(Further examples with varying combinations of properties should be added here)</p> <p>## 4. Conclusion</p> <p>Flexbox provides a powerful and efficient way to manage layouts in modern web development. By mastering the key properties and their interactions, you can create responsive and dynamic designs with ease.  Remember to practice with different combinations of properties and scenarios to solidify your understanding and develop your ability to create complex and elegant layouts.  Utilizing developer tools in your browser to inspect existing flexbox implementations is also a valuable learning technique.  This will help you deconstruct existing designs and learn from successful applications of Flexbox.</p>"},{"location":"notes/react-native/Offline_support_and_data_synchronization/","title":"Offline support and data synchronization","text":""},{"location":"notes/react-native/Offline_support_and_data_synchronization/#offline-support-and-data-synchronization-premium-study-notes","title":"Offline Support and Data Synchronization: Premium Study Notes","text":"<p>1. Introduction</p> <p>Offline support and data synchronization are crucial features for modern applications, particularly those designed for mobile devices or environments with unreliable network connectivity.  They allow users to access and interact with data even without a persistent internet connection, enhancing usability and improving the user experience.  This seamless transition between online and offline modes requires careful design and implementation, involving considerations of data storage, conflict resolution, and efficient synchronization mechanisms.  Understanding the underlying principles and techniques is essential for developers building robust and resilient applications.</p> <p>2. Core Concepts</p> <ul> <li> <p>Data Storage: This refers to how data is persistently stored locally on the device when offline.  Common approaches include:</p> <ul> <li>Local Databases:  SQLite is a popular choice for its lightweight nature and ease of integration. Other options include Realm or embedded NoSQL databases.  These offer structured data storage and querying capabilities.</li> <li>File Storage:  Simpler for unstructured data (e.g., images, videos).  JSON or other formats can be used to represent structured data within files.</li> <li>Caching:  Storing frequently accessed data in memory (RAM) for extremely fast retrieval. This is ephemeral and data is lost on app closure unless persisted elsewhere.</li> </ul> </li> <li> <p>Synchronization Mechanisms:  These define how data is exchanged between the local device and a remote server.  Key aspects include:</p> <ul> <li>Pull Synchronization: The device requests updates from the server.  Suitable for applications where data changes infrequently on the server.</li> <li>Push Synchronization: The server actively pushes updates to the device.  Ideal for real-time applications requiring immediate updates.</li> <li>Bi-directional Synchronization:  Data changes made locally and on the server are synchronized in both directions.  Requires robust conflict resolution mechanisms.</li> </ul> </li> <li> <p>Conflict Resolution:  This is crucial for bi-directional synchronization. Strategies include:</p> <ul> <li>Last-Write-Wins (LWW): The most recent update overwrites previous versions. Simple but can lead to data loss.</li> <li>Timestamp-Based:  Resolves conflicts based on timestamps, prioritizing the most recent update.</li> <li>Merge Strategies:  Attempts to combine changes intelligently, potentially requiring human intervention in complex cases.  This is generally the most complex but offers the greatest data integrity.</li> </ul> </li> <li> <p>Data Versioning:  Tracking changes to the data allows for efficient synchronization and conflict resolution. Techniques include using revision numbers or timestamps associated with each data record.</p> </li> <li> <p>Offline Capabilities:  Defines what functionalities remain available when offline.  This could range from viewing cached data to performing limited offline edits, with changes synchronized upon reconnection.</p> </li> <li> <p>Network Connectivity Detection:  The application must reliably detect network connectivity changes to seamlessly switch between online and offline modes.</p> </li> </ul> <p>3. Practical Examples</p> <ul> <li> <p>Email Client:  Emails are downloaded and stored locally for offline viewing and composition.  Synchronization occurs when a network connection is available, uploading new emails and downloading any server-side changes.  Conflict resolution might involve prioritizing server-side changes.</p> </li> <li> <p>Note-Taking App:  Notes are stored locally using a database like SQLite.  Synchronization with a cloud service (e.g., Google Drive, Dropbox) occurs periodically or on demand, ensuring data consistency across devices.  A timestamp-based conflict resolution strategy could be employed.</p> </li> <li> <p>Collaborative Document Editor:  Requires sophisticated bi-directional synchronization and a merge strategy for handling concurrent edits from multiple users.  Operational Transformation (OT) is a common approach used to minimize conflicts.</p> </li> <li> <p>Mobile Game with Leaderboard:  High scores are stored locally until an internet connection is established, at which point they are uploaded to a server and the leaderboard is updated.  A last-write-wins strategy might be acceptable in this case due to the nature of the data.</p> </li> </ul> <p>4. Conclusion</p> <p>Implementing robust offline support and data synchronization requires a thorough understanding of data storage mechanisms, synchronization strategies, and conflict resolution techniques.  The choice of approach depends heavily on the specific application and its requirements.  Careful consideration of user experience is paramount; seamless transitions between online and offline modes are vital for ensuring user satisfaction and application success.  Developing effective offline features adds significant complexity, but it significantly enhances application usability and resilience, making it a valuable investment for many applications.</p>"},{"location":"notes/react-native/Over-the-Air_OTA_updates_with_Expo_Application_Ser/","title":"Over the Air OTA updates with Expo Application Ser","text":"<p>\u26a0\ufe0f Error generating content: 404 Publisher Model <code>projects/generativelanguage-ga/locations/us-central1/publishers/google/models/gemini-1.5-flash-002</code> was not found or your project does not have access to it. Please ensure you are using a valid model version. For more information, see: https://cloud.google.com/vertex-ai/generative-ai/docs/learn/model-versions</p>"},{"location":"notes/react-native/Passing_parameters_between_screens/","title":"Passing parameters between screens","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react-native/Performance_Optimization_Why_did_you_render_Flippe/","title":"Performance Optimization Why did you render Flippe","text":""},{"location":"notes/react-native/Performance_Optimization_Why_did_you_render_Flippe/#performance-optimization-why-did-you-render-flipper","title":"Performance Optimization (Why Did You Render?, Flipper)","text":"<p>## 1. Introduction</p> <p>React applications, while powerful and flexible, can suffer performance bottlenecks if not carefully optimized.  Unnecessary re-renders are a common culprit, leading to sluggish interfaces and a poor user experience.  Tools like Flipper provide invaluable insights into the rendering process, helping developers pinpoint and resolve these issues. This document explores common causes of excessive rendering in React, techniques for optimization, and how Flipper can assist in the debugging process.  Understanding \"why did you render\" is crucial for building high-performing React applications.  We will focus on minimizing unnecessary re-renders to improve overall application speed and responsiveness.</p> <p>## 2. Core Concepts</p> <p>This section outlines key concepts related to React rendering and optimization.</p> <ul> <li> <p>Virtual DOM: React uses a virtual DOM (Document Object Model) to minimize direct manipulation of the real DOM. Changes are first calculated in the virtual DOM, and only necessary updates are applied to the real DOM, improving performance.</p> </li> <li> <p>Reconciliation:  The process of comparing the previous virtual DOM with the updated one to determine what changes need to be applied to the real DOM.  This is where optimization efforts are primarily focused.</p> </li> <li> <p>Re-renders:  When a component's props or state change, React initiates a reconciliation process, potentially leading to a re-render.  The goal is to minimize these re-renders to only when absolutely necessary.</p> </li> <li> <p><code>shouldComponentUpdate</code> (Legacy):  A lifecycle method (now largely superseded by other techniques) that allows developers to control whether a component should re-render based on prop and state changes.  Returning <code>false</code> prevents re-rendering.  However, this method is less preferred due to potential for errors and difficulty maintaining.</p> </li> <li> <p>React.memo:  A higher-order component (HOC) that memoizes a component's output. It prevents re-rendering if the props haven't changed using a shallow comparison.  This is a preferred method for functional components.</p> </li> <li> <p>useMemo:  A React Hook that memoizes the result of a computationally expensive function.  This is ideal for preventing recalculations when inputs haven't changed.</p> </li> <li> <p>useCallback:  A React Hook that memoizes a callback function. This prevents unnecessary recreations of callback functions, which might trigger parent component re-renders.</p> </li> <li> <p>Pure Components: Classes extending <code>React.PureComponent</code> perform shallow comparisons of props and state before rendering, similar to <code>React.memo</code>. This approach is less common with the rise of functional components and hooks.</p> </li> <li> <p>Keys:  Essential for efficient list rendering.  Unique keys help React identify which items have changed, added, or removed, resulting in more targeted updates.</p> </li> <li> <p>Fragment:  Allows rendering multiple elements without adding extra nodes to the DOM.</p> </li> <li> <p>React Profiler: Built-in React tool within the developer tools to identify performance bottlenecks.  It provides a flame graph visualizing rendering times and helping pinpoint slow components.</p> </li> </ul> <p>## 3. Practical Examples</p> <p>Example 1: Inefficient Rendering</p> <pre><code>function MyComponent(props) {\n  console.log(\"Rendered!\"); // This will log excessively!\n  return &lt;div&gt;{props.count}&lt;/div&gt;;\n}\n</code></pre> <p>If <code>props.count</code> changes frequently, this component will re-render every time, even if the visual output remains the same.</p> <p>Example 2: Optimizing with <code>React.memo</code></p> <pre><code>const MyComponent = React.memo((props) =&gt; {\n  console.log(\"Rendered!\");\n  return &lt;div&gt;{props.count}&lt;/div&gt;;\n});\n</code></pre> <p>Now, <code>MyComponent</code> only re-renders if <code>props.count</code> changes.  <code>React.memo</code> performs a shallow comparison.</p> <p>Example 3: Optimizing with <code>useMemo</code></p> <pre><code>function ExpensiveComponent({ data }) {\n  const expensiveCalculation = useMemo(() =&gt; {\n    // Perform a complex calculation here\n    return expensiveCalculation(data);\n  }, [data]);\n\n  return &lt;div&gt;{expensiveCalculation}&lt;/div&gt;;\n}\n</code></pre> <p><code>expensiveCalculation</code> is only recalculated when <code>data</code> changes.</p> <p>Example 4: Using Keys in Lists</p> <pre><code>const MyList = ({ items }) =&gt; {\n  return (\n    &lt;ul&gt;\n      {items.map((item) =&gt; (\n        &lt;li key={item.id}&gt;{item.name}&lt;/li&gt; // Crucial for efficient updates\n      ))}\n    &lt;/ul&gt;\n  );\n};\n</code></pre> <p>Unique <code>key</code> props (e.g., item IDs) are crucial for efficient list rendering.</p> <p>Flipper's Role:  Flipper's Inspector tab allows examination of component props and state, helping identify unnecessary updates.  Its performance profiler helps pinpoint performance bottlenecks within the application, aiding in the identification of components causing excessive re-renders.  The \"Why did you render?\" feature within Flipper (or similar React Developer Tools features) provides a detailed breakdown of why a component re-rendered, highlighting specific prop or state changes that triggered the update.</p> <p>## 4. Conclusion</p> <p>Optimizing React application performance requires a multifaceted approach. Understanding the rendering lifecycle, utilizing techniques like <code>React.memo</code>, <code>useMemo</code>, <code>useCallback</code>, and employing appropriate keys are crucial for minimizing unnecessary re-renders. Tools like Flipper (and the React Developer Tools) are invaluable in diagnosing performance issues.  By strategically applying these optimization techniques and leveraging debugging tools, developers can significantly improve the responsiveness and overall user experience of their React applications.  Remember to profile your application to identify the most significant performance bottlenecks before focusing on optimization.</p>"},{"location":"notes/react-native/Platform-Specific_Code_Platform_module/","title":"Platform Specific Code Platform module","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react-native/React_Navigation_The_standard_solution/","title":"React Navigation The standard solution","text":""},{"location":"notes/react-native/React_Navigation_The_standard_solution/#react-navigation-the-standard-solution","title":"React Navigation: The Standard Solution","text":"<p>Study Notes</p> <p>1. Introduction</p> <p>React Navigation is the most popular library for navigation in React Native applications.  It provides a robust and flexible way to manage the flow of screens within your app, offering a declarative approach that simplifies complex navigation scenarios.  Unlike implementing navigation manually, React Navigation handles various aspects including screen transitions, screen stack management, and parameter passing, allowing developers to focus on building the app's core features.  Its extensive documentation and large community support make it an ideal choice for projects of all sizes, from small prototypes to large-scale applications.  This document will explore its core concepts and provide practical examples to solidify understanding.</p> <p>2. Core Concepts</p> <ul> <li> <p>Navigators:  These are the fundamental building blocks of React Navigation.  They define the structure and behavior of your navigation hierarchy. Key navigator types include:</p> <ul> <li><code>StackNavigator</code>:  Manages screens in a stack-like manner.  This is the most common navigator, used for creating the typical screen-pushing and -popping behavior.  It supports features like screen header customization, transition animations, and screen options.</li> <li><code>TabNavigator</code>:  Provides a tab bar at the bottom (or top) of the screen, allowing users to switch between different screens. Ideal for representing distinct sections within an app.</li> <li><code>DrawerNavigator</code>:  Presents a side-drawer menu that allows access to various sections of the app. Useful for applications with many screens or complex hierarchies.</li> <li><code>BottomTabNavigator</code> (deprecated): Functionality now included in <code>TabNavigator</code>.</li> <li><code>SwitchNavigator</code>: Now deprecated, its functionality is absorbed into other navigators.</li> </ul> </li> <li> <p>Screens: These are the individual views within your application.  Each screen is a React component that renders its content.  Screens are associated with navigators, defining their position within the navigation hierarchy.</p> </li> <li> <p>Routes: These define the paths to different screens within your application.  Routes are configured within the navigator, mapping URLs or identifiers to specific screen components.</p> </li> <li> <p>Navigation Actions: These are functions that modify the navigation state, such as pushing a new screen onto the stack (<code>navigation.navigate</code>), popping the current screen (<code>navigation.goBack</code>), or replacing the current screen (<code>navigation.replace</code>).  Actions are triggered by user interactions (e.g., button presses) or programmatically.</p> </li> <li> <p>Navigation Parameters: Data passed between screens.  This enables communication and data sharing across different parts of the application.  Parameters are passed as key-value pairs using the <code>params</code> property during navigation.</p> </li> <li> <p>Navigation Prop:  A prop injected into each screen component, providing access to navigation actions and parameters. This prop is essential for interacting with the navigator and managing screen transitions.</p> </li> </ul> <p>3. Practical Examples</p> <p>(a) Basic Stack Navigation:</p> <pre><code>import { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport HomeScreen from './HomeScreen';\nimport DetailsScreen from './DetailsScreen';\n\nconst Stack = createNativeStackNavigator();\n\nfunction App() {\n  return (\n    &lt;Stack.Navigator&gt;\n      &lt;Stack.Screen name=\"Home\" component={HomeScreen} /&gt;\n      &lt;Stack.Screen name=\"Details\" component={DetailsScreen} /&gt;\n    &lt;/Stack.Navigator&gt;\n  );\n}\n</code></pre> <p>This code creates a simple stack navigator with two screens, \"Home\" and \"Details.\"  Navigating to \"Details\" from \"Home\" would involve:</p> <pre><code>&lt;Button title=\"Go to Details\" onPress={() =&gt; navigation.navigate('Details')} /&gt;\n</code></pre> <p>(b) Passing Parameters:</p> <pre><code>// In HomeScreen\n&lt;Button title=\"Go to Details\" onPress={() =&gt; navigation.navigate('Details', { itemId: 86, otherParam: 'anything you want here' })} /&gt;\n\n// In DetailsScreen\nconst { itemId, otherParam } = route.params;\n</code></pre> <p>(c) Tab Navigation:</p> <pre><code>import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\n\nconst Tab = createBottomTabNavigator();\n\nfunction App() {\n  return (\n    &lt;Tab.Navigator&gt;\n      &lt;Tab.Screen name=\"Home\" component={HomeScreen} /&gt;\n      &lt;Tab.Screen name=\"Settings\" component={SettingsScreen} /&gt;\n    &lt;/Tab.Navigator&gt;\n  );\n}\n</code></pre> <p>4. Conclusion</p> <p>React Navigation offers a powerful and intuitive way to manage navigation in React Native apps. Its flexible architecture, coupled with its extensive features and large community support, makes it the preferred choice for many developers.  Mastering its core concepts \u2013 navigators, screens, routes, actions, and parameters \u2013 is crucial for creating well-structured and user-friendly React Native applications.  Further exploration of its advanced features, such as custom transitions and screen options, will enhance your ability to build sophisticated and engaging mobile experiences.  Remember to consult the official documentation for the most up-to-date information and detailed examples.</p>"},{"location":"notes/react-native/Setting_up_the_Development_Environment_Expo_Go_Rea/","title":"Setting up the Development Environment Expo Go Rea","text":""},{"location":"notes/react-native/Setting_up_the_Development_Environment_Expo_Go_Rea/#setting-up-the-development-environment-for-react-native-expo-go-react-native-cli","title":"Setting up the Development Environment for React Native: Expo Go &amp; React Native CLI","text":"<p>## 1. Introduction</p> <p>React Native allows developers to build cross-platform mobile applications using JavaScript and React.  Two primary methods exist for setting up a React Native development environment: Expo Go and the React Native CLI (Command Line Interface).  This document outlines the advantages and disadvantages of each approach and provides step-by-step instructions for setting up both.  Choosing the right method depends on your project's complexity and specific needs.  Expo Go offers a simpler, faster setup ideal for beginners and smaller projects with limited native module requirements. The React Native CLI provides more control and flexibility, necessary for complex apps requiring access to native device features beyond Expo's managed workflow.</p> <p>## 2. Core Concepts</p> <p>A. Expo Go:</p> <ul> <li>Managed Workflow: Expo Go utilizes a managed workflow.  Expo handles most of the native code and build processes, simplifying development and deployment.</li> <li>Ease of Use:  Ideal for beginners due to its straightforward setup and simplified development process.  No need to configure Xcode or Android Studio directly.</li> <li>Limited Native Module Access:  Expo's managed workflow restricts access to certain native device features. If your app requires functionalities not supported by Expo, you might need to eject to a bare workflow (which is significantly more complex).</li> <li>Expo Client App: Requires installing the Expo Go app on your mobile device to test and run your application. Changes require a restart of the app.</li> <li>Faster Development Cycle:  Faster iteration and testing due to hot reloading capabilities within the Expo Go client.</li> </ul> <p>B. React Native CLI:</p> <ul> <li>Bare Workflow: Offers a bare workflow, granting complete control over the native code and build processes.</li> <li>Full Native Module Access: Allows access to all native device features and APIs.  This is essential for apps requiring deep integration with the device's hardware or operating system.</li> <li>Steeper Learning Curve: Requires familiarity with Xcode (iOS) and Android Studio (Android) for building and debugging.  More complex setup and configuration.</li> <li>Manual Configuration: You'll need to configure native projects manually, potentially dealing with Android SDK, NDK, Gradle, and Xcode build settings.</li> <li>More Control and Flexibility: Provides more control over the app's build process and enables greater customization.</li> </ul> <p>C. Key Differences Summarized:</p> Feature Expo Go React Native CLI Workflow Managed Bare Setup Complexity Easy Complex Native Module Access Limited Full Debugging Simpler, within Expo Go app More complex, using Xcode/Android Studio debuggers Deployment Easy (Expo Go, EAS Build) More complex (manual signing, app stores) Ideal for Beginners, smaller projects Complex projects, specific native needs <p>## 3. Practical Examples</p> <p>A. Setting up Expo Go:</p> <ol> <li>Install Node.js and npm (or yarn):  Ensure you have Node.js and npm (or yarn) installed on your system.</li> <li>Install Expo CLI: <code>npm install -g expo-cli</code></li> <li>Create a new project: <code>expo init my-expo-app</code> (choose a template, e.g., \"blank (TypeScript)\")</li> <li>Install dependencies: <code>cd my-expo-app &amp;&amp; npm install</code></li> <li>Start the development server: <code>npm start</code></li> <li>Scan QR code: Scan the QR code displayed in your terminal using the Expo Go app on your phone.</li> </ol> <p>B. Setting up React Native CLI:</p> <ol> <li>Install Node.js and npm (or yarn):  Ensure Node.js and npm (or yarn) are installed.</li> <li>Install React Native CLI: <code>npm install -g react-native-cli</code></li> <li>Create a new project: <code>react-native init my-react-native-app</code> (choose a template, e.g., --template react-native-template-typescript)</li> <li>Install dependencies: <code>cd my-react-native-app &amp;&amp; npm install</code></li> <li>Configure Android (Android Studio):  Set up the Android SDK, NDK, and Gradle. Open the <code>android</code> folder in Android Studio and follow any necessary configuration steps.</li> <li>Configure iOS (Xcode): Open the <code>ios</code> folder in Xcode and resolve any potential issues.</li> <li>Start the development server: <code>npm start</code> or <code>npx react-native start</code></li> <li>Run on devices/emulators: Use the <code>react-native run-android</code> or <code>react-native run-ios</code> commands.</li> </ol> <p>## 4. Conclusion</p> <p>Expo Go provides a rapid and easy entry point into React Native development, ideal for learning and smaller projects.  However, for applications needing extensive native functionality or fine-grained control over the build process, the React Native CLI is necessary, despite its steeper learning curve. The choice depends on the project's requirements and the developer's experience level.  Understanding the strengths and limitations of both approaches is crucial for making the right decision for your specific needs. Remember to consult the official React Native and Expo documentation for the most up-to-date instructions and troubleshooting assistance.</p>"},{"location":"notes/react-native/Stack_Navigator_for_screen-based_flows/","title":"Stack Navigator for screen based flows","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react-native/Structuring_a_React_Native_project/","title":"Structuring a React Native project","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react-native/Testing_with_Jest_and_React_Native_Testing_Library/","title":"Testing with Jest and React Native Testing Library","text":""},{"location":"notes/react-native/Testing_with_Jest_and_React_Native_Testing_Library/#testing-with-jest-and-react-native-testing-library-premium-study-notes","title":"Testing with Jest and React Native Testing Library: Premium Study Notes","text":"<p>1. Introduction</p> <p>Testing is crucial for building robust and reliable React Native applications.  Jest, Facebook's JavaScript testing framework, provides a powerful and versatile environment for writing tests.  React Native Testing Library (RTL) builds upon Jest, offering a high-level API focused on testing components from a user's perspective, rather than their implementation details.  This approach leads to more maintainable and resilient tests that are less likely to break with minor code changes.  Together, Jest and RTL form a cornerstone of best practices for React Native development. This document outlines core concepts and practical examples to solidify your understanding.</p> <p>2. Core Concepts</p> <ul> <li> <p>Jest:</p> <ul> <li>Test Runner: Executes tests and provides a clear report on successes and failures.</li> <li>Assertion Library: Provides functions like <code>expect()</code> to compare values and verify expectations.  Matchers like <code>toBe</code>, <code>toEqual</code>, <code>toContain</code>, etc., allow for precise comparisons.</li> <li>Mocking:  Allows simulating external dependencies (APIs, timers, modules) to isolate component logic during testing.  <code>jest.mock()</code> is a key function for this.</li> <li>Snapshot Testing: Captures the rendered output of a component and compares it to a previously saved snapshot.  Useful for quickly detecting UI regressions, but should be used judiciously and snapshots reviewed regularly.</li> <li>Setup and Teardown: <code>beforeEach</code>, <code>afterEach</code>, <code>beforeAll</code>, <code>afterAll</code> lifecycle functions allow for setting up test environments and cleaning up after tests.</li> </ul> </li> <li> <p>React Native Testing Library (RTL):</p> <ul> <li>User-centric Testing: Encourages testing from the user's perspective, focusing on interactions and observable outcomes.  This reduces coupling to implementation details.</li> <li>Querying:  Provides methods like <code>render</code>, <code>fireEvent</code>, <code>screen.getByRole</code>, <code>screen.getByText</code>, <code>screen.queryBy...</code> etc. to interact with and query rendered components.  <code>getBy...</code> throws an error if the element isn't found; <code>queryBy...</code> returns null.  This distinction is important for handling optional UI elements.</li> <li>Accessibility: RTL emphasizes accessibility best practices by encouraging the use of semantic HTML attributes and querying based on roles, labels, and text content.</li> <li>Less Coupling: Tests are less likely to break when internal component structure changes, as they focus on user-facing behavior.</li> </ul> </li> <li> <p>Key Differences from Enzyme: While Enzyme was a popular testing library, RTL is now preferred due to its user-centric approach, better alignment with accessibility standards, and less reliance on internal component implementation details.</p> </li> </ul> <p>3. Practical Examples</p> <p>Let's assume we have a simple counter component:</p> <pre><code>// Counter.js\nimport React, { useState } from 'react';\nimport { Button, Text, View } from 'react-native';\n\nconst Counter = () =&gt; {\n  const [count, setCount] = useState(0);\n  return (\n    &lt;View&gt;\n      &lt;Text&gt;Count: {count}&lt;/Text&gt;\n      &lt;Button title=\"Increment\" onPress={() =&gt; setCount(count + 1)} /&gt;\n    &lt;/View&gt;\n  );\n};\n\nexport default Counter;\n</code></pre> <p>Here's how to test it using Jest and RTL:</p> <pre><code>// Counter.test.js\nimport React from 'react';\nimport { render, fireEvent, screen } from '@testing-library/react-native';\nimport Counter from './Counter';\n\ntest('Counter increments correctly', () =&gt; {\n  render(&lt;Counter /&gt;);\n  const button = screen.getByText('Increment'); //Find button by text\n  expect(screen.getByText('Count: 0')).toBeTruthy(); //Initial count\n  fireEvent.press(button);\n  expect(screen.getByText('Count: 1')).toBeTruthy(); //Count after increment\n});\n</code></pre> <p>This test renders the <code>Counter</code> component, finds the button using <code>getByText</code>, simulates a press using <code>fireEvent.press</code>, and then asserts that the count has incremented.  Note how the test interacts with the component as a user would.</p> <p>Further Examples (Expand upon these):</p> <ul> <li>Testing asynchronous operations (fetching data):  Use <code>async/await</code> and Jest's mocking capabilities to simulate API calls.</li> <li>Testing input fields: Use <code>fireEvent.changeText</code> to simulate user input and verify state updates.</li> <li>Testing navigation: If using a navigation library, test navigation actions using appropriate methods provided by the library.</li> <li>Testing complex interactions: Break down complex interactions into smaller, more manageable test cases.</li> </ul> <p>4. Conclusion</p> <p>Jest and React Native Testing Library provide a powerful and effective combination for writing high-quality tests for React Native applications.  By focusing on user-centric testing and minimizing reliance on implementation details, you can create a robust test suite that is maintainable, reliable, and helps ensure the quality and stability of your application.  Remember to write tests early and often, integrating them into your development workflow to catch bugs and regressions before they reach production.  This approach ultimately saves time and resources in the long run.</p>"},{"location":"notes/react-native/Understanding_Core_Components_View_Text_Image_Styl/","title":"Understanding Core Components View Text Image Styl","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react-native/Using_the_Camera_and_Photo_Library/","title":"Using the Camera and Photo Library","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"},{"location":"notes/react-native/Working_with_gestures_Gesture_Handler/","title":"Working with gestures Gesture Handler","text":"<p>\u26a0\ufe0f Error generating content: 404 models/gemini-1.5-flash is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.</p>"}]}